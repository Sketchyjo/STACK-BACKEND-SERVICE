[
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "f4baeaf6-6a4e-42df-8614-70542c86fe65",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC001-user registration with valid and invalid inputs",
    "description": "Test the user registration endpoint with valid email and password to ensure successful registration. Also test with missing or invalid fields to verify proper error handling and duplicate user registration attempts.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\nHEADERS_JSON = {'Content-Type': 'application/json'}\n\ndef test_user_registration_with_valid_and_invalid_inputs():\n    created_users = []\n    try:\n        # 1. Valid user registration (email + password)\n        valid_email = f\"testuser_{uuid.uuid4()}@example.com\"\n        valid_password = \"TestPass123!\"\n        payload = {\"email\": valid_email, \"password\": valid_password}\n        resp = requests.post(f\"{BASE_URL}/api/v1/auth/register\", json=payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Expected 201 Created, got {resp.status_code}, content: {resp.text}\"\n        created_users.append(valid_email)\n\n        # 2. Attempt duplicate registration with the same email (should return 409)\n        resp_dup = requests.post(f\"{BASE_URL}/api/v1/auth/register\", json=payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert resp_dup.status_code == 409, f\"Expected 409 Conflict on duplicate registration, got {resp_dup.status_code}\"\n\n        # 3. Registration missing required field: no password\n        payload_missing_password = {\"email\": f\"nopass_{uuid.uuid4()}@example.com\"}\n        resp_missing_pw = requests.post(f\"{BASE_URL}/api/v1/auth/register\", json=payload_missing_password, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert resp_missing_pw.status_code == 400, f\"Expected 400 Bad Request for missing password, got {resp_missing_pw.status_code}\"\n\n        # 4. Registration missing required field: no email\n        payload_missing_email = {\"password\": \"SomePassword123\"}\n        resp_missing_email = requests.post(f\"{BASE_URL}/api/v1/auth/register\", json=payload_missing_email, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert resp_missing_email.status_code == 400, f\"Expected 400 Bad Request for missing email, got {resp_missing_email.status_code}\"\n\n        # 5. Registration with invalid email format\n        payload_invalid_email = {\"email\": \"invalid-email-format\", \"password\": \"Password123\"}\n        resp_invalid_email = requests.post(f\"{BASE_URL}/api/v1/auth/register\", json=payload_invalid_email, headers=HEADERS_JSON, timeout=TIMEOUT)\n        # Accept either 400 or 422 depending on schema validation\n        assert resp_invalid_email.status_code in [400, 422], f\"Expected 400 or 422 for invalid email format, got {resp_invalid_email.status_code}\"\n\n        # 6. Registration with phone only (email still required so expect 400)\n        payload_phone_only = {\"phone\": \"+1234567890\"}\n        resp_phone_only = requests.post(f\"{BASE_URL}/api/v1/auth/register\", json=payload_phone_only, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert resp_phone_only.status_code == 400, f\"Expected 400 Bad Request when email missing, got {resp_phone_only.status_code}\"\n\n        # 7. Registration with email and phone (phone nullable)\n        valid_email2 = f\"testuser2_{uuid.uuid4()}@example.com\"\n        payload_email_phone = {\"email\": valid_email2, \"password\": \"AnotherPass123\", \"phone\": \"+1234567890\"}\n        resp_email_phone = requests.post(f\"{BASE_URL}/api/v1/auth/register\", json=payload_email_phone, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert resp_email_phone.status_code == 201, f\"Expected 201 Created with email and phone, got {resp_email_phone.status_code}\"\n        created_users.append(valid_email2)\n\n    finally:\n        # Clean up created users to maintain environment hygiene if API supports delete (not documented here)\n        # Since no delete user endpoint was documented, we skip deletion.\n        # Typically, cleanup or test isolation should be handled externally or via test DB.\n        pass\n\ntest_user_registration_with_valid_and_invalid_inputs()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 17, in test_user_registration_with_valid_and_invalid_inputs\nAssertionError: Expected 201 Created, got 501, content: {\"error\":\"Not implemented yet\",\"message\":\"User registration endpoint will be implemented\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.173Z",
    "modified": "2025-10-03T17:35:59.568Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "1b258aec-6647-4691-940c-6d95828bd998",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC002-user login with correct and incorrect credentials",
    "description": "Verify the user login endpoint accepts valid email and password combinations and returns a successful response with a token. Test invalid credentials to confirm the system returns unauthorized errors.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\nHEADERS_JSON = {\"Content-Type\": \"application/json\"}\n\ndef test_user_login_with_correct_and_incorrect_credentials():\n    # We will create a unique user for testing login happy path\n    test_email = f\"testuser_{uuid.uuid4()}@example.com\"\n    test_password = \"StrongP@ssw0rd!\"\n    register_url = f\"{BASE_URL}/api/v1/auth/register\"\n    login_url = f\"{BASE_URL}/api/v1/auth/login\"\n\n    # Register the user first to ensure it's in the system\n    register_payload = {\n        \"email\": test_email,\n        \"password\": test_password\n    }\n\n    # Cleanup variable to delete user is not provided by API, so no cleanup here\n    try:\n        # Register user\n        r_register = requests.post(register_url, json=register_payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        # Registration could return 201 (success) or 409 (user exists, unlikely here with unique email)\n        assert r_register.status_code in (201, 409), f\"Unexpected register status {r_register.status_code}, body: {r_register.text}\"\n\n        # Test successful login with correct credentials\n        login_payload = {\n            \"email\": test_email,\n            \"password\": test_password\n        }\n        r_login_success = requests.post(login_url, json=login_payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert r_login_success.status_code == 200, f\"Expected 200 OK on valid login, got {r_login_success.status_code}\"\n        json_resp = r_login_success.json()\n        assert \"token\" in json_resp or \"accessToken\" in json_resp or \"sessionToken\" in json_resp, \\\n            f\"Login success response missing token field: {json_resp}\"\n\n        # Test login with incorrect password (invalid credentials)\n        bad_password_payload = {\n            \"email\": test_email,\n            \"password\": \"WrongPassword123!\"\n        }\n        r_login_fail = requests.post(login_url, json=bad_password_payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert r_login_fail.status_code == 401, f\"Expected 401 Unauthorized for bad password, got {r_login_fail.status_code}\"\n\n        # Test login with non-existent email\n        non_exist_email_payload = {\n            \"email\": f\"nonexistent_{uuid.uuid4()}@example.com\",\n            \"password\": \"AnyPass123!\"\n        }\n        r_login_non_exist = requests.post(login_url, json=non_exist_email_payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        # API doc only states 401 for invalid credentials, so expect 401 here too\n        assert r_login_non_exist.status_code == 401, f\"Expected 401 Unauthorized for non-existent user, got {r_login_non_exist.status_code}\"\n\n        # Test login with missing email field\n        missing_email_payload = {\n            # \"email\" omitted\n            \"password\": \"AnyPass123!\"\n        }\n        r_login_missing_email = requests.post(login_url, json=missing_email_payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        # Spec not explicit, but likely to return 400 Bad Request for missing required fields\n        assert r_login_missing_email.status_code in (400, 422), f\"Expected 400 or 422 Bad Request for missing email, got {r_login_missing_email.status_code}\"\n\n        # Test login with missing password field\n        missing_password_payload = {\n            \"email\": test_email\n            # \"password\" omitted\n        }\n        r_login_missing_password = requests.post(login_url, json=missing_password_payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        assert r_login_missing_password.status_code in (400, 422), f\"Expected 400 or 422 Bad Request for missing password, got {r_login_missing_password.status_code}\"\n\n        # Test login with invalid email format\n        invalid_email_payload = {\n            \"email\": \"not-an-email\",\n            \"password\": \"AnyPass123!\"\n        }\n        r_login_invalid_email = requests.post(login_url, json=invalid_email_payload, headers=HEADERS_JSON, timeout=TIMEOUT)\n        # API spec may respond 400 for invalid format\n        assert r_login_invalid_email.status_code == 400, f\"Expected 400 Bad Request for invalid email, got {r_login_invalid_email.status_code}\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_user_login_with_correct_and_incorrect_credentials()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 85, in <module>\n  File \"<string>\", line 26, in test_user_login_with_correct_and_incorrect_credentials\nAssertionError: Unexpected register status 501, body: {\"error\":\"Not implemented yet\",\"message\":\"User registration endpoint will be implemented\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.179Z",
    "modified": "2025-10-03T17:35:34.301Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "85ad1a9f-901f-4073-ae53-6993842e645c",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC003-start onboarding process with valid and invalid data",
    "description": "Test the onboarding start endpoint by submitting valid email and optional phone number to initiate onboarding. Validate error responses for missing required fields and duplicate user onboarding attempts.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_start_onboarding_process_with_valid_and_invalid_data():\n    \"\"\"\n    Test the onboarding start endpoint by submitting valid email and optional phone number to initiate onboarding.\n    Validate error responses for missing required fields and duplicate user onboarding attempts.\n    \"\"\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Generate a unique email for testing to avoid duplication conflicts on first onboarding\n    unique_email = f\"testuser_{uuid.uuid4()}@example.com\"\n    phone_number = \"+1234567890\"\n\n    # Helper function to start onboarding with given payload\n    def start_onboarding(payload):\n        try:\n            resp = requests.post(\n                f\"{BASE_URL}/api/v1/onboarding/start\",\n                json=payload,\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            return resp\n        except requests.RequestException as e:\n            raise AssertionError(f\"Request failed: {e}\")\n\n    # 1. Happy Path: Valid email only\n    payload_valid_email_only = {\"email\": unique_email}\n    response = start_onboarding(payload_valid_email_only)\n    assert response.status_code == 201, f\"Expected 201, got {response.status_code} with body {response.text}\"\n    json_resp = response.json()\n    assert \"userId\" in json_resp and isinstance(json_resp[\"userId\"], str) and json_resp[\"userId\"]\n    assert \"onboardingStatus\" in json_resp and isinstance(json_resp[\"onboardingStatus\"], str)\n    # nextStep can be any string\n    assert \"nextStep\" in json_resp and isinstance(json_resp[\"nextStep\"], str)\n    # sessionToken could be null or string\n    assert \"sessionToken\" in json_resp\n\n    user_id = json_resp[\"userId\"]\n\n    # 2. Happy Path: Valid email with optional phone number\n    unique_email_2 = f\"testuser_{uuid.uuid4()}@example.com\"\n    payload_valid_email_phone = {\"email\": unique_email_2, \"phone\": phone_number}\n    response = start_onboarding(payload_valid_email_phone)\n    assert response.status_code == 201, f\"Expected 201, got {response.status_code} with body {response.text}\"\n    json_resp = response.json()\n    assert \"userId\" in json_resp\n    assert isinstance(json_resp[\"userId\"], str)\n    assert json_resp[\"userId\"]\n    assert \"onboardingStatus\" in json_resp and isinstance(json_resp[\"onboardingStatus\"], str)\n    assert \"nextStep\" in json_resp\n    assert \"sessionToken\" in json_resp\n\n    # 3. Error Case: Missing required field email\n    payload_missing_email = {\"phone\": phone_number}\n    response = start_onboarding(payload_missing_email)\n    assert response.status_code == 400, f\"Expected 400 for missing email, got {response.status_code}\"\n\n    # 4. Error Case: Duplicate onboarding attempt with same email\n    # Using the first valid email to trigger conflict\n    response = start_onboarding(payload_valid_email_only)\n    assert response.status_code == 409, f\"Expected 409 for duplicate user, got {response.status_code}\"\n\n    # 5. Error Case: Invalid email format\n    payload_invalid_email = {\"email\": \"not-an-email\"}\n    response = start_onboarding(payload_invalid_email)\n    assert response.status_code == 400, f\"Expected 400 for invalid email format, got {response.status_code}\"\n\n    # 6. Error Case: Empty email string\n    payload_empty_email = {\"email\": \"\"}\n    response = start_onboarding(payload_empty_email)\n    assert response.status_code == 400, f\"Expected 400 for empty email, got {response.status_code}\"\n\n    # 7. Edge Case: Null phone explicitly sent (should pass because phone is optional and nullable)\n    payload_null_phone = {\"email\": f\"testuser_{uuid.uuid4()}@example.com\", \"phone\": None}\n    response = start_onboarding(payload_null_phone)\n    assert response.status_code == 201, f\"Expected 201 when phone is null, got {response.status_code}\"\n\ntest_start_onboarding_process_with_valid_and_invalid_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 84, in <module>\n  File \"<string>\", line 35, in test_start_onboarding_process_with_valid_and_invalid_data\nAssertionError: Expected 201, got 404 with body 404 page not found\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.184Z",
    "modified": "2025-10-03T17:35:34.305Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "e9732170-b6d8-496d-892d-d14f3e929c01",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC004-retrieve onboarding status with valid and invalid user ids",
    "description": "Verify the onboarding status endpoint returns correct onboarding, KYC, and wallet provisioning status for valid user IDs. Test invalid or non-existent user IDs to ensure proper error responses.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_retrieve_onboarding_status_with_valid_and_invalid_user_ids():\n    # Step 1: Create a new user onboarding to get a valid userId and auth token\n    email = f\"testuser+{uuid.uuid4()}@example.com\"\n    signup_payload = {\n        \"email\": email\n    }\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Start onboarding\n    resp_start = requests.post(f\"{BASE_URL}/api/v1/onboarding/start\", json=signup_payload, headers=headers, timeout=TIMEOUT)\n    assert resp_start.status_code == 201, f\"Onboarding start failed: {resp_start.text}\"\n    data_start = resp_start.json()\n\n    user_id = data_start.get(\"userId\")\n    assert user_id is not None, \"userId missing in onboarding start response\"\n    session_token = data_start.get(\"sessionToken\")\n    # sessionToken may be nullable, fallback to login if needed\n\n    # Step 2: Authenticate to get a bearer token\n    # Since KYC verification and OTP/email verification is described as required before continuing,\n    # but no direct login or verification endpoint is described for continued steps,\n    # we will assume for test purposes that onboarding start returns a sessionToken usable as bearer token.\n    # If sessionToken is None, will try login (not mandatory in PRD for onboarding) - here we skip that due to test scope\n\n    assert session_token is not None, \"Session token is required for authenticated requests\"\n\n    auth_headers = {\n        \"Authorization\": f\"Bearer {session_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        # Wait some seconds to simulate any processing delays for provisioning or KYC (optional, can be skipped)\n        time.sleep(2)\n\n        # Step 3: Retrieve onboarding status with valid user ID\n        params_valid = {\"user_id\": user_id}\n        resp_status_valid = requests.get(f\"{BASE_URL}/api/v1/onboarding/status\", headers=auth_headers, params=params_valid, timeout=TIMEOUT)\n        assert resp_status_valid.status_code == 200, f\"Failed to get onboarding status for valid user_id: {resp_status_valid.text}\"\n        data_status_valid = resp_status_valid.json()\n\n        # Validate required fields in response for valid user ID\n        assert data_status_valid.get(\"userId\") == user_id, \"Returned userId does not match\"\n        # onboardingStatus, kycStatus should be present and strings\n        assert isinstance(data_status_valid.get(\"onboardingStatus\"), str), \"onboardingStatus missing or invalid\"\n        assert isinstance(data_status_valid.get(\"kycStatus\"), str), \"kycStatus missing or invalid\"\n        # walletStatus may be null or object if provisioning done\n        wallet_status = data_status_valid.get(\"walletStatus\")\n        if wallet_status is not None:\n            assert isinstance(wallet_status, dict), \"walletStatus should be an object or null\"\n        # canProceed boolean\n        assert isinstance(data_status_valid.get(\"canProceed\"), bool), \"canProceed missing or not boolean\"\n        # completedSteps is list of strings\n        completed_steps = data_status_valid.get(\"completedSteps\")\n        assert isinstance(completed_steps, list), \"completedSteps missing or not list\"\n        for step in completed_steps:\n            assert isinstance(step, str), \"completedSteps items must be strings\"\n        # requiredActions is list of strings\n        required_actions = data_status_valid.get(\"requiredActions\")\n        assert isinstance(required_actions, list), \"requiredActions missing or not list\"\n        for action in required_actions:\n            assert isinstance(action, str), \"requiredActions items must be strings or empty list\"\n\n        # Step 4: Test invalid user IDs for error responses\n        invalid_user_ids = [\n            \"not-a-uuid\",\n            str(uuid.uuid4()),  # random UUID not associated with any user\n            \"\",  # empty string\n            \"00000000-0000-0000-0000-000000000000\"  # all zeros UUID\n        ]\n\n        for invalid_id in invalid_user_ids:\n            params_invalid = {\"user_id\": invalid_id}\n            resp_invalid = requests.get(f\"{BASE_URL}/api/v1/onboarding/status\", headers=auth_headers, params=params_invalid, timeout=TIMEOUT)\n            if invalid_id == \"not-a-uuid\" or invalid_id == \"\":\n                # Expect 400 Bad Request for invalid format\n                assert resp_invalid.status_code == 400, f\"Expected 400 for invalid user_id format '{invalid_id}', got {resp_invalid.status_code}\"\n            else:\n                # Expect 404 Not Found for valid UUID format but nonexistent user\n                # The zero UUID may be considered invalid or not found, test both cases\n                assert resp_invalid.status_code in (400, 404), f\"Expected 400 or 404 for user_id '{invalid_id}', got {resp_invalid.status_code}\"\n\n    finally:\n        # Clean up: API does not provide explicit user delete, best effort skip\n        pass\n\ntest_retrieve_onboarding_status_with_valid_and_invalid_user_ids()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 97, in <module>\n  File \"<string>\", line 21, in test_retrieve_onboarding_status_with_valid_and_invalid_user_ids\nAssertionError: Onboarding start failed: 404 page not found\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.190Z",
    "modified": "2025-10-03T17:35:34.287Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "8637b4b4-62f8-42ef-af4b-605281dec2f0",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC005-submit kyc documents with complete and incomplete data",
    "description": "Test the KYC document submission endpoint with all required fields and valid document URLs to ensure acceptance. Validate error handling for missing required fields, invalid data, and unauthorized submissions.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n\ndef test_submit_kyc_documents_complete_incomplete():\n    \"\"\"\n    Test the KYC document submission endpoint with complete and incomplete data,\n    including valid/invalid document URLs and unauthorized submissions.\n    \"\"\"\n\n    # Helper function to register and start onboarding\n    def register_and_start_onboarding(email, phone=None):\n        # Register user\n        register_payload = {\n            \"email\": email,\n            \"password\": \"TestPass123!\"\n        }\n        register_resp = requests.post(\n            f\"{BASE_URL}/api/v1/auth/register\",\n            json=register_payload,\n            timeout=TIMEOUT,\n        )\n        # 409 if user exists, ignore for reruns\n        assert register_resp.status_code in (201, 409), f\"Registration failed: {register_resp.text}\"\n\n        # Start onboarding\n        onboarding_payload = {\n            \"email\": email,\n        }\n        if phone:\n            onboarding_payload[\"phone\"] = phone\n\n        onboarding_resp = requests.post(\n            f\"{BASE_URL}/api/v1/onboarding/start\",\n            json=onboarding_payload,\n            timeout=TIMEOUT,\n        )\n        assert onboarding_resp.status_code == 201, f\"Onboarding start failed: {onboarding_resp.text}\"\n        onboarding_data = onboarding_resp.json()\n        assert \"userId\" in onboarding_data\n        assert \"onboardingStatus\" in onboarding_data\n\n        return onboarding_data\n\n    # Helper function to login and get bearer token\n    def login_and_get_token(email):\n        login_payload = {\n            \"email\": email,\n            \"password\": \"TestPass123!\"\n        }\n        login_resp = requests.post(\n            f\"{BASE_URL}/api/v1/auth/login\",\n            json=login_payload,\n            timeout=TIMEOUT,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data or \"accessToken\" in login_data or \"sessionToken\" in login_data or \"jwt\" in login_data or \"bearer\" in login_data\n        # Try to find token key\n        token = login_data.get(\"token\") or login_data.get(\"accessToken\") or login_data.get(\"sessionToken\") or login_data.get(\"jwt\") or login_data.get(\"bearer\")\n        # Some endpoints return sessionToken on onboarding, use that if login not present\n        if not token:\n            token = onboarding_data.get(\"sessionToken\")\n        assert token is not None, \"No token found in login response\"\n        return token\n\n    # Helper function to submit KYC documents\n    def submit_kyc(token, payload):\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n        return requests.post(\n            f\"{BASE_URL}/api/v1/onboarding/kyc/submit\",\n            json=payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n\n    # Generate a unique email for testing\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n\n    # Register, start onboarding\n    onboarding_data = register_and_start_onboarding(unique_email)\n\n    # Wait briefly (simulate verification step - not described in API so we assume manual or auto complete)\n    # For testing purposes, assume user is now authorized to submit KYC after onboarding start\n    # If verification required, real flow would be more complex.\n\n    # Login to get auth token\n    token = login_and_get_token(unique_email)\n\n    # Prepare valid KYC submission payload (complete data)\n    valid_kyc_payload = {\n        \"documentType\": \"passport\",\n        \"documents\": [\n            {\n                \"type\": \"id_front\",\n                \"fileUrl\": \"https://example.com/docs/id_front.jpg\",\n                \"contentType\": \"image/jpeg\"\n            },\n            {\n                \"type\": \"selfie\",\n                \"fileUrl\": \"https://example.com/docs/selfie.jpg\",\n                \"contentType\": \"image/jpeg\"\n            }\n        ],\n        \"personalInfo\": {\n            \"firstName\": \"Test\",\n            \"lastName\": \"User\",\n            \"dateOfBirth\": \"1990-01-01T00:00:00Z\",\n            \"country\": \"US\",\n            \"address\": {\n                \"street\": \"123 Test St\",\n                \"city\": \"Testville\",\n                \"postalCode\": \"12345\",\n                \"country\": \"US\"\n            }\n        },\n        \"metadata\": {\n            \"note\": \"Test submission complete data\"\n        }\n    }\n\n    # Submit valid KYC documents - expect 202 Accepted\n    resp_valid = submit_kyc(token, valid_kyc_payload)\n    assert resp_valid.status_code == 202, f\"Valid KYC submission failed: {resp_valid.text}\"\n\n    # Prepare incomplete KYC payloads (various cases)\n\n    incomplete_payloads = [\n        # Missing required 'documentType'\n        {\n            \"documents\": [\n                {\n                    \"type\": \"id_front\",\n                    \"fileUrl\": \"https://example.com/docs/id_front.jpg\",\n                    \"contentType\": \"image/jpeg\"\n                }\n            ]\n        },\n        # Missing required 'documents'\n        {\n            \"documentType\": \"passport\"\n        },\n        # Invalid document URL (non-URI format)\n        {\n            \"documentType\": \"passport\",\n            \"documents\": [\n                {\n                    \"type\": \"id_front\",\n                    \"fileUrl\": \"not-a-valid-url\",\n                    \"contentType\": \"image/jpeg\"\n                }\n            ]\n        },\n        # Missing required fields within documents array (missing contentType)\n        {\n            \"documentType\": \"passport\",\n            \"documents\": [\n                {\n                    \"type\": \"id_front\",\n                    \"fileUrl\": \"https://example.com/docs/id_front.jpg\"\n                }\n            ]\n        },\n        # Empty documents array\n        {\n            \"documentType\": \"driver_license\",\n            \"documents\": []\n        }\n    ]\n\n    for idx, payload in enumerate(incomplete_payloads):\n        resp = submit_kyc(token, payload)\n        assert resp.status_code == 400, f\"Incomplete KYC test case {idx} should return 400, got {resp.status_code}. Response: {resp.text}\"\n\n    # Test unauthorized submission (no token)\n    resp_unauth = requests.post(\n        f\"{BASE_URL}/api/v1/onboarding/kyc/submit\",\n        json=valid_kyc_payload,\n        timeout=TIMEOUT\n    )\n    assert resp_unauth.status_code == 401 or resp_unauth.status_code == 403, f\"Unauthorized KYC submission should be rejected, got {resp_unauth.status_code}\"\n\n\ntest_submit_kyc_documents_complete_incomplete()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 191, in <module>\n  File \"<string>\", line 88, in test_submit_kyc_documents_complete_incomplete\n  File \"<string>\", line 28, in register_and_start_onboarding\nAssertionError: Registration failed: {\"error\":\"Not implemented yet\",\"message\":\"User registration endpoint will be implemented\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.195Z",
    "modified": "2025-10-03T17:35:32.837Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "e366ec63-6cb7-46b8-a75a-dd78ba23482c",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC006-process kyc callback with valid and invalid payloads",
    "description": "Verify the KYC callback endpoint correctly processes valid callbacks from KYC providers and updates user status. Test invalid or malformed callbacks to confirm error handling.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_process_kyc_callback_with_valid_and_invalid_payloads():\n    # Step 1: Register a new user\n    register_url = f\"{BASE_URL}/api/v1/auth/register\"\n    email = f\"testuser+{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPass123!\"\n    register_payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    headers = {\"Content-Type\": \"application/json\"}\n    r = requests.post(register_url, json=register_payload, headers=headers, timeout=TIMEOUT)\n    assert r.status_code == 201, f\"User registration failed: {r.text}\"\n\n    # Step 2: Login the user to get token\n    login_url = f\"{BASE_URL}/api/v1/auth/login\"\n    login_payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    r = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n    assert r.status_code == 200, f\"User login failed: {r.text}\"\n    token = r.json().get(\"token\")\n    assert token, \"No token received upon login\"\n    auth_headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Step 3: Start onboarding with email (no phone)\n    onboarding_start_url = f\"{BASE_URL}/api/v1/onboarding/start\"\n    onboarding_payload = {\n        \"email\": email\n    }\n    r = requests.post(onboarding_start_url, json=onboarding_payload, headers={\"Content-Type\": \"application/json\"}, timeout=TIMEOUT)\n    # It might return 409 if user onboarding already exists, allow that case but get userId and token from response if 201\n    if r.status_code == 201:\n        onboarding_data = r.json()\n        user_id = onboarding_data.get(\"userId\")\n        onboarding_token = onboarding_data.get(\"sessionToken\")\n        # Use onboarding_token if provided for KYC submit\n        if onboarding_token:\n            auth_headers[\"Authorization\"] = f\"Bearer {onboarding_token}\"\n    elif r.status_code == 409:\n        # User already exists, get user id from onboarding status later\n        # We'll try to get user_id by fetching onboarding status\n        user_id = None\n    else:\n        assert False, f\"Unexpected onboarding start response: {r.status_code} {r.text}\"\n\n    # If user_id is None, get from onboarding status (some endpoints require auth)\n    if not user_id:\n        onboarding_status_url = f\"{BASE_URL}/api/v1/onboarding/status\"\n        # This endpoint requires Authorization bearer token\n        r = requests.get(onboarding_status_url, headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Failed to fetch onboarding status: {r.text}\"\n        user_id = r.json().get(\"userId\")\n    assert user_id, \"User ID not obtained after onboarding start\"\n\n    # Prepare to submit KYC documents to initiate a KYC flow to get a provider_ref for the callback\n    kyc_submit_url = f\"{BASE_URL}/api/v1/onboarding/kyc/submit\"\n    kyc_payload = {\n        \"documentType\": \"passport\",\n        \"documents\": [\n            {\n                \"type\": \"passport\",\n                \"fileUrl\": \"https://example.com/passport.jpg\",\n                \"contentType\": \"image/jpeg\"\n            }\n        ],\n        \"personalInfo\": {\n            \"firstName\": \"Test\",\n            \"lastName\": \"User\",\n            \"dateOfBirth\": \"1990-01-01T00:00:00Z\",\n            \"country\": \"US\"\n        },\n        \"metadata\": {\n            \"test\": \"callback\"\n        }\n    }\n\n    r = requests.post(kyc_submit_url, headers=auth_headers, json=kyc_payload, timeout=TIMEOUT)\n    assert r.status_code == 202, f\"KYC submit should be accepted (202), got {r.status_code}: {r.text}\"\n\n    # Since the provider_ref is required for callback, we must fetch it.\n    # It should be logged in audit_logs or part of onboarding status or wallet provisioning logs.\n    # The PRD doesn't specify direct API to get provider_ref, assume onboarding status or wallet info contains it.\n    # We'll poll onboarding status until KYC Pending or provider_ref appears.\n\n    kyc_provider_ref = None\n    max_retries = 10\n    for _ in range(max_retries):\n        r = requests.get(f\"{BASE_URL}/api/v1/onboarding/status\", headers=auth_headers, timeout=TIMEOUT)\n        if r.status_code != 200:\n            time.sleep(1)\n            continue\n        status_data = r.json()\n        # Attempt to extract provider_ref from walletStatus or other fields if available\n        # This is heuristic - no direct field in PRD - fallback to fake provider_ref for testing invalid case\n        # We'll assume status_data has \"requiredActions\" that might contain provider_ref or the userId can serve as provider_ref for testing\n        # For demonstration, use user_id as provider_ref for the valid callback test\n        kyc_provider_ref = user_id\n        break\n    assert kyc_provider_ref, \"Unable to obtain provider_ref for KYC callback\"\n\n    kyc_callback_url = f\"{BASE_URL}/api/v1/kyc/callback/{kyc_provider_ref}\"\n\n    # Happy Path: Valid callback payload - simulate Approved KYC status\n    valid_callback_payload = {\n        \"status\": \"approved\",\n        \"providerReference\": kyc_provider_ref,\n        \"details\": {\n            \"verifiedAt\": \"2025-09-29T12:00:00Z\",\n            \"documentsReviewed\": True\n        }\n    }\n\n    r = requests.post(kyc_callback_url, headers={\"Content-Type\": \"application/json\"}, json=valid_callback_payload, timeout=TIMEOUT)\n    assert r.status_code == 200, f\"Valid KYC callback failed: {r.status_code} {r.text}\"\n\n    # Verify onboarding status reflects approved KYC\n    r = requests.get(f\"{BASE_URL}/api/v1/onboarding/status\", headers=auth_headers, timeout=TIMEOUT)\n    assert r.status_code == 200, f\"Failed to get onboarding status after callback: {r.text}\"\n    kyc_status = r.json().get(\"kycStatus\")\n    assert kyc_status and kyc_status.lower() == \"approved\", f\"KYC status not approved after valid callback, got: {kyc_status}\"\n\n    # Sad Path: Invalid callback payload - missing required fields\n    invalid_callback_payloads = [\n        {},  # empty payload\n        {\"status\": \"unknown\"},  # unknown status values\n        {\"providerReference\": kyc_provider_ref},  # missing status\n        {\"status\": \"approved\", \"providerReference\": \"\"},  # empty providerReference\n        \"not-a-json\",  # invalid type payload\n    ]\n\n    for payload in invalid_callback_payloads:\n        if isinstance(payload, str):\n            r = requests.post(kyc_callback_url, headers={\"Content-Type\": \"application/json\"}, data=payload, timeout=TIMEOUT)\n        else:\n            r = requests.post(kyc_callback_url, headers={\"Content-Type\": \"application/json\"}, json=payload, timeout=TIMEOUT)\n        assert r.status_code == 400, f\"Invalid callback payload should return 400, got {r.status_code} for payload: {payload}\"\n\n    # Sad Path: Callback with invalid provider_ref in URL (not existing user/provider_ref)\n    fake_provider_ref = \"nonexistent-provider-ref-12345\"\n    fake_callback_url = f\"{BASE_URL}/api/v1/kyc/callback/{fake_provider_ref}\"\n    r = requests.post(fake_callback_url, headers={\"Content-Type\": \"application/json\"}, json=valid_callback_payload, timeout=TIMEOUT)\n    # The PRD states 400 for invalid callback, or 500 on server error.\n    # We expect a 400 Bad Request or 404 Not Found, but 400 is the documented error for invalid callback.\n    assert r.status_code == 400 or r.status_code == 404, f\"Invalid provider_ref callback should return 400 or 404, got {r.status_code}\"\n\n# Call the test function\ntest_process_kyc_callback_with_valid_and_invalid_payloads()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 158, in <module>\n  File \"<string>\", line 19, in test_process_kyc_callback_with_valid_and_invalid_payloads\nAssertionError: User registration failed: {\"error\":\"Not implemented yet\",\"message\":\"User registration endpoint will be implemented\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.200Z",
    "modified": "2025-10-03T17:35:34.303Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "0bcbf165-f028-40ae-bc68-8bccb4aadc71",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC007-get wallet addresses filtered by blockchain chain",
    "description": "Test the wallet addresses endpoint to retrieve wallet addresses for the authenticated user. Validate filtering by supported blockchain networks and proper error handling for invalid requests.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_get_wallet_addresses_filtered_by_blockchain_chain():\n    session = requests.Session()\n\n    # Common headers\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # 1. Register a new user with a unique email\n    import uuid\n    unique_email = f\"testuser+{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"StrongPassword!123\"\n\n    register_payload = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n\n    resp = session.post(f\"{BASE_URL}/api/v1/auth/register\", json=register_payload, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 201, f\"Unexpected register status code: {resp.status_code} {resp.text}\"\n\n    # 2. Login with the new user to get JWT token\n    login_payload = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n    resp = session.post(f\"{BASE_URL}/api/v1/auth/login\", json=login_payload, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 200, f\"Login failed: {resp.status_code} {resp.text}\"\n    login_data = resp.json()\n    assert \"token\" in login_data or \"accessToken\" in login_data or \"access_token\" in login_data, \"No token found on login\"\n    # Try different key variants for token\n    token = login_data.get(\"token\") or login_data.get(\"accessToken\") or login_data.get(\"access_token\")\n    assert token, \"Empty token returned\"\n\n    auth_headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # 3. Start onboarding process (required to begin KYC and wallet provisioning)\n    onboarding_start_payload = {\n        \"email\": unique_email\n    }\n    resp = session.post(f\"{BASE_URL}/api/v1/onboarding/start\",\n                        json=onboarding_start_payload,\n                        headers={**headers, **auth_headers},\n                        timeout=TIMEOUT)\n    # Onboarding start might fail if duplicate or something else; allow 201 or 409\n    assert resp.status_code in (201, 409), f\"Onboarding start unexpected status: {resp.status_code} {resp.text}\"\n\n    # 4. Submit minimal KYC documents to get approved status (simulate approved after waiting)\n    # Submit KYC documents with dummy data\n    kyc_payload = {\n        \"documentType\": \"IDENTITY\",\n        \"documents\": [\n            {\n                \"type\": \"id_front\",\n                \"fileUrl\": \"http://example.com/id_front.jpg\",\n                \"contentType\": \"image/jpeg\"\n            },\n            {\n                \"type\": \"id_back\",\n                \"fileUrl\": \"http://example.com/id_back.jpg\",\n                \"contentType\": \"image/jpeg\"\n            }\n        ]\n    }\n    resp = session.post(f\"{BASE_URL}/api/v1/onboarding/kyc/submit\",\n                        json=kyc_payload,\n                        headers={**headers, **auth_headers},\n                        timeout=TIMEOUT)\n    assert resp.status_code == 202, f\"KYC submit failed: {resp.status_code} {resp.text}\"\n\n    # 5. Poll onboarding/status endpoint until KYC is Approved and wallets created or timeout 120s\n    kyc_approved = False\n    max_wait = 120\n    interval = 5\n    user_id = None\n\n    for _ in range(0, max_wait, interval):\n        resp = session.get(f\"{BASE_URL}/api/v1/onboarding/status\", headers={**headers, **auth_headers}, timeout=TIMEOUT)\n        if resp.status_code == 200:\n            data = resp.json()\n            kyc_status = data.get(\"kycStatus\", \"\").lower()\n            user_id = data.get(\"userId\")\n            wallet_status = data.get(\"walletStatus\")\n            if kyc_status == \"approved\":\n                # Check if walletStatus exists and some wallets present (ready or pending)\n                if wallet_status and isinstance(wallet_status, dict):\n                    # Assuming walletStatus contains data on wallets readiness\n                    kyc_approved = True\n                    break\n        time.sleep(interval)\n\n    assert kyc_approved, \"KYC approval or wallet provisioning did not complete in time\"\n\n    # 6. Define supported chains to test filtering\n    supported_chains = [\"ETH\", \"SOL\", \"APTOS\", \"ETH-SEPOLIA\", \"SOL-DEVNET\", \"APTOS-TESTNET\"]\n\n    # 7. Test fetching wallet addresses filtered by each supported chain - happy path\n    for chain in supported_chains:\n        params = {\"chain\": chain}\n        resp = session.get(f\"{BASE_URL}/api/v1/wallet/addresses\",\n                           headers={**headers, **auth_headers},\n                           params=params,\n                           timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to get wallet address for chain {chain}: {resp.status_code} {resp.text}\"\n        resp_json = resp.json()\n        assert isinstance(resp_json, dict), f\"Response is not a dict for chain {chain}\"\n        wallets = resp_json.get(\"wallets\")\n        assert isinstance(wallets, list), f\"wallets not a list for chain {chain}\"\n        for wallet in wallets:\n            assert \"chain\" in wallet, \"Wallet missing 'chain' field\"\n            assert wallet[\"chain\"].upper() == chain.upper(), f\"Returned wallet chain mismatch: expected {chain}, got {wallet['chain']}\"\n            assert \"address\" in wallet and wallet[\"address\"], \"Wallet missing or empty 'address'\"\n            assert \"status\" in wallet and wallet[\"status\"], \"Wallet missing or empty 'status'\"\n\n    # 8. Test fetching wallet addresses without chain filter returns all wallets\n    resp = session.get(f\"{BASE_URL}/api/v1/wallet/addresses\",\n                       headers={**headers, **auth_headers},\n                       timeout=TIMEOUT)\n    assert resp.status_code == 200, f\"Failed to get all wallet addresses: {resp.status_code} {resp.text}\"\n    resp_json = resp.json()\n    wallets = resp_json.get(\"wallets\")\n    assert isinstance(wallets, list) and len(wallets) > 0, \"No wallets returned when no chain filter applied\"\n\n    # 9. Test invalid chain parameter returns 400 error\n    invalid_chains = [\"INVALIDCHAIN\", \"123\", \"\", \"ethereummainnet\"]\n    for bad_chain in invalid_chains:\n        params = {\"chain\": bad_chain}\n        resp = session.get(f\"{BASE_URL}/api/v1/wallet/addresses\",\n                           headers={**headers, **auth_headers},\n                           params=params,\n                           timeout=TIMEOUT)\n        assert resp.status_code == 400, f\"Invalid chain '{bad_chain}' did not return 400, got {resp.status_code}\"\n\n    # 10. Test unauthorized request returns 401\n    resp = session.get(f\"{BASE_URL}/api/v1/wallet/addresses\",\n                       headers={**headers},  # no auth header\n                       timeout=TIMEOUT)\n    assert resp.status_code == 401 or resp.status_code == 403, f\"Unauthorized request did not return 401/403, got {resp.status_code}\"\n\n\ntest_get_wallet_addresses_filtered_by_blockchain_chain()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 147, in <module>\n  File \"<string>\", line 26, in test_get_wallet_addresses_filtered_by_blockchain_chain\nAssertionError: Unexpected register status code: 501 {\"error\":\"Not implemented yet\",\"message\":\"User registration endpoint will be implemented\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.205Z",
    "modified": "2025-10-03T17:35:38.440Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "3ed08f4c-578c-46b5-a567-093ed531a589",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC008-get wallet status with valid and invalid user context",
    "description": "Verify the wallet status endpoint returns comprehensive wallet provisioning and status information for authenticated users. Test error responses for invalid or unauthorized access.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_wallet_status_with_valid_and_invalid_user_context():\n    # Helper to register and onboard a user, returning tokens and userId\n    def register_and_onboard_user(email):\n        # Register User\n        register_payload = {\n            \"email\": email,\n            \"password\": \"StrongPassw0rd!\"\n        }\n        r = requests.post(f\"{BASE_URL}/api/v1/auth/register\", json=register_payload, timeout=TIMEOUT)\n        if r.status_code == 409:\n            # User exists - continue with login instead\n            pass\n        else:\n            assert r.status_code == 201, f\"Unexpected register status: {r.status_code}\"\n\n        # Login User\n        login_payload = {\n            \"email\": email,\n            \"password\": \"StrongPassw0rd!\"\n        }\n        r = requests.post(f\"{BASE_URL}/api/v1/auth/login\", json=login_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Login failed with status {r.status_code}\"\n        token = r.json().get(\"token\") or r.json().get(\"accessToken\") or r.json().get(\"sessionToken\")\n        assert token, \"No token received in login response\"\n\n        # Start onboarding (KYC onboarding start)\n        onboard_payload = {\n            \"email\": email\n        }\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = requests.post(f\"{BASE_URL}/api/v1/onboarding/start\", json=onboard_payload, timeout=TIMEOUT)\n        # 201 if onboarding started successfully, 409 if onboarding exists\n        assert r.status_code in (201, 409), f\"Onboarding start failed: {r.status_code}\"\n        if r.status_code == 201:\n            user_id = r.json().get(\"userId\")\n        else:\n            # Duplicate onboard => get userId from onboarding status API\n            r2 = requests.get(f\"{BASE_URL}/api/v1/onboarding/status\", headers=headers, timeout=TIMEOUT)\n            assert r2.status_code == 200, f\"Failed to get onboarding status: {r2.status_code}\"\n            user_id = r2.json().get(\"userId\")\n        assert user_id\n\n        return user_id, token\n\n    # Helper to submit KYC documents\n    def submit_kyc(token):\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        kyc_payload = {\n            \"documentType\": \"passport\",\n            \"documents\": [\n                {\n                    \"type\": \"passport\",\n                    \"fileUrl\": \"https://example.com/kyc/passport.jpg\",\n                    \"contentType\": \"image/jpeg\"\n                }\n            ],\n            \"personalInfo\": {\n                \"firstName\": \"John\",\n                \"lastName\": \"Doe\",\n                \"dateOfBirth\": \"1990-01-01T00:00:00Z\",\n                \"country\": \"US\"\n            }\n        }\n        r = requests.post(f\"{BASE_URL}/api/v1/onboarding/kyc/submit\", json=kyc_payload, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 202, f\"KYC submission failed with status {r.status_code}\"\n\n    # Helper to poll onboarding status until KYC approved or timeout (max wait ~2 minutes)\n    def wait_for_kyc_approved(token, user_id, max_wait=120, interval=5):\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        elapsed = 0\n        while elapsed < max_wait:\n            r = requests.get(f\"{BASE_URL}/api/v1/onboarding/status\", headers=headers, timeout=TIMEOUT)\n            assert r.status_code == 200, f\"Onboarding status failed: {r.status_code}\"\n            data = r.json()\n            assert data.get(\"userId\") == user_id\n\n            kyc_status = data.get(\"kycStatus\")\n            wallet_status = data.get(\"walletStatus\")\n            can_proceed = data.get(\"canProceed\")\n            required_actions = data.get(\"requiredActions\")\n\n            if kyc_status == \"Approved\":\n                # Wallet provisioning should start or be done\n                return data\n            elif kyc_status == \"Failed\":\n                raise Exception(f\"KYC failed as per onboarding status. Required actions: {required_actions}\")\n            # Pending or other: wait and retry\n            time.sleep(interval)\n            elapsed += interval\n\n        raise TimeoutError(\"Timed out waiting for KYC approval\")\n\n    # Helper to get wallet status with token\n    def get_wallet_status(token):\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = requests.get(f\"{BASE_URL}/api/v1/wallet/status\", headers=headers, timeout=TIMEOUT)\n        return r\n\n    # Generate a unique email for testing\n    test_email = f\"testuser+{uuid.uuid4()}@example.com\"\n\n    user_id = None\n    token = None\n\n    try:\n        # Register, login, start onboarding\n        user_id, token = register_and_onboard_user(test_email)\n\n        # Submit KYC documents\n        submit_kyc(token)\n\n        # Wait for KYC approval and wallet provisioning status\n        onboarding_data = wait_for_kyc_approved(token, user_id)\n\n        # Validate wallet provisioning info in onboarding status\n        wallet_status = onboarding_data.get(\"walletStatus\")\n        assert wallet_status is not None, \"Wallet status should be present after KYC approval\"\n\n        # Get wallet status endpoint response (happy path)\n        r = get_wallet_status(token)\n        assert r.status_code == 200, f\"Wallet status endpoint failed: {r.status_code}\"\n        data = r.json()\n        assert data.get(\"userId\") == user_id\n        # Validate keys presence and types\n        for key in [\"totalWallets\", \"readyWallets\", \"pendingWallets\", \"failedWallets\", \"walletsByChain\"]:\n            assert key in data, f\"{key} missing in wallet status response\"\n        assert isinstance(data.get(\"totalWallets\"), int)\n        assert isinstance(data.get(\"readyWallets\"), int)\n        assert isinstance(data.get(\"pendingWallets\"), int)\n        assert isinstance(data.get(\"failedWallets\"), int)\n        wallets_by_chain = data.get(\"walletsByChain\")\n        assert isinstance(wallets_by_chain, dict)\n\n        # --------------------------\n        # Test unauthorized access (missing / invalid token)\n        r = requests.get(f\"{BASE_URL}/api/v1/wallet/status\", timeout=TIMEOUT)\n        # Expect 401 Unauthorized or 403 Forbidden\n        assert r.status_code in (401, 403), \"Expected unauthorized error for missing token\"\n\n        r = requests.get(f\"{BASE_URL}/api/v1/wallet/status\", headers={\"Authorization\": \"Bearer invalidtoken\"}, timeout=TIMEOUT)\n        assert r.status_code in (401, 403), \"Expected unauthorized error for invalid token\"\n\n        # --------------------------\n        # Test access with random non-existent user JWT or invalid user context\n        # If the system supports user_id query param for admin, test invalid user_id param (should 400 or 404)\n        # But wallet/status does not specify user_id query param so test only through token\n        # We can simulate a token with no valid user, but here just test with token for non-registered user.\n\n        # Create a dummy token format (may not work as real JWT but testing API error)\n        dummy_token = \"Bearer \" + str(uuid.uuid4())\n        r = requests.get(f\"{BASE_URL}/api/v1/wallet/status\", headers={\"Authorization\": dummy_token}, timeout=TIMEOUT)\n        assert r.status_code in (401, 403, 404), \"Expected unauthorized or not found for invalid user token\"\n\n    finally:\n        # Cleanup would be here - no direct user delete API specified in PRD,\n        # assuming test env auto-cleans or alternate approach.\n        pass\n\n\ntest_wallet_status_with_valid_and_invalid_user_context()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 167, in <module>\n  File \"<string>\", line 114, in test_wallet_status_with_valid_and_invalid_user_context\n  File \"<string>\", line 21, in register_and_onboard_user\nAssertionError: Unexpected register status: 501\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.211Z",
    "modified": "2025-10-03T17:35:38.441Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "3cf72821-35cc-49a7-869a-a71844fc9ff4",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC009-admin create wallets for user with valid and invalid inputs",
    "description": "Test the admin wallet creation endpoint to manually trigger wallet creation for a user with valid user ID and chain list. Validate permission checks and error handling for invalid requests.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Admin user credentials for authentication (should have admin privileges)\nADMIN_EMAIL = \"admin@example.com\"\nADMIN_PASSWORD = \"AdminPass123!\"\n\ndef test_admin_create_wallets_for_user_valid_invalid_inputs():\n    headers = {\"Content-Type\": \"application/json\"}\n    session = requests.Session()\n\n    def register_user(email):\n        payload = {\n            \"email\": email,\n            \"password\": \"TestPassword123!\"\n        }\n        resp = session.post(f\"{BASE_URL}/api/v1/auth/register\", json=payload, headers=headers, timeout=TIMEOUT)\n        # Accept both success and if user already exists (409)\n        assert resp.status_code in (201, 409), f\"Unexpected status code on registration: {resp.status_code}\"\n        return email\n\n    def login_user(email, password):\n        payload = {\"email\": email, \"password\": password}\n        resp = session.post(f\"{BASE_URL}/api/v1/auth/login\", json=payload, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Login failed for {email} with status {resp.status_code}\"\n        return resp.json().get(\"token\") or resp.json().get(\"accessToken\") or resp.json().get(\"access_token\")\n\n    def start_onboarding(token):\n        hdr = headers.copy()\n        hdr[\"Authorization\"] = f\"Bearer {token}\"\n        payload = {\n            \"email\": test_email\n        }\n        resp = session.post(f\"{BASE_URL}/api/v1/onboarding/start\", json=payload, headers=hdr, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Onboarding start failed with status {resp.status_code}\"\n        data = resp.json()\n        assert \"userId\" in data, \"userId missing in onboarding start response\"\n        return data[\"userId\"], data.get(\"sessionToken\")\n\n    def submit_kyc(token, user_id, session_token=None):\n        hdr = headers.copy()\n        hdr[\"Authorization\"] = f\"Bearer {token}\"\n        # Minimal valid KYC submission with dummy doc URL\n        payload = {\n            \"documentType\": \"passport\",\n            \"documents\": [\n                {\n                    \"type\": \"passport\",\n                    \"fileUrl\": \"https://example.com/dummy-passport.jpg\",\n                    \"contentType\": \"image/jpeg\"\n                }\n            ],\n            \"personalInfo\": {\n                \"firstName\": \"Test\",\n                \"lastName\": \"User\",\n                \"country\": \"US\"\n            }\n        }\n        resp = session.post(f\"{BASE_URL}/api/v1/onboarding/kyc/submit\", json=payload, headers=hdr, timeout=TIMEOUT)\n        assert resp.status_code == 202, f\"KYC submission failed with status {resp.status_code}\"\n\n    def wait_for_kyc_approval(token, user_id, max_wait_sec=120, poll_interval=5):\n        hdr = headers.copy()\n        hdr[\"Authorization\"] = f\"Bearer {token}\"\n        start_time = time.time()\n        while time.time() - start_time < max_wait_sec:\n            resp = session.get(f\"{BASE_URL}/api/v1/onboarding/status\", params={\"user_id\": user_id}, headers=hdr, timeout=TIMEOUT)\n            if resp.status_code == 200:\n                data = resp.json()\n                kyc_status = data.get(\"kycStatus\")\n                if kyc_status == \"Approved\":\n                    return True\n                elif kyc_status == \"Failed\":\n                    raise Exception(\"KYC verification failed\")\n            time.sleep(poll_interval)\n        raise TimeoutError(\"Timed out waiting for KYC approval\")\n\n    def admin_login():\n        payload = {\"email\": ADMIN_EMAIL, \"password\": ADMIN_PASSWORD}\n        resp = session.post(f\"{BASE_URL}/api/v1/auth/login\", json=payload, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, \"Admin login failed\"\n        token = resp.json().get(\"token\") or resp.json().get(\"accessToken\") or resp.json().get(\"access_token\")\n        assert token is not None, \"No token received for admin\"\n        return token\n\n    def admin_create_wallets(token, user_id, chains):\n        hdr = headers.copy()\n        hdr[\"Authorization\"] = f\"Bearer {token}\"\n        payload = {\n            \"user_id\": user_id,\n            \"chains\": chains\n        }\n        resp = session.post(f\"{BASE_URL}/api/v1/admin/wallet/create\", json=payload, headers=hdr, timeout=TIMEOUT)\n        return resp\n\n    def admin_create_wallets_no_auth(user_id, chains):\n        payload = {\n            \"user_id\": user_id,\n            \"chains\": chains\n        }\n        resp = session.post(f\"{BASE_URL}/api/v1/admin/wallet/create\", json=payload, headers=headers, timeout=TIMEOUT)\n        return resp\n\n    # Create test user with unique email\n    test_email = f\"testuser_{uuid.uuid4()}@example.com\"\n    register_user(test_email)\n    user_token = login_user(test_email, \"TestPassword123!\")\n    user_id, session_token = start_onboarding(user_token)\n    submit_kyc(user_token, user_id, session_token)\n    wait_for_kyc_approval(user_token, user_id)\n\n    # Admin login for privileged actions\n    admin_token = admin_login()\n\n    # Happy path: Admin creates wallets with valid user_id and chains\n    valid_chains = [\"ETH\", \"SOL\", \"APTOS\"]\n    resp = admin_create_wallets(admin_token, user_id, valid_chains)\n    assert resp.status_code == 202, f\"Expected 202 for valid wallet creation, got {resp.status_code}\"\n\n    # Invalid user ID format\n    invalid_user_id = \"not-a-uuid\"\n    resp = admin_create_wallets(admin_token, invalid_user_id, valid_chains)\n    assert resp.status_code == 400, f\"Expected 400 for invalid user_id, got {resp.status_code}\"\n\n    # Invalid chain in list\n    invalid_chains = [\"INVALIDCHAIN\"]\n    resp = admin_create_wallets(admin_token, user_id, invalid_chains)\n    assert resp.status_code == 400, f\"Expected 400 for invalid chains, got {resp.status_code}\"\n\n    # Empty chains list\n    resp = admin_create_wallets(admin_token, user_id, [])\n    assert resp.status_code == 400, f\"Expected 400 for empty chains list, got {resp.status_code}\"\n\n    # Missing user_id\n    hdr = headers.copy()\n    hdr[\"Authorization\"] = f\"Bearer {admin_token}\"\n    payload_missing_user = {\"chains\": valid_chains}\n    resp = session.post(f\"{BASE_URL}/api/v1/admin/wallet/create\", json=payload_missing_user, headers=hdr, timeout=TIMEOUT)\n    assert resp.status_code == 400, f\"Expected 400 when missing user_id, got {resp.status_code}\"\n\n    # Missing chains\n    payload_missing_chains = {\"user_id\": user_id}\n    resp = session.post(f\"{BASE_URL}/api/v1/admin/wallet/create\", json=payload_missing_chains, headers=hdr, timeout=TIMEOUT)\n    assert resp.status_code == 400, f\"Expected 400 when missing chains, got {resp.status_code}\"\n\n    # Insufficient permissions: call without auth\n    resp = admin_create_wallets_no_auth(user_id, valid_chains)\n    assert resp.status_code in (401,403), f\"Expected 401 or 403 for unauthenticated request, got {resp.status_code}\"\n\n    # Insufficient permissions: call with non-admin user token\n    resp = admin_create_wallets(user_token, user_id, valid_chains)\n    assert resp.status_code == 403, f\"Expected 403 for non-admin user, got {resp.status_code}\"\n\ntest_admin_create_wallets_for_user_valid_invalid_inputs()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 158, in <module>\n  File \"<string>\", line 110, in test_admin_create_wallets_for_user_valid_invalid_inputs\n  File \"<string>\", line 23, in register_user\nAssertionError: Unexpected status code on registration: 501\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.216Z",
    "modified": "2025-10-03T17:35:40.678Z"
  },
  {
    "projectId": "3932e877-9747-4939-85da-64e9610e18ae",
    "testId": "a908e4d8-de81-4558-8bcc-86afbfaf286c",
    "userId": "448894d8-5071-7043-7616-12ca8e762178",
    "title": "TC010-generate deposit address for supported blockchain chains",
    "description": "Test the deposit address generation endpoint by requesting deposit addresses for each supported blockchain chain. Verify correct address generation and error handling for invalid or unauthorized requests.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_generate_deposit_address_for_supported_blockchains():\n    session = requests.Session()\n    email = f\"testuser_{int(time.time())}@example.com\"\n    password = \"StrongPassw0rd!\"\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # 1. Register user\n    register_payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    r = session.post(f\"{BASE_URL}/api/v1/auth/register\", json=register_payload, headers=headers, timeout=TIMEOUT)\n    assert r.status_code == 201, f\"Registration failed: {r.text}\"\n\n    # 2. Login user to get auth token\n    login_payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    r = session.post(f\"{BASE_URL}/api/v1/auth/login\", json=login_payload, headers=headers, timeout=TIMEOUT)\n    assert r.status_code == 200, f\"Login failed: {r.text}\"\n    token = r.json().get(\"token\") or r.json().get(\"accessToken\")  # fallback key if any\n    assert token, \"No token received on login\"\n    auth_headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n    # 3. Start onboarding\n    onboarding_payload = {\n        \"email\": email\n    }\n    r = session.post(f\"{BASE_URL}/api/v1/onboarding/start\", json=onboarding_payload, headers=auth_headers, timeout=TIMEOUT)\n    assert r.status_code == 201, f\"Onboarding start failed: {r.text}\"\n    user_id = r.json().get(\"userId\")\n    assert user_id, \"No userId returned from onboarding start\"\n\n    # 4. Normally user has to verify email/OTP and submit KYC.\n    # For testing, simulate KYC submission with required fields\n    # Submit fake KYC documents (minimal valid)\n    kyc_payload = {\n        \"documentType\": \"passport\",\n        \"documents\": [\n            {\n                \"type\": \"passport_photo\",\n                \"fileUrl\": \"https://example.com/fake-passport.jpg\",\n                \"contentType\": \"image/jpeg\"\n            }\n        ],\n        \"personalInfo\": {\n            \"firstName\": \"Test\",\n            \"lastName\": \"User\",\n            \"country\": \"US\"\n        }\n    }\n    r = session.post(f\"{BASE_URL}/api/v1/onboarding/kyc/submit\", json=kyc_payload, headers=auth_headers, timeout=TIMEOUT)\n    assert r.status_code == 202, f\"KYC submit failed: {r.text}\"\n\n    # 5. Wait and poll onboarding status until KYC Approved or timeout (~90 seconds)\n    kyc_approved = False\n    for _ in range(18):\n        r = session.get(f\"{BASE_URL}/api/v1/onboarding/status?user_id={user_id}\", headers=auth_headers, timeout=TIMEOUT)\n        if r.status_code == 200:\n            status = r.json()\n            kyc_status = status.get(\"kycStatus\", \"\").lower()\n            if kyc_status == \"approved\":\n                kyc_approved = True\n                break\n            elif kyc_status == \"failed\":\n                assert False, f\"KYC failed during test: {r.text}\"\n        else:\n            assert False, f\"Failed to get onboarding status: {r.text}\"\n        time.sleep(5)\n    assert kyc_approved, \"KYC not approved after waiting\"\n\n    # 6. Confirm wallet provisioning completed (ready wallets matches expected chains)\n    wallet_ready = False\n    for _ in range(12):\n        r = session.get(f\"{BASE_URL}/api/v1/wallet/status\", headers=auth_headers, timeout=TIMEOUT)\n        if r.status_code == 200:\n            data = r.json()\n            total_wallets = data.get(\"totalWallets\", 0)\n            ready_wallets = data.get(\"readyWallets\", 0)\n            # Expect at least ETH (EVM), SOL, APTOS wallets as per requirements\n            if total_wallets >= 3 and ready_wallets >= 3:\n                wallet_ready = True\n                break\n        else:\n            assert False, f\"Failed to get wallet status: {r.text}\"\n        time.sleep(5)\n    assert wallet_ready, \"Wallet provisioning not complete or insufficient wallets ready\"\n\n    supported_chains = [\"Aptos\", \"Solana\", \"polygon\", \"starknet\"]\n    valid_chains_lower = {c.lower() for c in supported_chains}\n\n    try:\n        # 7. Test deposit address generation for each supported chain - expect 200 and valid address\n        for chain in supported_chains:\n            payload = {\"chain\": chain}\n            r = session.post(f\"{BASE_URL}/api/v1/funding/deposit-address\", json=payload, headers=auth_headers, timeout=TIMEOUT)\n            assert r.status_code == 200, f\"Deposit address generation failed for chain {chain}: {r.text}\"\n            rsp_json = r.json()\n            # Expect some address format in response; check at least address presence and chain key\n            address = rsp_json.get(\"address\") or rsp_json.get(\"walletAddress\") or rsp_json.get(\"depositAddress\")\n            assert address and isinstance(address, str) and len(address) > 0, f\"No valid address returned for chain {chain}\"\n        # 8. Test error handling for invalid chain (bad input)\n        invalid_chain_payload = {\"chain\": \"invalidchain\"}\n        r = session.post(f\"{BASE_URL}/api/v1/funding/deposit-address\", json=invalid_chain_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 400, f\"Invalid chain did not return 400 error, got {r.status_code}\"\n\n        # 9. Test unauthorized request (no token)\n        r = session.post(f\"{BASE_URL}/api/v1/funding/deposit-address\", json={\"chain\": \"Aptos\"}, timeout=TIMEOUT)\n        assert r.status_code == 401, f\"Unauthorized request did not return 401, got {r.status_code}\"\n\n    finally:\n        # (No explicit resource to delete; no cleanup endpoint specified)\n        pass\n\ntest_generate_deposit_address_for_supported_blockchains()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 122, in <module>\n  File \"<string>\", line 19, in test_generate_deposit_address_for_supported_blockchains\nAssertionError: Registration failed: {\"error\":\"Not implemented yet\",\"message\":\"User registration endpoint will be implemented\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-03T17:34:33.221Z",
    "modified": "2025-10-03T17:35:40.922Z"
  }
]
