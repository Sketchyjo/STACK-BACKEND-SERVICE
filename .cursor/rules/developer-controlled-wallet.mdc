---
alwaysApply: false
---

# Generating the Entity Secret

```go
package main

import (
"crypto/rand"
"fmt"
"io"
)

func generateRandomHex() []byte { 
mainBuff := make([]byte, 32) 
_, err := io.ReadFull(rand.Reader, mainBuff) 
if err != nil { 
  panic("reading from crypto/rand failed: " + err.Error())
}
return mainBuff
}

// The following sample codes generate a distinct hex encoded entity secret with each execution
// The generation of entity secret only need to be executed once unless you need to rotate entity secret.
func main() { 
entitySecret := generateRandomHex()
fmt.Printf("Hex encoded entity secret: %x
", entitySecret)
}
```

#### Example response

```json
{
  "response": {
    "entitySecret": "cb82a7c71abcc0b262a061e3897deb4d4eaf1bdcf7e79b1d469c0bb89301c578"
  }
}
```

With your Entity Secret now created, we're ready to advance to a critical juncture. You're about to convert the Entity Secret into Ciphertext and register it with the system. This process sets the stage for you to create your first wallet—a milestone to look forward to.

---

## Retrieving Your Entity's Public Key (Optional if registering with SDK)

Begin by acquiring your entity's public key. This key is retrievable via our APIs and is instrumental in the upcoming steps. To obtain it, use your API key for authentication. The entity's public key plays a crucial role as it encrypts your Entity Secret. Once encrypted, the Entity Secret remains secure, ensuring the information is shared exclusively between you and the platform, keeping it out of reach from outsiders.

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.circle.com/v1/w3s/config/entity/publicKey"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", "Bearer <YOUR_API_KEY>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(string(body))

}
```

#### Example response

```text
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAqM5uxsv3d7ZV0pfxMZsG
67EOI8vg9ovQmcUz/Fte3T2pXna6JMaUdXyrOsWo4prsk/QZ3/MZsi4kYjIXOcDS
MTitn2yBQaOEf9H55FhWYQf2geTldJl70aA7jg3StvRZods8dAAl+iaJMWL7URRy
2luA9SBf8kINyfJDIONfB3dY2LYUcGTKNHaxAz9+766SzgkbfDKzAcH88Bb6McLj
uwg/pm7ROSjtqpFda2x76Yff6RlpC9KfIULD+/f0nw27nO7aeHDEk/AHMh1HXt7d
Z2ThcTXCD9kjkFL9pOPSTLLRKZlv8D47OppyEGziYdjRa4Ea3PEIQDl+2oG8gGi4
YZFKBMutRu/KSjcXzyw35jzh90685IsagKlygVy4f6rxeVEd4lU5OKfRbROP7C41
AWf8meZE/4QsT2aAzpn/ckk2o5hUNIsgFJ5RRVu3YxhrpUzRcx86kbYkplWg8R/S
HuSRI9WyDYpVz2tQ7EKV5Pei97vuIgFfto8SO1TCozsrFLq6Vr7FmepuS164N11j
8zgCLdDFr/eDIFVq8iWRMDxjUxG1qn7y2QI9EenJIEbhLE2Yda2RcNrG5BQmQb6v
9emeY8+ggLEvH4ZYvM9gc0ET1ef+4+pQ6YGLtK+CuJWPWEBlidbTGf31aKwWBce2
bUQULnOQlASQ6pH30UJw3pMCAwEAAQ==
-----END PUBLIC KEY-----
```

---

## Encrypting the Entity Secret and Encoding in Base64 (Optional if registering with SDK)

After obtaining the public key, the next step involves using RSA encryption to secure your Entity Secret. Follow these steps:

1. **Encrypt the Entity Secret**  
   Employ RSA encryption with the public key to encrypt your Entity Secret. This cryptographic process ensures that the secret is encoded in such a way that only someone with the private key can decrypt it.

2. **Encode as Base64**  
   After encryption, convert the encrypted data into Base64 format. Encoding in Base64 ensures the encrypted data can be safely conveyed and interpreted in various contexts, including those that may not handle binary data well.

3. **Verify the Ciphertext Length**  
   Ensure that the generated Ciphertext is 684 characters in length. This specific length confirms the encryption process has been executed properly and that the data will be maintained correctly upon receipt.

The code provided will assist in automating this encryption process, generating a unique Entity Secret Ciphertext every time it is executed. The resulting Ciphertext is what you'll use to interact securely with the platform's API when performing operations that require it.

### Generate Entity Secret Ciphertext

```go
package main

import (
"crypto/rand"
"crypto/rsa"
"crypto/sha256"
"crypto/x509"
"encoding/base64"
"encoding/hex"
"encoding/pem"
"errors"
"fmt"
)
// Paste your entity public key here. var publicKeyString = "PASTE_YOUR_PUBLIC_KEY_HERE"
// If you already have a hex encoded entity secret, you can paste it here. the length of the hex string should be 64. var hexEncodedEntitySecret = "PASTE_YOUR_HEX_ENCODED_ENTITY_SECRET_KEY_HERE"
// The following sample codes generate a distinct entity secret ciphertext with each execution 
func main() { 
entitySecret, err := hex.DecodeString(hexEncodedEntitySecret) 
if err != nil { 
  panic(err) 
} 

if len(entitySecret) != 32 { 
  panic("invalid entity secret") 
} 

pubKey, err := ParseRsaPublicKeyFromPem([]byte(publicKeyString)) 
if err != nil {
  panic(err)
} 

cipher, err := EncryptOAEP(pubKey, entitySecret) 
if err != nil { 
  panic(err)
}
fmt.Printf("Hex encoded entity secret: %x", entitySecret)
fmt.Printf("Entity secret ciphertext: %s", base64.StdEncoding.EncodeToString(cipher))
}

// ParseRsaPublicKeyFromPem parse rsa public key from pem. 
func ParseRsaPublicKeyFromPem(pubPEM []byte) (*rsa.PublicKey, error) { 
block, _ := pem.Decode(pubPEM) 
if block == nil { 
  return nil, errors.New("failed to parse PEM block containing the key") 
}
pub, err := x509.ParsePKIXPublicKey(block.Bytes)
if err != nil {
	return nil, err
}
switch pub := pub.(type) {
case *rsa.PublicKey:
	return pub, nil
default:
}
return nil, errors.New("key type is not rsa")
}

// EncryptOAEP rsa encrypt oaep. 
func EncryptOAEP(pubKey *rsa.PublicKey, message []byte) (ciphertext []byte, err error) 
{ 
random := rand.Reader 
ciphertext, err = rsa.EncryptOAEP(sha256.New(), random, pubKey, message, nil) 
if err != nil {
  return nil, err
}
return
}
```

---

# Register the Entity Secret

You can register your Entity Secret in two ways: using the SDK, or using the Circle Console. The registration links your Entity Secret with your developer account, ensuring that you can confidently manage wallet creation and transactions with the assurance of robust security measures in place.

> **Notae:** As you proceed with the registration of your Entity Secret, pay close attention to the recovery file that will be generated. This file is a critical safety measure for your operations. In the event that your Entity Secret is ever lost, the recovery file will act as your fallback, enabling you to regain access to your developer-controlled wallets. Ensure that you store this file securely and in a location that you can access readily if needed.
>
> *Note: If you use the SDK to register the Entity Secret, the function downloads a recovery file named recoveryfile<timestamp>.dat. Additionally, the function returns the content of the recovery file as a JSON response.*

---

## Registering your Entity Secret using the SDK

You can use the sample code below as a guide to register your Entity Secret Ciphertext using the SDK.

```phython
from circle.web3 import utils

result = utils.register_entity_secret_ciphertext(api_key='your_api_key', entity_secret='new_entity_secret')
print(result)
```

---

# Crafting Your WalletSet

Now that we've got the concept of idempotency covered, let's look at creating your WalletSet.

| Term                | Definition                                                                                                                                          |
|---------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| idempotencyKey      | Think of this as a safety net. By using a unique UUID for every transaction request, you ensure no transaction is mistakenly processed more than once. It's a measure against unintended duplicates. |
| entitySecretCiphertext | Remember the encryption we discussed earlier? You'll need to provide this encrypted string for security and authorization.                         |
| name                | The name for your new WalletSet.                                                                                                                    |

Let's create our first wallet set!

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.circle.com/v1/w3s/developer/walletSets"

	payload := strings.NewReader("{\"idempotencyKey\":\"<UNIQUE_UUID>\",\"entitySecretCipherText\":\"<GENERATED_ENTITY_SECRET_CIPHERTEXT>\",\"name\":\"<WALLET_SET_NAME>\"}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", "Bearer <YOUR_API_KEY>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(string(body))

}
```

#### Example response

```json
 "response": {
    "data": {
      "walletSet": {
        "id": "c69d9754-d9bc-5fd3-b098-7ab28f3e3832",
        "custodyType": "DEVELOPER",
        "name": "Stack",
        "updateDate": "2025-10-20T02:03:35Z",
        "createDate": "2025-10-20T02:03:35Z"
      }
    }
  }
```

---

## Understanding the Developer-Controlled Wallet

In web3, a wallet isn't just a storage mechanism for digital tokens or NFTs, but the very essence of user interactions on the blockchain. Essentially, it's a blend of a unique address and accompanying metadata stored on the blockchain.

For developer-controlled wallets:

- **Address:**  
  A unique identifier on a blockchain. Notably, while an address remains distinct, multiple wallets can have the same address across different EVM blockchains.

- **Custody Type:**  
  This signifies who controls the private key invocation — either the user or the developer. For our purpose, we're focusing on developer-controlled wallets, which are inherently more manageable and tailored for specific app requirements.

---

# Crafting your wallet

To create a wallet you use the following parameters:

| Term                | Definition                                                                                                       |
|---------------------|------------------------------------------------------------------------------------------------------------------|
| idempotencyKey      | Ensures that a request is executed only once, even if it's received multiple times.                             |
| entitySecretCiphertext | The encrypted form of your Entity Secret, ensuring robust security for your API requests.                    |
| walletSetId         | The ID of the wallet set that you created in the preceding step.                                                |
| blockchains         | Specifies the blockchains on which the wallet should be manifested.                                             |
| count               | The number of wallets you aim to create. Note: The parameter should not exceed 20.                              |
| accountType         | The type of account you want to create. For this guide, you will use SCA, which represents developer-controlled wallets. |

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.circle.com/v1/w3s/developer/wallets"

	payload := strings.NewReader("{\"idempotencyKey\":\"<UNIQUE_UUID>\",\"entitySecretCipherText\":\"<GENERATED_ENTITY_SECRET_CIPHERTEXT>\",\"blockchains\":[\"<BLOCKCHAIN_1>\",\"<BLOCKCHAIN_2>\",\"<BLOCKCHAIN_3>\"],\"count\":2,\"accountType\":\"SCA\",\"walletSetId\":\"<ID_OF_PREVIOUSLY_GENERATED_WALLET_SET>\"}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", "Bearer <YOUR_API_KEY>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(string(body))

}
```

> Note: Smart Contract Account wallets are not availabe for Solana Devnet. A similar workflow can be accomplished on Solana Devnet with EOA wallets and the Circle Gas Station.

And there you have it! By the end of this step, you'll have fully functional developer-controlled wallets, ready to shape web3 experiences.

---

# Getting the tokenId

Before we can proceed, we need to determine the tokenId. You can do this by retrieving the token balances for your wallet.

## Get your wallet balance

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.circle.com/v1/w3s/wallets/__WALLET_ID__/balances"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", "Bearer <YOUR_API_KEY>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(string(body))

}
```

#### Example response

```json
"response": {
    "data": {
      "tokenBalances": [
        {
          "token": {
            "id": "36b6931a-873a-56a8-8a27-b706b17104ee",
            "blockchain": "MATIC-AMOY",
            "tokenAddress": "0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",
            "standard": "ERC20",
            "name": "USDC",
            "symbol": "USDC",
            "decimals": 6,
            "isNative": false,
            "updateDate": "2024-03-27T17:55:12Z",
            "createDate": "2024-03-27T17:55:12Z"
          },
          "amount": "10",
          "updateDate": "2025-10-20T01:57:03Z"
        }
    ]
    }
}
```

---

# Transfer fund between account

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.circle.com/v1/w3s/developer/transactions/transfer"

	payload := strings.NewReader("{\"idempotencyKey\":\"<UNIQUE_UUID>\",\"entitySecretCipherText\":\"<GENERATED_ENTITY_SECRET_CIPHERTEXT>\",\"amounts\":[\"<AMOUNT_1>\"],\"feeLevel\":\"HIGH\",\"tokenId\":\"<ID_OF_THE_TOKEN_YOU_WANT_TO_TRANSFER>\",\"walletId\":\"<ID_OF_PREVIOUSLY_GENERATED_WALLET>\"}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", "Bearer <YOUR_API_KEY>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(string(body))

}
```

