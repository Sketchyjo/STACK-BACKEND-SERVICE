
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>alpaca: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stack-service/stack_service/internal/adapters/alpaca/client.go (45.7%)</option>
				
				<option value="file1">github.com/stack-service/stack_service/internal/domain/entities/admin_entities.go (0.0%)</option>
				
				<option value="file2">github.com/stack-service/stack_service/internal/domain/entities/alpaca_entities.go (0.0%)</option>
				
				<option value="file3">github.com/stack-service/stack_service/internal/domain/entities/auth_entities.go (0.0%)</option>
				
				<option value="file4">github.com/stack-service/stack_service/internal/domain/entities/fund_protection_entities.go (0.0%)</option>
				
				<option value="file5">github.com/stack-service/stack_service/internal/domain/entities/funding_job_entities.go (0.0%)</option>
				
				<option value="file6">github.com/stack-service/stack_service/internal/domain/entities/onboarding_entities.go (0.0%)</option>
				
				<option value="file7">github.com/stack-service/stack_service/internal/domain/entities/onboarding_job_entities.go (0.0%)</option>
				
				<option value="file8">github.com/stack-service/stack_service/internal/domain/entities/transfer_entities.go (0.0%)</option>
				
				<option value="file9">github.com/stack-service/stack_service/internal/domain/entities/wallet_entities.go (0.0%)</option>
				
				<option value="file10">github.com/stack-service/stack_service/internal/domain/entities/withdrawal_entities.go (0.0%)</option>
				
				<option value="file11">github.com/stack-service/stack_service/internal/domain/entities/zerog_entities.go (0.0%)</option>
				
				<option value="file12">github.com/stack-service/stack_service/internal/domain/services/funding/service.go (0.0%)</option>
				
				<option value="file13">github.com/stack-service/stack_service/internal/domain/services/wallet/service.go (18.3%)</option>
				
				<option value="file14">github.com/stack-service/stack_service/internal/infrastructure/circle/client.go (0.0%)</option>
				
				<option value="file15">github.com/stack-service/stack_service/pkg/retry/retry.go (0.0%)</option>
				
				<option value="file16">github.com/stack-service/stack_service/pkg/webhook/security.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package alpaca

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "math"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/sony/gobreaker"
        "github.com/stack-service/stack_service/internal/domain/entities"
        "go.uber.org/zap"
)

const (
        // Default timeouts and limits
        defaultTimeout    = 30 * time.Second
        maxRetries        = 3
        baseBackoff       = 1 * time.Second
        maxBackoff        = 16 * time.Second
        jitterRange       = 0.1 // 10% jitter
        defaultRetryAfter = 5 * time.Second
        maxRetryAfter     = 60 * time.Second

        // Alpaca API rate limits (requests per minute)
        alpacaRateLimitRPM = 200
        rateLimitBurst     = 20

        // Alpaca API endpoints
        accountsEndpoint  = "/v1/accounts"
        ordersEndpoint    = "/v1/trading/accounts/%s/orders" // account_id parameter
        assetsEndpoint    = "/v1/assets"
        positionsEndpoint = "/v1/trading/accounts/%s/positions" // account_id parameter
        newsEndpoint      = "/v1beta1/news"
)

// Config represents Alpaca API configuration
type Config struct {
        APIKey         string
        APISecret      string
        BaseURL        string // Broker API base URL
        DataBaseURL    string // Market Data API base URL
        Environment    string // sandbox or production
        Timeout        time.Duration
        RateLimitRPM   int // Requests per minute (0 = use default)
        RateLimitBurst int // Burst capacity (0 = use default)
}

// Client represents an Alpaca Broker API client
type Client struct {
        config         Config
        httpClient     *http.Client
        circuitBreaker *gobreaker.CircuitBreaker
        rateLimiter    *time.Ticker
        requestTokens  chan struct{}
        logger         *zap.Logger
}

// NewClient creates a new Alpaca API client
func NewClient(config Config, logger *zap.Logger) *Client <span class="cov5" title="11">{
        if config.Timeout == 0 </span><span class="cov2" title="2">{
                config.Timeout = defaultTimeout
        }</span>

        // Set default rate limits if not provided
        <span class="cov5" title="11">if config.RateLimitRPM == 0 </span><span class="cov4" title="9">{
                config.RateLimitRPM = alpacaRateLimitRPM
        }</span>
        <span class="cov5" title="11">if config.RateLimitBurst == 0 </span><span class="cov4" title="9">{
                config.RateLimitBurst = rateLimitBurst
        }</span>

        <span class="cov5" title="11">if config.BaseURL == "" </span><span class="cov2" title="2">{
                if config.Environment == "production" </span><span class="cov1" title="1">{
                        config.BaseURL = "https://broker-api.alpaca.markets"
                }</span> else<span class="cov1" title="1"> {
                        config.BaseURL = "https://broker-api.sandbox.alpaca.markets"
                }</span>
        }
        <span class="cov5" title="11">config.BaseURL = strings.TrimRight(config.BaseURL, "/")

        if config.DataBaseURL == "" </span><span class="cov4" title="10">{
                config.DataBaseURL = "https://data.alpaca.markets"
        }</span>
        <span class="cov5" title="11">config.DataBaseURL = strings.TrimRight(config.DataBaseURL, "/")

        httpClient := &amp;http.Client{
                Timeout: config.Timeout,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                MinVersion: tls.VersionTLS12,
                        },
                        MaxIdleConns:        100,
                        MaxIdleConnsPerHost: 10,
                        IdleConnTimeout:     90 * time.Second,
                },
        }

        // Initialize rate limiter
        rateLimiter := time.NewTicker(time.Minute / time.Duration(config.RateLimitRPM))
        requestTokens := make(chan struct{}, config.RateLimitBurst)

        // Fill initial burst capacity
        for i := 0; i &lt; config.RateLimitBurst; i++ </span><span class="cov10" title="191">{
                requestTokens &lt;- struct{}{}
        }</span>

        // Token replenishment goroutine
        <span class="cov5" title="11">go func() </span><span class="cov5" title="11">{
                for range rateLimiter.C </span><span class="cov7" title="35">{
                        select </span>{
                        case requestTokens &lt;- struct{}{}:<span class="cov4" title="7"></span>
                        default:<span class="cov6" title="28"></span>
                                // Channel is full, skip this token
                        }
                }
        }()

        <span class="cov5" title="11">st := gobreaker.Settings{
                Name:        "AlpacaBrokerAPI",
                MaxRequests: 5,
                Interval:    10 * time.Second,
                Timeout:     30 * time.Second,
                ReadyToTrip: func(counts gobreaker.Counts) bool </span><span class="cov2" title="3">{
                        return counts.ConsecutiveFailures &gt; 5
                }</span>,
                OnStateChange: func(name string, from gobreaker.State, to gobreaker.State) <span class="cov0" title="0">{
                        logger.Info("Circuit breaker state changed",
                                zap.String("name", name),
                                zap.String("from", from.String()),
                                zap.String("to", to.String()))
                }</span>,
        }

        <span class="cov5" title="11">circuitBreaker := gobreaker.NewCircuitBreaker(st)

        return &amp;Client{
                config:         config,
                httpClient:     httpClient,
                circuitBreaker: circuitBreaker,
                rateLimiter:    rateLimiter,
                requestTokens:  requestTokens,
                logger:         logger,
        }</span>
}

// Account Management Methods

// CreateAccount creates a new brokerage account
func (c *Client) CreateAccount(ctx context.Context, req *entities.AlpacaCreateAccountRequest) (*entities.AlpacaAccountResponse, error) <span class="cov0" title="0">{
        c.logger.Info("Creating Alpaca brokerage account",
                zap.String("email", req.Contact.EmailAddress))

        var response entities.AlpacaAccountResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "POST", accountsEndpoint, req, &amp;response, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to create Alpaca account",
                        zap.String("email", req.Contact.EmailAddress),
                        zap.Error(err))
                return nil, fmt.Errorf("create account failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Created Alpaca account successfully",
                zap.String("account_id", response.ID),
                zap.String("account_number", response.AccountNumber),
                zap.String("status", string(response.Status)))

        return &amp;response, nil</span>
}

// GetAccount retrieves account details by account ID
func (c *Client) GetAccount(ctx context.Context, accountID string) (*entities.AlpacaAccountResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf("%s/%s", accountsEndpoint, accountID)

        var response entities.AlpacaAccountResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get Alpaca account",
                        zap.String("account_id", accountID),
                        zap.Error(err))
                return nil, fmt.Errorf("get account failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// ListAccounts lists all accounts
func (c *Client) ListAccounts(ctx context.Context, query map[string]string) ([]entities.AlpacaAccountResponse, error) <span class="cov0" title="0">{
        endpoint := accountsEndpoint
        if len(query) &gt; 0 </span><span class="cov0" title="0">{
                params := url.Values{}
                for k, v := range query </span><span class="cov0" title="0">{
                        params.Add(k, v)
                }</span>
                <span class="cov0" title="0">endpoint = fmt.Sprintf("%s?%s", endpoint, params.Encode())</span>
        }

        <span class="cov0" title="0">var response []entities.AlpacaAccountResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to list Alpaca accounts", zap.Error(err))
                return nil, fmt.Errorf("list accounts failed: %w", err)
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

// Trading Methods

// CreateOrder creates a new order for an account
func (c *Client) CreateOrder(ctx context.Context, accountID string, req *entities.AlpacaCreateOrderRequest) (*entities.AlpacaOrderResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf(ordersEndpoint, accountID)

        c.logger.Info("Creating Alpaca order",
                zap.String("account_id", accountID),
                zap.String("symbol", req.Symbol),
                zap.String("side", string(req.Side)),
                zap.String("type", string(req.Type)))

        var response entities.AlpacaOrderResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "POST", endpoint, req, &amp;response, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to create Alpaca order",
                        zap.String("account_id", accountID),
                        zap.String("symbol", req.Symbol),
                        zap.Error(err))
                return nil, fmt.Errorf("create order failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Created Alpaca order successfully",
                zap.String("order_id", response.ID),
                zap.String("status", string(response.Status)))

        return &amp;response, nil</span>
}

// GetOrder retrieves an order by ID
func (c *Client) GetOrder(ctx context.Context, accountID, orderID string) (*entities.AlpacaOrderResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf(ordersEndpoint+"/%s", accountID, orderID)

        var response entities.AlpacaOrderResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get Alpaca order",
                        zap.String("account_id", accountID),
                        zap.String("order_id", orderID),
                        zap.Error(err))
                return nil, fmt.Errorf("get order failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// ListOrders lists all orders for an account
func (c *Client) ListOrders(ctx context.Context, accountID string, query map[string]string) ([]entities.AlpacaOrderResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf(ordersEndpoint, accountID)
        if len(query) &gt; 0 </span><span class="cov0" title="0">{
                params := url.Values{}
                for k, v := range query </span><span class="cov0" title="0">{
                        params.Add(k, v)
                }</span>
                <span class="cov0" title="0">endpoint = fmt.Sprintf("%s?%s", endpoint, params.Encode())</span>
        }

        <span class="cov0" title="0">var response []entities.AlpacaOrderResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to list Alpaca orders",
                        zap.String("account_id", accountID),
                        zap.Error(err))
                return nil, fmt.Errorf("list orders failed: %w", err)
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

// CancelOrder cancels an order
func (c *Client) CancelOrder(ctx context.Context, accountID, orderID string) error <span class="cov0" title="0">{
        endpoint := fmt.Sprintf(ordersEndpoint+"/%s", accountID, orderID)

        c.logger.Info("Canceling Alpaca order",
                zap.String("account_id", accountID),
                zap.String("order_id", orderID))

        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return nil, c.doRequestWithRetry(ctx, "DELETE", endpoint, nil, nil, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to cancel Alpaca order",
                        zap.String("account_id", accountID),
                        zap.String("order_id", orderID),
                        zap.Error(err))
                return fmt.Errorf("cancel order failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Canceled Alpaca order successfully",
                zap.String("order_id", orderID))

        return nil</span>
}

// Asset Methods

// GetAsset retrieves an asset by symbol or ID
func (c *Client) GetAsset(ctx context.Context, symbolOrID string) (*entities.AlpacaAssetResponse, error) <span class="cov4" title="8">{
        endpoint := fmt.Sprintf("%s/%s", assetsEndpoint, symbolOrID)

        var response entities.AlpacaAssetResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov4" title="8">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, false)
        }</span>)

        <span class="cov4" title="8">if err != nil </span><span class="cov2" title="3">{
                c.logger.Error("Failed to get Alpaca asset",
                        zap.String("symbol_or_id", symbolOrID),
                        zap.Error(err))
                return nil, fmt.Errorf("get asset failed: %w", err)
        }</span>

        <span class="cov3" title="5">return &amp;response, nil</span>
}

// ListAssets lists all assets
func (c *Client) ListAssets(ctx context.Context, query map[string]string) ([]entities.AlpacaAssetResponse, error) <span class="cov1" title="1">{
        endpoint := assetsEndpoint
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                params := url.Values{}
                for k, v := range query </span><span class="cov2" title="2">{
                        params.Add(k, v)
                }</span>
                <span class="cov1" title="1">endpoint = fmt.Sprintf("%s?%s", endpoint, params.Encode())</span>
        }

        <span class="cov1" title="1">var response []entities.AlpacaAssetResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov1" title="1">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, false)
        }</span>)

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to list Alpaca assets", zap.Error(err))
                return nil, fmt.Errorf("list assets failed: %w", err)
        }</span>

        <span class="cov1" title="1">return response, nil</span>
}

// Position Methods

// GetPosition retrieves a position by symbol
func (c *Client) GetPosition(ctx context.Context, accountID, symbol string) (*entities.AlpacaPositionResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf(positionsEndpoint+"/%s", accountID, symbol)

        var response entities.AlpacaPositionResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get Alpaca position",
                        zap.String("account_id", accountID),
                        zap.String("symbol", symbol),
                        zap.Error(err))
                return nil, fmt.Errorf("get position failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// ListPositions lists all positions for an account
func (c *Client) ListPositions(ctx context.Context, accountID string) ([]entities.AlpacaPositionResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf(positionsEndpoint, accountID)

        var response []entities.AlpacaPositionResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, false)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to list Alpaca positions",
                        zap.String("account_id", accountID),
                        zap.Error(err))
                return nil, fmt.Errorf("list positions failed: %w", err)
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

// Market Data Methods

// GetNews fetches news articles from the market data API
func (c *Client) GetNews(ctx context.Context, req *entities.AlpacaNewsRequest) (*entities.AlpacaNewsResponse, error) <span class="cov0" title="0">{
        endpoint := newsEndpoint
        params := url.Values{}

        if len(req.Symbols) &gt; 0 </span><span class="cov0" title="0">{
                params.Add("symbols", strings.Join(req.Symbols, ","))
        }</span>
        <span class="cov0" title="0">if req.Start != nil </span><span class="cov0" title="0">{
                params.Add("start", req.Start.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">if req.End != nil </span><span class="cov0" title="0">{
                params.Add("end", req.End.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">if req.Limit &gt; 0 </span><span class="cov0" title="0">{
                params.Add("limit", fmt.Sprintf("%d", req.Limit))
        }</span>
        <span class="cov0" title="0">if req.Sort != "" </span><span class="cov0" title="0">{
                params.Add("sort", req.Sort)
        }</span>
        <span class="cov0" title="0">if req.IncludeContent </span><span class="cov0" title="0">{
                params.Add("include_content", "true")
        }</span>
        <span class="cov0" title="0">if req.ExcludeContentless </span><span class="cov0" title="0">{
                params.Add("exclude_contentless", "true")
        }</span>
        <span class="cov0" title="0">if req.PageToken != "" </span><span class="cov0" title="0">{
                params.Add("page_token", req.PageToken)
        }</span>

        <span class="cov0" title="0">if len(params) &gt; 0 </span><span class="cov0" title="0">{
                endpoint = fmt.Sprintf("%s?%s", endpoint, params.Encode())
        }</span>

        <span class="cov0" title="0">c.logger.Info("Fetching Alpaca news",
                zap.Strings("symbols", req.Symbols),
                zap.Int("limit", req.Limit))

        var response entities.AlpacaNewsResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response, true)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to fetch Alpaca news", zap.Error(err))
                return nil, fmt.Errorf("get news failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Fetched Alpaca news successfully",
                zap.Int("count", len(response.News)))

        return &amp;response, nil</span>
}

// HTTP helper methods

// doRequestWithRetry performs an HTTP request with exponential backoff retry
func (c *Client) doRequestWithRetry(ctx context.Context, method, endpoint string, body, response interface{}, useDataAPI bool) error <span class="cov4" title="9">{
        var lastErr error

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov5" title="15">{
                if attempt &gt; 0 </span><span class="cov4" title="6">{
                        backoff := calculateBackoff(attempt)
                        c.logger.Info("Retrying Alpaca API request",
                                zap.Int("attempt", attempt),
                                zap.Duration("backoff", backoff))

                        select </span>{
                        case &lt;-time.After(backoff):<span class="cov4" title="6"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }
                }

                // Acquire rate limit token
                <span class="cov5" title="15">select </span>{
                case &lt;-c.requestTokens:<span class="cov5" title="15"></span>
                        // Token acquired, proceed
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(c.config.Timeout):<span class="cov0" title="0">
                        return fmt.Errorf("rate limit token acquisition timeout")</span>
                }

                <span class="cov5" title="15">err := c.doRequest(ctx, method, endpoint, body, response, useDataAPI)
                if err == nil </span><span class="cov4" title="6">{
                        return nil
                }</span>

                <span class="cov4" title="9">lastErr = err

                // Check if error is retryable
                if !isRetryableError(err) </span><span class="cov2" title="2">{
                        c.logger.Warn("Non-retryable error encountered",
                                zap.Error(err))
                        return err
                }</span>

                <span class="cov4" title="7">c.logger.Warn("Retryable error encountered",
                        zap.Error(err),
                        zap.Int("attempt", attempt))</span>
        }

        <span class="cov1" title="1">return fmt.Errorf("max retries exceeded: %w", lastErr)</span>
}

// doRequest performs a single HTTP request
func (c *Client) doRequest(ctx context.Context, method, endpoint string, body, response interface{}, useDataAPI bool) error <span class="cov5" title="15">{
        baseURL := c.config.BaseURL
        if useDataAPI </span><span class="cov0" title="0">{
                baseURL = c.config.DataBaseURL
        }</span>

        <span class="cov5" title="15">fullURL := baseURL + endpoint

        var reqBody io.Reader
        if body != nil </span><span class="cov0" title="0">{
                jsonData, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov0" title="0">reqBody = bytes.NewReader(jsonData)</span>
        }

        <span class="cov5" title="15">req, err := http.NewRequestWithContext(ctx, method, fullURL, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov5" title="15">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        // Alpaca requires API key and secret as specific headers
        req.Header.Set("APCA-API-KEY-ID", c.config.APIKey)
        req.Header.Set("APCA-API-SECRET-KEY", c.config.APISecret)

        c.logger.Debug("Sending Alpaca API request",
                zap.String("method", method),
                zap.String("url", fullURL))

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov3" title="5">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov4" title="10">defer resp.Body.Close()

        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov4" title="10">c.logger.Debug("Received Alpaca API response",
                zap.Int("status_code", resp.StatusCode),
                zap.Int("body_size", len(respBody)))

        // Check for error responses
        if resp.StatusCode &gt;= 400 </span><span class="cov3" title="4">{
                var apiErr entities.AlpacaErrorResponse
                if err := json.Unmarshal(respBody, &amp;apiErr); err == nil &amp;&amp; apiErr.Message != "" </span><span class="cov3" title="4">{
                        apiErr.Code = resp.StatusCode

                        // Handle rate limiting specifically
                        if resp.StatusCode == http.StatusTooManyRequests </span><span class="cov1" title="1">{
                                if retryAfter := resp.Header.Get("Retry-After"); retryAfter != "" </span><span class="cov1" title="1">{
                                        if seconds, err := strconv.Atoi(retryAfter); err == nil </span><span class="cov1" title="1">{
                                                c.logger.Warn("Rate limited by Alpaca API",
                                                        zap.Int("retry_after_seconds", seconds),
                                                        zap.String("endpoint", endpoint))
                                        }</span>
                                }
                        }

                        <span class="cov3" title="4">return &amp;apiErr</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("API error: status %d, body: %s", resp.StatusCode, string(respBody))</span>
        }

        // Parse response if a response object is provided
        <span class="cov4" title="6">if response != nil &amp;&amp; len(respBody) &gt; 0 </span><span class="cov4" title="6">{
                if err := json.Unmarshal(respBody, response); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal response: %w", err)
                }</span>
        }

        <span class="cov4" title="6">return nil</span>
}

// calculateBackoff calculates exponential backoff with jitter
func calculateBackoff(attempt int) time.Duration <span class="cov7" title="56">{
        // Calculate exponential backoff: baseBackoff * 2^(attempt-1)
        backoff := float64(baseBackoff) * math.Pow(2, float64(attempt-1))

        // Apply max backoff limit
        if backoff &gt; float64(maxBackoff) </span><span class="cov0" title="0">{
                backoff = float64(maxBackoff)
        }</span>

        // Add jitter (Â±10%)
        <span class="cov7" title="56">jitter := backoff * jitterRange * (2*getRandomFloat() - 1)
        backoff += jitter

        return time.Duration(backoff)</span>
}

// getRandomFloat returns a random float between 0 and 1
func getRandomFloat() float64 <span class="cov7" title="56">{
        return float64(time.Now().UnixNano()%1000) / 1000.0
}</span>

// Close gracefully shuts down the client and cleans up resources
func (c *Client) Close() error <span class="cov5" title="11">{
        if c.rateLimiter != nil </span><span class="cov5" title="11">{
                c.rateLimiter.Stop()
        }</span>
        <span class="cov5" title="11">c.logger.Info("Alpaca client closed")
        return nil</span>
}

// isRetryableError determines if an error should trigger a retry
func isRetryableError(err error) bool <span class="cov6" title="19">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check for Alpaca API errors
        <span class="cov5" title="18">if apiErr, ok := err.(*entities.AlpacaErrorResponse); ok </span><span class="cov5" title="11">{
                // Retry on rate limits and server errors
                switch apiErr.Code </span>{
                case http.StatusTooManyRequests:<span class="cov2" title="2">
                        return true</span> // Rate limited, worth retrying after backoff
                case http.StatusInternalServerError, http.StatusBadGateway, http.StatusServiceUnavailable, http.StatusGatewayTimeout:<span class="cov4" title="6">
                        return true</span> // Server errors, worth retrying
                case http.StatusRequestTimeout:<span class="cov0" title="0">
                        return true</span> // Request timeout, worth retrying
                default:<span class="cov2" title="3">
                        return false</span> // Client errors (4xx except 429) should not be retried
                }
        }

        // Retry on network errors and timeouts
        <span class="cov4" title="7">errStr := strings.ToLower(err.Error())
        return strings.Contains(errStr, "timeout") ||
                strings.Contains(errStr, "deadline exceeded") ||
                strings.Contains(errStr, "context deadline exceeded") ||
                strings.Contains(errStr, "connection refused") ||
                strings.Contains(errStr, "connection reset") ||
                strings.Contains(errStr, "connection closed") ||
                strings.Contains(errStr, "eof") ||
                strings.Contains(errStr, "temporary failure") ||
                strings.Contains(errStr, "network is unreachable") ||
                strings.Contains(errStr, "no such host")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
)

// CreateWalletSetRequest represents request to create a wallet set
type CreateWalletSetRequest struct {
        Name              string `json:"name" validate:"required"`
        CircleWalletSetID string `json:"circle_wallet_set_id,omitempty"`
}

// WalletSetsListResponse represents response for wallet sets listing
type WalletSetsListResponse struct {
        Items []WalletSet `json:"items"`
        Count int         `json:"count"`
}

// WalletSetDetailResponse represents detailed wallet set response
type WalletSetDetailResponse struct {
        WalletSet WalletSet       `json:"wallet_set"`
        Wallets   []ManagedWallet `json:"wallets,omitempty"`
        Stats     WalletSetStats  `json:"stats,omitempty"`
}

// WalletSetStats represents statistics for a wallet set
type WalletSetStats struct {
        TotalWallets    int64 `json:"total_wallets"`
        LiveWallets     int64 `json:"live_wallets"`
        CreatingWallets int64 `json:"creating_wallets"`
        FailedWallets   int64 `json:"failed_wallets"`
}

// AdminWalletsListResponse represents response for admin wallets listing
type AdminWalletsListResponse struct {
        Items []ManagedWallet `json:"items"`
        Count int             `json:"count"`
}

// AdminRole represents the role assigned to privileged users
type AdminRole string

const (
        AdminRoleUser       AdminRole = "user"
        AdminRoleAdmin      AdminRole = "admin"
        AdminRoleSuperAdmin AdminRole = "super_admin"
)

// IsValid checks whether the role is one of the supported admin roles
func (r AdminRole) IsValid() bool <span class="cov0" title="0">{
        switch r </span>{
        case AdminRoleAdmin, AdminRoleSuperAdmin:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// CreateAdminRequest captures the payload required to create a new admin user
type CreateAdminRequest struct {
        Email     string     `json:"email" binding:"required,email"`
        Password  string     `json:"password" binding:"required,min=8"`
        FirstName *string    `json:"firstName,omitempty"`
        LastName  *string    `json:"lastName,omitempty"`
        Phone     *string    `json:"phone,omitempty"`
        Role      *AdminRole `json:"role,omitempty"`
}

// AdminUserResponse represents an admin user's information returned to clients
type AdminUserResponse struct {
        ID               uuid.UUID        `json:"id"`
        Email            string           `json:"email"`
        Role             AdminRole        `json:"role"`
        IsActive         bool             `json:"isActive"`
        OnboardingStatus OnboardingStatus `json:"onboardingStatus"`
        KYCStatus        string           `json:"kycStatus"`
        LastLoginAt      *time.Time       `json:"lastLoginAt,omitempty"`
        CreatedAt        time.Time        `json:"createdAt"`
        UpdatedAt        time.Time        `json:"updatedAt"`
}

// AdminSession contains auth tokens issued to newly created admins
type AdminSession struct {
        AccessToken  string    `json:"accessToken"`
        RefreshToken string    `json:"refreshToken"`
        ExpiresAt    time.Time `json:"expiresAt"`
}

// AdminCreationResponse packages admin details with the bootstrapped session
type AdminCreationResponse struct {
        AdminUserResponse
        AdminSession AdminSession `json:"adminSession"`
}

// UpdateUserStatusRequest represents the payload to activate or suspend a user
type UpdateUserStatusRequest struct {
        IsActive bool `json:"isActive"`
}

// AdminTransaction represents a transaction surfaced in admin endpoints
type AdminTransaction struct {
        ID        uuid.UUID              `json:"id"`
        UserID    uuid.UUID              `json:"userId"`
        Type      string                 `json:"type"`
        Amount    string                 `json:"amount"`
        Status    string                 `json:"status"`
        CreatedAt time.Time              `json:"createdAt"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// SystemAnalytics aggregates platform-level metrics for admin dashboards
type SystemAnalytics struct {
        TotalUsers      int64     `json:"totalUsers"`
        ActiveUsers     int64     `json:"activeUsers"`
        TotalAdmins     int64     `json:"totalAdmins"`
        TotalDeposits   string    `json:"totalDeposits"`
        PendingDeposits int64     `json:"pendingDeposits"`
        TotalWallets    int64     `json:"totalWallets"`
        GeneratedAt     time.Time `json:"generatedAt"`
}

// CuratedBasketRequest captures the payload to create or update curated baskets
type CuratedBasketRequest struct {
        Name        string            `json:"name" binding:"required"`
        Description string            `json:"description" binding:"required"`
        RiskLevel   RiskLevel         `json:"riskLevel" binding:"required"`
        Composition []BasketComponent `json:"composition" binding:"required,dive"`
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package entities

import (
        "time"

        "github.com/shopspring/decimal"
)

// Alpaca Account Management Entities

// AlpacaAccountType represents the type of brokerage account
type AlpacaAccountType string

const (
        AlpacaAccountTypeTradingCash   AlpacaAccountType = "trading_cash"
        AlpacaAccountTypeTradingMargin AlpacaAccountType = "trading_margin"
)

// AlpacaAccountStatus represents the status of an account
type AlpacaAccountStatus string

const (
        AlpacaAccountStatusActive          AlpacaAccountStatus = "ACTIVE"
        AlpacaAccountStatusAccountUpdated  AlpacaAccountStatus = "ACCOUNT_UPDATED"
        AlpacaAccountStatusApprovalPending AlpacaAccountStatus = "APPROVAL_PENDING"
        AlpacaAccountStatusApproved        AlpacaAccountStatus = "APPROVED"
        AlpacaAccountStatusDisabled        AlpacaAccountStatus = "DISABLED"
        AlpacaAccountStatusRejected        AlpacaAccountStatus = "REJECTED"
        AlpacaAccountStatusSubmitted       AlpacaAccountStatus = "SUBMITTED"
)

// AlpacaCreateAccountRequest represents a request to create a new brokerage account
type AlpacaCreateAccountRequest struct {
        Contact        AlpacaContact         `json:"contact"`
        Identity       AlpacaIdentity        `json:"identity"`
        Disclosures    AlpacaDisclosures     `json:"disclosures"`
        Agreements     []AlpacaAgreement     `json:"agreements"`
        Documents      []AlpacaDocument      `json:"documents,omitempty"`
        TrustedContact *AlpacaTrustedContact `json:"trusted_contact,omitempty"`
}

// AlpacaContact contains contact information
type AlpacaContact struct {
        EmailAddress  string   `json:"email_address"`
        PhoneNumber   string   `json:"phone_number"`
        StreetAddress []string `json:"street_address"`
        City          string   `json:"city"`
        State         string   `json:"state,omitempty"` // For US addresses
        PostalCode    string   `json:"postal_code"`
        Country       string   `json:"country,omitempty"`
}

// AlpacaIdentity contains identity information
type AlpacaIdentity struct {
        GivenName             string   `json:"given_name"`
        MiddleName            string   `json:"middle_name,omitempty"`
        FamilyName            string   `json:"family_name"`
        DateOfBirth           string   `json:"date_of_birth"` // YYYY-MM-DD format
        TaxID                 string   `json:"tax_id,omitempty"`
        TaxIDType             string   `json:"tax_id_type,omitempty"` // USA_SSN, etc.
        CountryOfCitizenship  string   `json:"country_of_citizenship,omitempty"`
        CountryOfBirth        string   `json:"country_of_birth,omitempty"`
        CountryOfTaxResidence string   `json:"country_of_tax_residence,omitempty"`
        FundingSource         []string `json:"funding_source,omitempty"`
}

// AlpacaDisclosures contains regulatory disclosures
type AlpacaDisclosures struct {
        IsControlPerson             bool   `json:"is_control_person"`
        IsAffiliatedExchangeOrFINRA bool   `json:"is_affiliated_exchange_or_finra"`
        IsPoliticallyExposed        bool   `json:"is_politically_exposed"`
        ImmediateFamilyExposed      bool   `json:"immediate_family_exposed"`
        EmploymentStatus            string `json:"employment_status,omitempty"` // employed, unemployed, student, retired
        EmployerName                string `json:"employer_name,omitempty"`
        EmployerAddress             string `json:"employer_address,omitempty"`
        EmploymentPosition          string `json:"employment_position,omitempty"`
}

// AlpacaAgreement represents a signed agreement
type AlpacaAgreement struct {
        Agreement string `json:"agreement"` // account, customer, margin, etc.
        SignedAt  string `json:"signed_at"` // RFC3339 format
        IPAddress string `json:"ip_address"`
        Revision  string `json:"revision,omitempty"`
}

// AlpacaDocument represents an uploaded document
type AlpacaDocument struct {
        DocumentType    string `json:"document_type"` // identity_verification, etc.
        DocumentSubType string `json:"document_sub_type,omitempty"`
        Content         string `json:"content"` // Base64 encoded
        MIMEType        string `json:"mime_type"`
}

// AlpacaTrustedContact contains trusted contact information
type AlpacaTrustedContact struct {
        GivenName    string `json:"given_name"`
        FamilyName   string `json:"family_name"`
        EmailAddress string `json:"email_address,omitempty"`
}

// AlpacaAccountResponse represents the response when creating/getting an account
type AlpacaAccountResponse struct {
        ID                   string              `json:"id"`
        AccountNumber        string              `json:"account_number"`
        Status               AlpacaAccountStatus `json:"status"`
        CryptoStatus         string              `json:"crypto_status,omitempty"`
        Currency             string              `json:"currency"`
        BuyingPower          decimal.Decimal     `json:"buying_power"`
        Cash                 decimal.Decimal     `json:"cash"`
        PortfolioValue       decimal.Decimal     `json:"portfolio_value"`
        PatternDayTrader     bool                `json:"pattern_day_trader"`
        TradeSuspendedByUser bool                `json:"trade_suspended_by_user"`
        TradingBlocked       bool                `json:"trading_blocked"`
        TransfersBlocked     bool                `json:"transfers_blocked"`
        AccountBlocked       bool                `json:"account_blocked"`
        CreatedAt            time.Time           `json:"created_at"`
        Contact              AlpacaContact       `json:"contact,omitempty"`
        Identity             AlpacaIdentity      `json:"identity,omitempty"`
        Disclosures          AlpacaDisclosures   `json:"disclosures,omitempty"`
}

// Alpaca Trading Entities

// AlpacaOrderSide represents the side of an order
type AlpacaOrderSide string

const (
        AlpacaOrderSideBuy  AlpacaOrderSide = "buy"
        AlpacaOrderSideSell AlpacaOrderSide = "sell"
)

// AlpacaOrderType represents the type of order
type AlpacaOrderType string

const (
        AlpacaOrderTypeMarket       AlpacaOrderType = "market"
        AlpacaOrderTypeLimit        AlpacaOrderType = "limit"
        AlpacaOrderTypeStop         AlpacaOrderType = "stop"
        AlpacaOrderTypeStopLimit    AlpacaOrderType = "stop_limit"
        AlpacaOrderTypeTrailingStop AlpacaOrderType = "trailing_stop"
)

// AlpacaTimeInForce represents how long an order stays active
type AlpacaTimeInForce string

const (
        AlpacaTimeInForceDay AlpacaTimeInForce = "day"
        AlpacaTimeInForceGTC AlpacaTimeInForce = "gtc" // Good til canceled
        AlpacaTimeInForceOPG AlpacaTimeInForce = "opg" // Market on open
        AlpacaTimeInForceCLS AlpacaTimeInForce = "cls" // Market on close
        AlpacaTimeInForceIOC AlpacaTimeInForce = "ioc" // Immediate or cancel
        AlpacaTimeInForceFOK AlpacaTimeInForce = "fok" // Fill or kill
)

// AlpacaOrderStatus represents the status of an order
type AlpacaOrderStatus string

const (
        AlpacaOrderStatusNew                AlpacaOrderStatus = "new"
        AlpacaOrderStatusPartiallyFilled    AlpacaOrderStatus = "partially_filled"
        AlpacaOrderStatusFilled             AlpacaOrderStatus = "filled"
        AlpacaOrderStatusDoneForDay         AlpacaOrderStatus = "done_for_day"
        AlpacaOrderStatusCanceled           AlpacaOrderStatus = "canceled"
        AlpacaOrderStatusExpired            AlpacaOrderStatus = "expired"
        AlpacaOrderStatusReplaced           AlpacaOrderStatus = "replaced"
        AlpacaOrderStatusPendingCancel      AlpacaOrderStatus = "pending_cancel"
        AlpacaOrderStatusPendingReplace     AlpacaOrderStatus = "pending_replace"
        AlpacaOrderStatusAccepted           AlpacaOrderStatus = "accepted"
        AlpacaOrderStatusPendingNew         AlpacaOrderStatus = "pending_new"
        AlpacaOrderStatusAcceptedForBidding AlpacaOrderStatus = "accepted_for_bidding"
        AlpacaOrderStatusStopped            AlpacaOrderStatus = "stopped"
        AlpacaOrderStatusRejected           AlpacaOrderStatus = "rejected"
        AlpacaOrderStatusSuspended          AlpacaOrderStatus = "suspended"
        AlpacaOrderStatusCalculated         AlpacaOrderStatus = "calculated"
)

// AlpacaCreateOrderRequest represents a request to create an order
type AlpacaCreateOrderRequest struct {
        Symbol        string            `json:"symbol"`
        Qty           *decimal.Decimal  `json:"qty,omitempty"`      // Quantity (fractional shares supported)
        Notional      *decimal.Decimal  `json:"notional,omitempty"` // Dollar amount (for market orders)
        Side          AlpacaOrderSide   `json:"side"`
        Type          AlpacaOrderType   `json:"type"`
        TimeInForce   AlpacaTimeInForce `json:"time_in_force"`
        LimitPrice    *decimal.Decimal  `json:"limit_price,omitempty"`
        StopPrice     *decimal.Decimal  `json:"stop_price,omitempty"`
        TrailPrice    *decimal.Decimal  `json:"trail_price,omitempty"`
        TrailPercent  *decimal.Decimal  `json:"trail_percent,omitempty"`
        ExtendedHours bool              `json:"extended_hours,omitempty"`
        ClientOrderID string            `json:"client_order_id,omitempty"`
        OrderClass    string            `json:"order_class,omitempty"` // simple, bracket, oco, oto
        Commission    *decimal.Decimal  `json:"commission,omitempty"`
}

// AlpacaOrderResponse represents the response when creating/getting an order
type AlpacaOrderResponse struct {
        ID             string                `json:"id"`
        ClientOrderID  string                `json:"client_order_id"`
        CreatedAt      time.Time             `json:"created_at"`
        UpdatedAt      time.Time             `json:"updated_at"`
        SubmittedAt    time.Time             `json:"submitted_at"`
        FilledAt       *time.Time            `json:"filled_at"`
        ExpiredAt      *time.Time            `json:"expired_at"`
        CanceledAt     *time.Time            `json:"canceled_at"`
        FailedAt       *time.Time            `json:"failed_at"`
        ReplacedAt     *time.Time            `json:"replaced_at"`
        AssetID        string                `json:"asset_id"`
        Symbol         string                `json:"symbol"`
        AssetClass     string                `json:"asset_class"`
        Qty            decimal.Decimal       `json:"qty"`
        Notional       *decimal.Decimal      `json:"notional"`
        FilledQty      decimal.Decimal       `json:"filled_qty"`
        FilledAvgPrice *decimal.Decimal      `json:"filled_avg_price"`
        OrderClass     string                `json:"order_class"`
        OrderType      AlpacaOrderType       `json:"order_type"`
        Type           AlpacaOrderType       `json:"type"`
        Side           AlpacaOrderSide       `json:"side"`
        TimeInForce    AlpacaTimeInForce     `json:"time_in_force"`
        LimitPrice     *decimal.Decimal      `json:"limit_price"`
        StopPrice      *decimal.Decimal      `json:"stop_price"`
        Status         AlpacaOrderStatus     `json:"status"`
        ExtendedHours  bool                  `json:"extended_hours"`
        Legs           []AlpacaOrderResponse `json:"legs,omitempty"`
        TrailPrice     *decimal.Decimal      `json:"trail_price,omitempty"`
        TrailPercent   *decimal.Decimal      `json:"trail_percent,omitempty"`
        Commission     decimal.Decimal       `json:"commission"`
}

// Alpaca Asset Entities

// AlpacaAssetClass represents the class of an asset
type AlpacaAssetClass string

const (
        AlpacaAssetClassUSEquity AlpacaAssetClass = "us_equity"
        AlpacaAssetClassCrypto   AlpacaAssetClass = "crypto"
)

// AlpacaAssetStatus represents the status of an asset
type AlpacaAssetStatus string

const (
        AlpacaAssetStatusActive   AlpacaAssetStatus = "active"
        AlpacaAssetStatusInactive AlpacaAssetStatus = "inactive"
)

// AlpacaAssetResponse represents an asset (stock, ETF, crypto)
type AlpacaAssetResponse struct {
        ID                string            `json:"id"`
        Class             AlpacaAssetClass  `json:"class"`
        Exchange          string            `json:"exchange"`
        Symbol            string            `json:"symbol"`
        Name              string            `json:"name"`
        Status            AlpacaAssetStatus `json:"status"`
        Tradable          bool              `json:"tradable"`
        Marginable        bool              `json:"marginable"`
        Shortable         bool              `json:"shortable"`
        EasyToBorrow      bool              `json:"easy_to_borrow"`
        Fractionable      bool              `json:"fractionable"`
        MinOrderSize      *decimal.Decimal  `json:"min_order_size,omitempty"`
        MinTradeIncrement *decimal.Decimal  `json:"min_trade_increment,omitempty"`
        PriceIncrement    *decimal.Decimal  `json:"price_increment,omitempty"`
}

// Alpaca Position Entities

// AlpacaPositionResponse represents a position in a portfolio
type AlpacaPositionResponse struct {
        AssetID                string          `json:"asset_id"`
        Symbol                 string          `json:"symbol"`
        Exchange               string          `json:"exchange"`
        AssetClass             string          `json:"asset_class"`
        AvgEntryPrice          decimal.Decimal `json:"avg_entry_price"`
        Qty                    decimal.Decimal `json:"qty"`
        QtyAvailable           decimal.Decimal `json:"qty_available"`
        Side                   string          `json:"side"` // long or short
        MarketValue            decimal.Decimal `json:"market_value"`
        CostBasis              decimal.Decimal `json:"cost_basis"`
        UnrealizedPL           decimal.Decimal `json:"unrealized_pl"`
        UnrealizedPLPC         decimal.Decimal `json:"unrealized_plpc"` // percentage
        UnrealizedIntradayPL   decimal.Decimal `json:"unrealized_intraday_pl"`
        UnrealizedIntradayPLPC decimal.Decimal `json:"unrealized_intraday_plpc"`
        CurrentPrice           decimal.Decimal `json:"current_price"`
        LastdayPrice           decimal.Decimal `json:"lastday_price"`
        ChangeToday            decimal.Decimal `json:"change_today"`
}

// Alpaca Market Data Entities

// AlpacaNewsArticle represents a news article from market data API
type AlpacaNewsArticle struct {
        ID        int               `json:"id"`
        Author    string            `json:"author"`
        CreatedAt time.Time         `json:"created_at"`
        UpdatedAt time.Time         `json:"updated_at"`
        Headline  string            `json:"headline"`
        Summary   string            `json:"summary"`
        Content   string            `json:"content"`
        Images    []AlpacaNewsImage `json:"images,omitempty"`
        Symbols   []string          `json:"symbols"`
        Source    string            `json:"source"`
        URL       string            `json:"url"`
}

// AlpacaNewsImage represents an image in a news article
type AlpacaNewsImage struct {
        Size string `json:"size"` // thumb, small, large
        URL  string `json:"url"`
}

// AlpacaNewsRequest represents a request for news articles
type AlpacaNewsRequest struct {
        Symbols            []string   `json:"symbols,omitempty"`             // Filter by symbols
        Start              *time.Time `json:"start,omitempty"`               // Start time (RFC3339)
        End                *time.Time `json:"end,omitempty"`                 // End time (RFC3339)
        Limit              int        `json:"limit,omitempty"`               // Max results (default 10, max 50)
        Sort               string     `json:"sort,omitempty"`                // ASC or DESC
        IncludeContent     bool       `json:"include_content,omitempty"`     // Include full content
        ExcludeContentless bool       `json:"exclude_contentless,omitempty"` // Exclude articles without content
        PageToken          string     `json:"page_token,omitempty"`          // Pagination token
}

// AlpacaNewsResponse represents the response for news articles
type AlpacaNewsResponse struct {
        News          []AlpacaNewsArticle `json:"news"`
        NextPageToken string              `json:"next_page_token,omitempty"`
}

// Alpaca Error Response

// AlpacaErrorResponse represents an error response from Alpaca API
type AlpacaErrorResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func (e *AlpacaErrorResponse) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
)

// === Authentication Request/Response Models ===

// RegisterRequest represents a user registration request
type RegisterRequest struct {
        Email    string  `json:"email" validate:"required,email"`
        Phone    *string `json:"phone,omitempty" validate:"omitempty,e164"`
        Password string  `json:"password" validate:"required,min=8"`
}

// LoginRequest represents a user login request
type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

// AuthResponse represents the response after successful authentication
type AuthResponse struct {
        User         *UserInfo `json:"user"`
        AccessToken  string    `json:"accessToken"`
        RefreshToken string    `json:"refreshToken"`
        ExpiresAt    time.Time `json:"expiresAt"`
}

// UserInfo represents basic user information returned in auth responses
type UserInfo struct {
        ID               uuid.UUID        `json:"id"`
        Email            string           `json:"email"`
        Phone            *string          `json:"phone,omitempty"`
        EmailVerified    bool             `json:"emailVerified"`
        PhoneVerified    bool             `json:"phoneVerified"`
        OnboardingStatus OnboardingStatus `json:"onboardingStatus"`
        KYCStatus        string           `json:"kycStatus"`
        CreatedAt        time.Time        `json:"createdAt"`
}

// RefreshTokenRequest represents a token refresh request
type RefreshTokenRequest struct {
        RefreshToken string `json:"refreshToken" validate:"required"`
}

// ErrorResponse represents an error response
type ErrorResponse struct {
        Code    string                 `json:"code"`
        Message string                 `json:"message"`
        Details map[string]interface{} `json:"details,omitempty"`
}

// ForgotPasswordRequest represents a forgot password request
type ForgotPasswordRequest struct {
        Email string `json:"email" validate:"required,email"`
}

// ResetPasswordRequest represents a reset password request
type ResetPasswordRequest struct {
        Token    string `json:"token" validate:"required"`
        Password string `json:"password" validate:"required,min=8"`
}

// VerifyEmailRequest represents an email verification request
type VerifyEmailRequest struct {
        Token string `json:"token" validate:"required"`
}

// ChangePasswordRequest represents a change password request
type ChangePasswordRequest struct {
        CurrentPassword string `json:"currentPassword" validate:"required"`
        NewPassword     string `json:"newPassword" validate:"required,min=8"`
}

// SignUpRequest represents a user signup request with email OR phone
type SignUpRequest struct {
        Email    *string `json:"email,omitempty" validate:"omitempty,email"`
        Phone    *string `json:"phone,omitempty" validate:"omitempty,e164"`
        Password string  `json:"password" validate:"required,min=8"`
}

// VerifyCodeRequest represents a verification code request
type VerifyCodeRequest struct {
        Email *string `json:"email,omitempty" validate:"omitempty,email"`
        Phone *string `json:"phone,omitempty" validate:"omitempty,e164"`
        Code  string  `json:"code" validate:"required,len=6"`
}

// ResendCodeRequest represents a resend verification code request
type ResendCodeRequest struct {
        Email *string `json:"email,omitempty" validate:"omitempty,email"`
        Phone *string `json:"phone,omitempty" validate:"omitempty,e164"`
}

// VerificationCodeData represents verification code data stored in Redis
type VerificationCodeData struct {
        Code      string    `json:"code"`
        Attempts  int       `json:"attempts"`
        ExpiresAt time.Time `json:"expires_at"`
        CreatedAt time.Time `json:"created_at"`
}

// SignUpResponse represents the response after successful signup
type SignUpResponse struct {
        Message    string `json:"message"`
        Identifier string `json:"identifier"`
}

// VerifyCodeResponse represents the response after successful verification
type VerifyCodeResponse struct {
        User         *UserInfo `json:"user"`
        AccessToken  string    `json:"accessToken"`
        RefreshToken string    `json:"refreshToken"`
        ExpiresAt    time.Time `json:"expiresAt"`
}

// UserRole defines available user roles
type UserRole string

const (
        RoleUser       UserRole = "user"
        RolePremium    UserRole = "premium"
        RoleTrader     UserRole = "trader"
        RoleAdmin      UserRole = "admin"
        RoleSuperAdmin UserRole = "super_admin"
)

// IsValid checks if the role is valid
func (r UserRole) IsValid() bool <span class="cov0" title="0">{
        return r == RoleUser || r == RolePremium || r == RoleTrader || r == RoleAdmin || r == RoleSuperAdmin
}</span>

// HasPermission checks if the role has the required permission level
func (r UserRole) HasPermission(requiredRole UserRole) bool <span class="cov0" title="0">{
        roleHierarchy := map[UserRole]int{
                RoleUser:       1,
                RolePremium:    2,
                RoleTrader:     3,
                RoleAdmin:      4,
                RoleSuperAdmin: 5,
        }
        return roleHierarchy[r] &gt;= roleHierarchy[requiredRole]
}</span>

// User represents a complete user entity for database operations
type User struct {
        ID                 uuid.UUID        `json:"id" db:"id"`
        Email              string           `json:"email" db:"email"`
        Phone              *string          `json:"phone" db:"phone"`
        PasswordHash       string           `json:"-" db:"password_hash"`
        AuthProviderID     *string          `json:"authProviderId" db:"auth_provider_id"`
        EmailVerified      bool             `json:"emailVerified" db:"email_verified"`
        PhoneVerified      bool             `json:"phoneVerified" db:"phone_verified"`
        OnboardingStatus   OnboardingStatus `json:"onboardingStatus" db:"onboarding_status"`
        KYCStatus          string           `json:"kycStatus" db:"kyc_status"`
        KYCProviderRef     *string          `json:"kycProviderRef" db:"kyc_provider_ref"`
        KYCSubmittedAt     *time.Time       `json:"kycSubmittedAt" db:"kyc_submitted_at"`
        KYCApprovedAt      *time.Time       `json:"kycApprovedAt" db:"kyc_approved_at"`
        KYCRejectionReason *string          `json:"kycRejectionReason" db:"kyc_rejection_reason"`
        Role               UserRole         `json:"role" db:"role"`
        IsActive           bool             `json:"isActive" db:"is_active"`
        LastLoginAt        *time.Time       `json:"lastLoginAt" db:"last_login_at"`
        CreatedAt          time.Time        `json:"createdAt" db:"created_at"`
        UpdatedAt          time.Time        `json:"updatedAt" db:"updated_at"`
}

// ToUserInfo converts User to UserInfo for public responses
func (u *User) ToUserInfo() *UserInfo <span class="cov0" title="0">{
        return &amp;UserInfo{
                ID:               u.ID,
                Email:            u.Email,
                Phone:            u.Phone,
                EmailVerified:    u.EmailVerified,
                PhoneVerified:    u.PhoneVerified,
                OnboardingStatus: u.OnboardingStatus,
                KYCStatus:        u.KYCStatus,
                CreatedAt:        u.CreatedAt,
        }
}</span>

// ToUserProfile converts User to UserProfile for onboarding operations
func (u *User) ToUserProfile() *UserProfile <span class="cov0" title="0">{
        return &amp;UserProfile{
                ID:                 u.ID,
                AuthProviderID:     u.AuthProviderID,
                Email:              u.Email,
                Phone:              u.Phone,
                EmailVerified:      u.EmailVerified,
                PhoneVerified:      u.PhoneVerified,
                OnboardingStatus:   u.OnboardingStatus,
                KYCStatus:          u.KYCStatus,
                KYCProviderRef:     u.KYCProviderRef,
                KYCSubmittedAt:     u.KYCSubmittedAt,
                KYCApprovedAt:      u.KYCApprovedAt,
                KYCRejectionReason: u.KYCRejectionReason,
                IsActive:           u.IsActive,
                CreatedAt:          u.CreatedAt,
                UpdatedAt:          u.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
)

// === Withdrawal Protection Entities ===

// RecoveryStatus represents the status of a recovery request
type RecoveryStatus string

const (
        RecoveryStatusPending   RecoveryStatus = "pending"
        RecoveryStatusInReview  RecoveryStatus = "in_review"
        RecoveryStatusApproved  RecoveryStatus = "approved"
        RecoveryStatusCompleted RecoveryStatus = "completed"
        RecoveryStatusRejected  RecoveryStatus = "rejected"
        RecoveryStatusExpired   RecoveryStatus = "expired"
        RecoveryStatusCancelled RecoveryStatus = "cancelled"
)

// RecoveryType represents the type of recovery requested
type RecoveryType string

const (
        RecoveryTypePasswordReset RecoveryType = "password_reset"
        RecoveryTypeWalletAccess  RecoveryType = "wallet_access"
        RecoveryTypeAccountAccess RecoveryType = "account_access"
)

// RecoveryPriority represents the priority level of recovery
type RecoveryPriority string

const (
        RecoveryPriorityLow    RecoveryPriority = "low"
        RecoveryPriorityMedium RecoveryPriority = "medium"
        RecoveryPriorityHigh   RecoveryPriority = "high"
        RecoveryPriorityUrgent RecoveryPriority = "urgent"
)

// RecoveryRequest represents a fund recovery request
type RecoveryRequest struct {
        ID                     uuid.UUID              `json:"id" db:"id"`
        UserID                 uuid.UUID              `json:"user_id" db:"user_id"`
        RecoveryType           RecoveryType           `json:"recovery_type" db:"recovery_type"`
        Status                 RecoveryStatus         `json:"status" db:"status"`
        Priority               RecoveryPriority       `json:"priority" db:"priority"`
        Reason                 string                 `json:"reason" db:"reason"`
        ExpiresAt              time.Time              `json:"expires_at" db:"expires_at"`
        RequiredVerifications  []string               `json:"required_verifications" db:"required_verifications"`
        CompletedVerifications []string               `json:"completed_verifications,omitempty" db:"completed_verifications"`
        Metadata               map[string]interface{} `json:"metadata,omitempty" db:"metadata"`
        ProcessedBy            *uuid.UUID             `json:"processed_by,omitempty" db:"processed_by"`
        ProcessedAt            *time.Time             `json:"processed_at,omitempty" db:"processed_at"`
        Notes                  *string                `json:"notes,omitempty" db:"notes"`
        CreatedAt              time.Time              `json:"created_at" db:"created_at"`
        UpdatedAt              time.Time              `json:"updated_at" db:"updated_at"`

        // Related entities (not stored in DB)
        User *User `json:"user,omitempty"`
}

// IsExpired checks if the recovery request has expired
func (r *RecoveryRequest) IsExpired() bool <span class="cov0" title="0">{
        return time.Now().After(r.ExpiresAt)
}</span>

// CanBeProcessed checks if the recovery request can be processed
func (r *RecoveryRequest) CanBeProcessed() bool <span class="cov0" title="0">{
        return r.Status == RecoveryStatusPending || r.Status == RecoveryStatusInReview
}</span>

// RecoveryAction represents an action taken during recovery
type RecoveryAction struct {
        ID          uuid.UUID              `json:"id" db:"id"`
        RecoveryID  uuid.UUID              `json:"recovery_id" db:"recovery_id"`
        ActionType  RecoveryActionType     `json:"action_type" db:"action_type"`
        Step        string                 `json:"step" db:"step"`
        Status      RecoveryActionStatus   `json:"status" db:"status"`
        Details     map[string]interface{} `json:"details" db:"details"`
        PerformedAt time.Time              `json:"performed_at" db:"performed_at"`
        PerformedBy *uuid.UUID             `json:"performed_by,omitempty" db:"performed_by"`
        IPAddress   *string                `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent   *string                `json:"user_agent,omitempty" db:"user_agent"`
}

// RecoveryActionType represents types of recovery actions
type RecoveryActionType string

const (
        RecoveryActionVerification RecoveryActionType = "verification"
        RecoveryActionReview       RecoveryActionType = "review"
        RecoveryActionRecovery     RecoveryActionType = "recovery"
        RecoveryActionRejection    RecoveryActionType = "rejection"
)

// RecoveryActionStatus represents the status of a recovery action
type RecoveryActionStatus string

const (
        RecoveryActionStatusPending   RecoveryActionStatus = "pending"
        RecoveryActionStatusCompleted RecoveryActionStatus = "completed"
        RecoveryActionStatusFailed    RecoveryActionStatus = "failed"
)

// RecoveryInitiationResponse represents the response after initiating recovery
type RecoveryInitiationResponse struct {
        RecoveryID uuid.UUID `json:"recoveryId"`
        Message    string    `json:"message"`
        ExpiresAt  time.Time `json:"expiresAt"`
        NextSteps  []string  `json:"nextSteps"`
}

// RecoveryStatusResponse represents the status of a recovery request
type RecoveryStatusResponse struct {
        RecoveryID uuid.UUID        `json:"recoveryId"`
        Status     RecoveryStatus   `json:"status"`
        Priority   RecoveryPriority `json:"priority"`
        Progress   string           `json:"progress"`
        ExpiresAt  time.Time        `json:"expiresAt"`
        CreatedAt  time.Time        `json:"createdAt"`
        NextSteps  []string         `json:"nextSteps"`
}

// === Fee Transparency Entities ===

// FeeEstimate represents a fee estimate for an operation
type FeeEstimate struct {
        OperationType   string           `json:"operationType"`
        EstimatedAmount decimal.Decimal  `json:"estimatedAmount"`
        FeeBreakdown    *FeeBreakdown    `json:"feeBreakdown"`
        ExchangeRate    *decimal.Decimal `json:"exchangeRate,omitempty"`
        FinalAmount     decimal.Decimal  `json:"finalAmount"`
        Currency        string           `json:"currency"`
        ExpiresAt       time.Time        `json:"expiresAt"`
}

// FeeBreakdown represents a detailed fee breakdown
type FeeBreakdown struct {
        OperationType   string          `json:"operationType"`
        OperationAmount decimal.Decimal `json:"operationAmount"`
        BaseFee         decimal.Decimal `json:"baseFee"`
        PercentageFee   decimal.Decimal `json:"percentageFee"`
        NetworkFee      decimal.Decimal `json:"networkFee"`
        TotalFee        decimal.Decimal `json:"totalFee"`
        Currency        string          `json:"currency"`
        FeeDescription  string          `json:"feeDescription"`
        Transparent     bool            `json:"transparent"`
}

// FeeSummary represents a summary of fees for a period
type FeeSummary struct {
        UserID         string                     `json:"userId"`
        Period         string                     `json:"period"`
        StartDate      time.Time                  `json:"startDate"`
        EndDate        time.Time                  `json:"endDate"`
        TotalFeesPaid  decimal.Decimal            `json:"totalFeesPaid"`
        FeesByType     map[string]decimal.Decimal `json:"feesByType"`
        OperationCount int                        `json:"operationCount"`
        Currency       string                     `json:"currency"`
}

// FeeConfig represents fee configuration for an operation
type FeeConfig struct {
        OperationType  string          `json:"operation_type"`
        BaseFee        decimal.Decimal `json:"base_fee"`
        PercentageFee  decimal.Decimal `json:"percentage_fee"`
        MinFee         decimal.Decimal `json:"min_fee"`
        MaxFee         decimal.Decimal `json:"max_fee"`
        Currency       string          `json:"currency"`
        EffectiveFrom  time.Time       `json:"effective_from"`
        EffectiveUntil *time.Time      `json:"effective_until,omitempty"`
        IsActive       bool            `json:"is_active"`
        Description    string          `json:"description"`
}

// FeeSchedule represents the complete fee schedule
type FeeSchedule struct {
        LastUpdated time.Time             `json:"lastUpdated"`
        Fees        map[string]*FeeConfig `json:"fees"`
        Disclaimer  string                `json:"disclaimer"`
}

// === User Education Entities ===

// RiskWarning represents a risk warning for a user action
type RiskWarning struct {
        WarningType       string `json:"warningType"`
        Severity          string `json:"severity"` // low, medium, high, critical
        Title             string `json:"title"`
        Message           string `json:"message"`
        RecommendedAction string `json:"recommendedAction"`
        LearnMoreURL      string `json:"learnMoreUrl,omitempty"`
        DisplayCondition  string `json:"displayCondition,omitempty"` // when to show this warning
}

// EducationalContent represents educational content
type EducationalContent struct {
        ID                uuid.UUID `json:"id"`
        Title             string    `json:"title"`
        Content           string    `json:"content"`
        ContentType       string    `json:"contentType"` // article, video, quiz, etc.
        Difficulty        string    `json:"difficulty"`  // beginner, intermediate, advanced
        Topic             string    `json:"topic"`
        EstimatedReadTime int       `json:"estimatedReadTime"` // in minutes
        Prerequisites     []string  `json:"prerequisites,omitempty"`
        Tags              []string  `json:"tags"`
        CreatedAt         time.Time `json:"createdAt"`
        UpdatedAt         time.Time `json:"updatedAt"`
}

// UserEducationProgress represents a user's education progress
type UserEducationProgress struct {
        UserID           uuid.UUID `json:"userId" db:"user_id"`
        CompletedModules int       `json:"completedModules" db:"completed_modules"`
        TotalModules     int       `json:"totalModules" db:"total_modules"`
        CurrentStreak    int       `json:"currentStreak" db:"current_streak"`
        LongestStreak    int       `json:"longestStreak" db:"longest_streak"`
        LastActivityAt   time.Time `json:"lastActivityAt" db:"last_activity_at"`
        CreatedAt        time.Time `json:"createdAt" db:"created_at"`
        UpdatedAt        time.Time `json:"updatedAt" db:"updated_at"`

        // Calculated fields
        CompletionRate float64 `json:"completionRate"`
        Level          string  `json:"level"` // beginner, intermediate, advanced
}

// CalculateCompletionRate calculates the completion rate
func (p *UserEducationProgress) CalculateCompletionRate() <span class="cov0" title="0">{
        if p.TotalModules &gt; 0 </span><span class="cov0" title="0">{
                p.CompletionRate = float64(p.CompletedModules) / float64(p.TotalModules)
        }</span>

        // Determine level
        <span class="cov0" title="0">switch </span>{
        case p.CompletedModules &lt; 5:<span class="cov0" title="0">
                p.Level = "beginner"</span>
        case p.CompletedModules &lt; 10:<span class="cov0" title="0">
                p.Level = "intermediate"</span>
        default:<span class="cov0" title="0">
                p.Level = "advanced"</span>
        }
}

// EducationEvent represents an education-related event
type EducationEvent struct {
        UserID    uuid.UUID              `json:"userId"`
        EventType string                 `json:"eventType"`
        Details   map[string]interface{} `json:"details"`
        CreatedAt time.Time              `json:"createdAt"`
}

// EducationStats represents education system statistics
type EducationStats struct {
        TotalUsers            int       `json:"totalUsers"`
        ActiveLearners        int       `json:"activeLearners"`
        CompletedModules      int       `json:"completedModules"`
        AverageCompletionRate float64   `json:"averageCompletionRate"`
        PopularTopics         []string  `json:"popularTopics"`
        LastUpdated           time.Time `json:"lastUpdated"`
}

// AIAdvice represents AI-generated personalized advice
type AIAdvice struct {
        UserID      uuid.UUID `json:"userId"`
        AdviceType  string    `json:"adviceType"`
        Title       string    `json:"title"`
        Content     string    `json:"content"`
        Confidence  float64   `json:"confidence"`
        Suggestions []string  `json:"suggestions"`
        GeneratedAt time.Time `json:"generatedAt"`
}

// RiskAnalysis represents a user's risk analysis
type RiskAnalysis struct {
        UserID          uuid.UUID      `json:"userId"`
        RiskLevel       string         `json:"riskLevel"`   // low, medium, high
        OverallRisk     float64        `json:"overallRisk"` // 0-10 scale
        Concerns        []*RiskConcern `json:"concerns"`
        Recommendations []string       `json:"recommendations"`
        AnalyzedAt      time.Time      `json:"analyzedAt"`
}

// RiskConcern represents a specific risk concern
type RiskConcern struct {
        Type        string  `json:"type"`
        Severity    string  `json:"severity"`
        Description string  `json:"description"`
        Impact      float64 `json:"impact"` // 0-10 scale
}

// === Transaction Limits Entities ===

// TransactionLimitType represents different types of transaction limits
type TransactionLimitType string

const (
        LimitTypeDaily   TransactionLimitType = "daily"
        LimitTypeWeekly  TransactionLimitType = "weekly"
        LimitTypeMonthly TransactionLimitType = "monthly"
)

// TransactionLimits represents user transaction limits
type TransactionLimits struct {
        UserID               uuid.UUID                  `json:"userId" db:"user_id"`
        DailyLimit           decimal.Decimal            `json:"dailyLimit" db:"daily_limit"`
        WeeklyLimit          decimal.Decimal            `json:"weeklyLimit" db:"weekly_limit"`
        MonthlyLimit         decimal.Decimal            `json:"monthlyLimit" db:"monthly_limit"`
        RequireDualAuthAbove decimal.Decimal            `json:"requireDualAuthAbove" db:"require_dual_auth_above"`
        LimitsByType         map[string]decimal.Decimal `json:"limitsByType" db:"limits_by_type"`
        IsActive             bool                       `json:"isActive" db:"is_active"`
        CreatedAt            time.Time                  `json:"createdAt" db:"created_at"`
        UpdatedAt            time.Time                  `json:"updatedAt" db:"updated_at"`
}

// TransactionTracking represents transaction usage tracking
type TransactionTracking struct {
        UserID         uuid.UUID       `json:"userId" db:"user_id"`
        Date           time.Time       `json:"date" db:"date"`
        DailyTotal     decimal.Decimal `json:"dailyTotal" db:"daily_total"`
        WeeklyTotal    decimal.Decimal `json:"weeklyTotal" db:"weekly_total"`
        MonthlyTotal   decimal.Decimal `json:"monthlyTotal" db:"monthly_total"`
        LastActivityAt *time.Time      `json:"lastActivityAt" db:"last_activity_at"`
        CreatedAt      time.Time       `json:"createdAt" db:"created_at"`
        UpdatedAt      time.Time       `json:"updatedAt" db:"updated_at"`
}

// LimitCheckResult represents the result of a limit check
type LimitCheckResult struct {
        CanTransact      bool            `json:"canTransact"`
        RequireApproval  bool            `json:"requireApproval"`
        DailyRemaining   decimal.Decimal `json:"dailyRemaining"`
        WeeklyRemaining  decimal.Decimal `json:"weeklyRemaining"`
        MonthlyRemaining decimal.Decimal `json:"monthlyRemaining"`
        Violations       []string        `json:"violations,omitempty"`
}

// === API Request/Response Models ===

// UpdateLimitsRequest represents a request to update transaction limits
type UpdateLimitsRequest struct {
        DailyLimit           *string `json:"dailyLimit,omitempty"`
        WeeklyLimit          *string `json:"weeklyLimit,omitempty"`
        MonthlyLimit         *string `json:"monthlyLimit,omitempty"`
        RequireDualAuthAbove *string `json:"requireDualAuthAbove,omitempty"`
}

// LimitsResponse represents transaction limits response
type LimitsResponse struct {
        DailyLimit           string    `json:"dailyLimit"`
        WeeklyLimit          string    `json:"weeklyLimit"`
        MonthlyLimit         string    `json:"monthlyLimit"`
        RequireDualAuthAbove string    `json:"requireDualAuthAbove"`
        DailyUsed            string    `json:"dailyUsed"`
        WeeklyUsed           string    `json:"weeklyUsed"`
        MonthlyUsed          string    `json:"monthlyUsed"`
        DailyRemaining       string    `json:"dailyRemaining"`
        WeeklyRemaining      string    `json:"weeklyRemaining"`
        MonthlyRemaining     string    `json:"monthlyRemaining"`
        LastUpdated          time.Time `json:"lastUpdated"`
}

// RecoveryRequestRequest represents a recovery request
type RecoveryRequestRequest struct {
        Email  string `json:"email" validate:"required,email"`
        Reason string `json:"reason" validate:"required,min=10,max=500"`
}

// VerifyRecoveryRequest represents a recovery verification request
type VerifyRecoveryRequest struct {
        RecoveryID uuid.UUID `json:"recoveryId" validate:"required"`
        Step       string    `json:"step" validate:"required,oneof=email phone document"`
        Code       string    `json:"code" validate:"required,len=6"`
}

// FeeDisclosure represents fee disclosure for a transaction
type FeeDisclosure struct {
        TransactionType string        `json:"transactionType"`
        Amount          string        `json:"amount"`
        FeeBreakdown    *FeeBreakdown `json:"feeBreakdown"`
        TotalAmount     string        `json:"totalAmount"`
        DisclosureText  string        `json:"disclosureText"`
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package entities

import (
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
)

// FundingEventJobStatus represents the status of a funding event processing job
type FundingEventJobStatus string

const (
        JobStatusPending    FundingEventJobStatus = "pending"
        JobStatusProcessing FundingEventJobStatus = "processing"
        JobStatusCompleted  FundingEventJobStatus = "completed"
        JobStatusFailed     FundingEventJobStatus = "failed"
        JobStatusDLQ        FundingEventJobStatus = "dlq" // Dead Letter Queue
)

// FundingEventErrorType categorizes errors for retry decisions
type FundingEventErrorType string

const (
        ErrorTypeTransient  FundingEventErrorType = "transient"   // Retry-able (network, timeout, 5xx)
        ErrorTypePermanent  FundingEventErrorType = "permanent"   // Non-retry-able (validation, 4xx)
        ErrorTypeUnknown    FundingEventErrorType = "unknown"     // Default, treat as transient
        ErrorTypeRPCFailure FundingEventErrorType = "rpc_failure" // RPC/chain query failed
)

// FundingEventJob represents a queued webhook event for processing
type FundingEventJob struct {
        ID           uuid.UUID             `json:"id" db:"id"`
        TxHash       string                `json:"tx_hash" db:"tx_hash"`
        Chain        Chain                 `json:"chain" db:"chain"`
        Token        Stablecoin            `json:"token" db:"token"`
        Amount       decimal.Decimal       `json:"amount" db:"amount"`
        ToAddress    string                `json:"to_address" db:"to_address"`
        Status       FundingEventJobStatus `json:"status" db:"status"`
        AttemptCount int                   `json:"attempt_count" db:"attempt_count"`
        MaxAttempts  int                   `json:"max_attempts" db:"max_attempts"`

        // Error tracking
        LastError     *string                `json:"last_error,omitempty" db:"last_error"`
        ErrorType     *FundingEventErrorType `json:"error_type,omitempty" db:"error_type"`
        FailureReason *string                `json:"failure_reason,omitempty" db:"failure_reason"`

        // Timing
        FirstSeenAt   time.Time  `json:"first_seen_at" db:"first_seen_at"`
        LastAttemptAt *time.Time `json:"last_attempt_at,omitempty" db:"last_attempt_at"`
        NextRetryAt   *time.Time `json:"next_retry_at,omitempty" db:"next_retry_at"`
        CompletedAt   *time.Time `json:"completed_at,omitempty" db:"completed_at"`
        MovedToDLQAt  *time.Time `json:"moved_to_dlq_at,omitempty" db:"moved_to_dlq_at"`

        // Metadata
        WebhookPayload map[string]interface{} `json:"webhook_payload,omitempty" db:"webhook_payload"`
        ProcessingLogs []ProcessingLogEntry   `json:"processing_logs,omitempty" db:"processing_logs"`
        CreatedAt      time.Time              `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time              `json:"updated_at" db:"updated_at"`
}

// ProcessingLogEntry tracks individual processing attempts
type ProcessingLogEntry struct {
        Timestamp  time.Time              `json:"timestamp"`
        Attempt    int                    `json:"attempt"`
        Status     string                 `json:"status"`
        Error      *string                `json:"error,omitempty"`
        ErrorType  *FundingEventErrorType `json:"error_type,omitempty"`
        DurationMs int64                  `json:"duration_ms"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// CanRetry checks if the job is eligible for retry
func (j *FundingEventJob) CanRetry() bool <span class="cov0" title="0">{
        return j.Status == JobStatusFailed &amp;&amp;
                j.AttemptCount &lt; j.MaxAttempts &amp;&amp;
                j.ErrorType != nil &amp;&amp;
                *j.ErrorType != ErrorTypePermanent
}</span>

// ShouldMoveToDLQ checks if job should be moved to DLQ
func (j *FundingEventJob) ShouldMoveToDLQ() bool <span class="cov0" title="0">{
        return (j.Status == JobStatusFailed &amp;&amp; j.AttemptCount &gt;= j.MaxAttempts) ||
                (j.ErrorType != nil &amp;&amp; *j.ErrorType == ErrorTypePermanent)
}</span>

// MarkProcessing marks the job as currently being processed
func (j *FundingEventJob) MarkProcessing() <span class="cov0" title="0">{
        now := time.Now()
        j.Status = JobStatusProcessing
        j.AttemptCount++
        j.LastAttemptAt = &amp;now
        j.UpdatedAt = now
}</span>

// MarkCompleted marks the job as successfully completed
func (j *FundingEventJob) MarkCompleted() <span class="cov0" title="0">{
        now := time.Now()
        j.Status = JobStatusCompleted
        j.CompletedAt = &amp;now
        j.NextRetryAt = nil
        j.UpdatedAt = now
}</span>

// MarkFailed marks the job as failed and calculates next retry time
func (j *FundingEventJob) MarkFailed(err error, errorType FundingEventErrorType, nextRetryDelay time.Duration) <span class="cov0" title="0">{
        now := time.Now()
        errMsg := err.Error()

        j.Status = JobStatusFailed
        j.LastError = &amp;errMsg
        j.ErrorType = &amp;errorType
        j.UpdatedAt = now

        // Calculate next retry time if eligible
        if j.CanRetry() &amp;&amp; errorType != ErrorTypePermanent </span><span class="cov0" title="0">{
                nextRetry := now.Add(nextRetryDelay)
                j.NextRetryAt = &amp;nextRetry
        }</span> else<span class="cov0" title="0"> if j.ShouldMoveToDLQ() </span><span class="cov0" title="0">{
                // Mark for DLQ
                j.Status = JobStatusDLQ
                j.MovedToDLQAt = &amp;now
                j.NextRetryAt = nil

                // Generate failure reason
                reason := fmt.Sprintf("Exhausted %d attempts or permanent error: %s", j.AttemptCount, errMsg)
                j.FailureReason = &amp;reason
        }</span>
}

// AddProcessingLog adds a log entry for the current attempt
func (j *FundingEventJob) AddProcessingLog(entry ProcessingLogEntry) <span class="cov0" title="0">{
        if j.ProcessingLogs == nil </span><span class="cov0" title="0">{
                j.ProcessingLogs = make([]ProcessingLogEntry, 0)
        }</span>
        <span class="cov0" title="0">j.ProcessingLogs = append(j.ProcessingLogs, entry)</span>
}

// GetRetryDelay calculates exponential backoff with jitter
func (j *FundingEventJob) GetRetryDelay() time.Duration <span class="cov0" title="0">{
        // Exponential backoff: base * 2^attempt
        baseDelay := 2 * time.Second
        maxDelay := 30 * time.Minute

        // Calculate exponential delay
        attempt := j.AttemptCount
        if attempt &gt; 10 </span><span class="cov0" title="0">{
                attempt = 10 // Cap to prevent overflow
        }</span>

        <span class="cov0" title="0">delay := baseDelay * (1 &lt;&lt; uint(attempt)) // 2^attempt

        if delay &gt; maxDelay </span><span class="cov0" title="0">{
                delay = maxDelay
        }</span>

        // Add jitter (Â±20%)
        <span class="cov0" title="0">jitter := time.Duration(float64(delay) * 0.2 * (2.0*randomFloat() - 1.0))
        delay += jitter

        if delay &lt; 0 </span><span class="cov0" title="0">{
                delay = baseDelay
        }</span>

        <span class="cov0" title="0">return delay</span>
}

// Simple random float for jitter (0.0 to 1.0)
func randomFloat() float64 <span class="cov0" title="0">{
        // Simple pseudo-random based on time
        return float64(time.Now().UnixNano()%1000) / 1000.0
}</span>

// Validate validates the funding event job
func (j *FundingEventJob) Validate() error <span class="cov0" title="0">{
        if j.TxHash == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("tx_hash is required")
        }</span>

        <span class="cov0" title="0">if j.Chain == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("chain is required")
        }</span>

        <span class="cov0" title="0">if j.Token == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("token is required")
        }</span>

        <span class="cov0" title="0">if j.Amount.IsZero() || j.Amount.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("amount must be positive")
        }</span>

        <span class="cov0" title="0">if j.ToAddress == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("to_address is required")
        }</span>

        <span class="cov0" title="0">if j.MaxAttempts &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_attempts must be positive")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReconciliationCandidate represents a deposit pending reconciliation
type ReconciliationCandidate struct {
        DepositID       uuid.UUID       `json:"deposit_id" db:"deposit_id"`
        UserID          uuid.UUID       `json:"user_id" db:"user_id"`
        TxHash          string          `json:"tx_hash" db:"tx_hash"`
        Chain           Chain           `json:"chain" db:"chain"`
        Token           Stablecoin      `json:"token" db:"token"`
        Amount          decimal.Decimal `json:"amount" db:"amount"`
        ToAddress       string          `json:"to_address" db:"to_address"`
        Status          string          `json:"status" db:"status"`
        CreatedAt       time.Time       `json:"created_at" db:"created_at"`
        PendingDuration time.Duration   `json:"pending_duration"`
}

// ShouldReconcile determines if a deposit should be reconciled
func (c *ReconciliationCandidate) ShouldReconcile(threshold time.Duration) bool <span class="cov0" title="0">{
        return c.Status == "pending" &amp;&amp; c.PendingDuration &gt; threshold
}</span>

// WebhookMetrics tracks webhook processing metrics
type WebhookMetrics struct {
        TotalReceived      int64         `json:"total_received"`
        TotalProcessed     int64         `json:"total_processed"`
        TotalFailed        int64         `json:"total_failed"`
        TotalDLQ           int64         `json:"total_dlq"`
        SuccessRate        float64       `json:"success_rate"`
        AverageLatency     time.Duration `json:"average_latency"`
        AverageRetryCount  float64       `json:"average_retry_count"`
        DLQDepth           int64         `json:"dlq_depth"`
        PendingCount       int64         `json:"pending_count"`
        ReconciliationRuns int64         `json:"reconciliation_runs"`
        RecoveredDeposits  int64         `json:"recovered_deposits"`
}

// CalculateSuccessRate calculates the success rate
func (m *WebhookMetrics) CalculateSuccessRate() <span class="cov0" title="0">{
        if m.TotalReceived &gt; 0 </span><span class="cov0" title="0">{
                m.SuccessRate = float64(m.TotalProcessed) / float64(m.TotalReceived) * 100.0
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package entities

import (
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
)

// OnboardingStatus represents the overall onboarding status
type OnboardingStatus string

const (
        OnboardingStatusStarted        OnboardingStatus = "started"
        OnboardingStatusKYCPending     OnboardingStatus = "kyc_pending"
        OnboardingStatusKYCApproved    OnboardingStatus = "kyc_approved"
        OnboardingStatusKYCRejected    OnboardingStatus = "kyc_rejected"
        OnboardingStatusWalletsPending OnboardingStatus = "wallets_pending"
        OnboardingStatusCompleted      OnboardingStatus = "completed"
)

// IsValid checks if the onboarding status is valid
func (s OnboardingStatus) IsValid() bool <span class="cov0" title="0">{
        switch s </span>{
        case OnboardingStatusStarted, OnboardingStatusKYCPending, OnboardingStatusKYCApproved,
                OnboardingStatusKYCRejected, OnboardingStatusWalletsPending, OnboardingStatusCompleted:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// CanTransitionTo checks if transition to target status is allowed
func (s OnboardingStatus) CanTransitionTo(target OnboardingStatus) bool <span class="cov0" title="0">{
        transitions := map[OnboardingStatus][]OnboardingStatus{
                OnboardingStatusStarted:        {OnboardingStatusWalletsPending, OnboardingStatusKYCPending},
                OnboardingStatusKYCPending:     {OnboardingStatusKYCApproved, OnboardingStatusKYCRejected, OnboardingStatusWalletsPending},
                OnboardingStatusKYCApproved:    {OnboardingStatusWalletsPending},
                OnboardingStatusKYCRejected:    {OnboardingStatusKYCPending, OnboardingStatusWalletsPending}, // Allow retry or continue without KYC
                OnboardingStatusWalletsPending: {OnboardingStatusCompleted},
                OnboardingStatusCompleted:      {}, // Terminal state
        }

        allowedTargets, exists := transitions[s]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, allowed := range allowedTargets </span><span class="cov0" title="0">{
                if allowed == target </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// KYCStatus represents KYC verification status
type KYCStatus string

const (
        KYCStatusPending    KYCStatus = "pending"
        KYCStatusProcessing KYCStatus = "processing"
        KYCStatusApproved   KYCStatus = "approved"
        KYCStatusRejected   KYCStatus = "rejected"
        KYCStatusExpired    KYCStatus = "expired"
)

// IsValid checks if KYC status is valid
func (s KYCStatus) IsValid() bool <span class="cov0" title="0">{
        switch s </span>{
        case KYCStatusPending, KYCStatusProcessing, KYCStatusApproved, KYCStatusRejected, KYCStatusExpired:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// OnboardingStepType represents different steps in the onboarding flow
type OnboardingStepType string

const (
        StepRegistration       OnboardingStepType = "registration"
        StepEmailVerification  OnboardingStepType = "email_verification"
        StepPhoneVerification  OnboardingStepType = "phone_verification"
        StepPasscodeCreation   OnboardingStepType = "passcode_creation"
        StepKYCSubmission      OnboardingStepType = "kyc_submission"
        StepKYCReview          OnboardingStepType = "kyc_review"
        StepWalletCreation     OnboardingStepType = "wallet_creation"
        StepOnboardingComplete OnboardingStepType = "completed"
)

// StepStatus represents the status of an individual onboarding step
type StepStatus string

const (
        StepStatusPending    StepStatus = "pending"
        StepStatusInProgress StepStatus = "in_progress"
        StepStatusCompleted  StepStatus = "completed"
        StepStatusFailed     StepStatus = "failed"
        StepStatusSkipped    StepStatus = "skipped"
)

// UserProfile represents enhanced user information for onboarding
type UserProfile struct {
        ID                 uuid.UUID        `json:"id" db:"id"`
        AuthProviderID     *string          `json:"auth_provider_id" db:"auth_provider_id"`
        Email              string           `json:"email" db:"email" validate:"required,email"`
        FirstName          *string          `json:"first_name" db:"first_name"`
        LastName           *string          `json:"last_name" db:"last_name"`
        DateOfBirth        *time.Time       `json:"date_of_birth" db:"date_of_birth"`
        Phone              *string          `json:"phone" db:"phone" validate:"omitempty,e164"`
        PhoneVerified      bool             `json:"phone_verified" db:"phone_verified"`
        EmailVerified      bool             `json:"email_verified" db:"email_verified"`
        OnboardingStatus   OnboardingStatus `json:"onboarding_status" db:"onboarding_status"`
        KYCStatus          string           `json:"kyc_status" db:"kyc_status"`
        KYCProviderRef     *string          `json:"kyc_provider_ref" db:"kyc_provider_ref"`
        KYCSubmittedAt     *time.Time       `json:"kyc_submitted_at" db:"kyc_submitted_at"`
        KYCApprovedAt      *time.Time       `json:"kyc_approved_at" db:"kyc_approved_at"`
        KYCRejectionReason *string          `json:"kyc_rejection_reason" db:"kyc_rejection_reason"`
        IsActive           bool             `json:"is_active" db:"is_active"`
        CreatedAt          time.Time        `json:"created_at" db:"created_at"`
        UpdatedAt          time.Time        `json:"updated_at" db:"updated_at"`
}

// Validate performs business rule validation on user profile
func (u *UserProfile) Validate() error <span class="cov0" title="0">{
        if u.Email == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("email is required")
        }</span>

        <span class="cov0" title="0">if !strings.Contains(u.Email, "@") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid email format")
        }</span>

        // Validate names if provided
        <span class="cov0" title="0">if u.FirstName != nil &amp;&amp; *u.FirstName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("first name cannot be empty if provided")
        }</span>

        <span class="cov0" title="0">if u.LastName != nil &amp;&amp; *u.LastName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("last name cannot be empty if provided")
        }</span>

        // Validate date of birth if provided
        <span class="cov0" title="0">if u.DateOfBirth != nil </span><span class="cov0" title="0">{
                // Must be at least 18 years old
                eighteenYearsAgo := time.Now().AddDate(-18, 0, 0)
                if u.DateOfBirth.After(eighteenYearsAgo) </span><span class="cov0" title="0">{
                        return fmt.Errorf("user must be at least 18 years old")
                }</span>

                // Cannot be more than 120 years ago
                <span class="cov0" title="0">oneHundredTwentyYearsAgo := time.Now().AddDate(-120, 0, 0)
                if u.DateOfBirth.Before(oneHundredTwentyYearsAgo) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid date of birth: too far in the past")
                }</span>
        }

        <span class="cov0" title="0">if !u.OnboardingStatus.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid onboarding status: %s", u.OnboardingStatus)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CanStartKYC checks if user can start KYC process
func (u *UserProfile) CanStartKYC() bool <span class="cov0" title="0">{
        if !u.EmailVerified </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">switch u.OnboardingStatus </span>{
        case OnboardingStatusStarted, OnboardingStatusKYCRejected, OnboardingStatusWalletsPending, OnboardingStatusCompleted:<span class="cov0" title="0">
                return true</span>
        case OnboardingStatusKYCPending:<span class="cov0" title="0">
                // Allow initial submission when we're in the pending state but nothing was sent yet
                return u.KYCSubmittedAt == nil</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// CanCreateWallets checks if user can proceed to wallet creation
func (u *UserProfile) CanCreateWallets() bool <span class="cov0" title="0">{
        if !u.EmailVerified </span><span class="cov0" title="0">{
                return false
        }</span>

        // Wallet provisioning is allowed once identity basics are verified, even if KYC is optional
        <span class="cov0" title="0">switch u.OnboardingStatus </span>{
        case OnboardingStatusWalletsPending, OnboardingStatusCompleted:<span class="cov0" title="0">
                return true</span>
        case OnboardingStatusStarted, OnboardingStatusKYCPending, OnboardingStatusKYCApproved, OnboardingStatusKYCRejected:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetFullName returns the user's full name if available
func (u *UserProfile) GetFullName() string <span class="cov0" title="0">{
        if u.FirstName != nil &amp;&amp; u.LastName != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s %s", *u.FirstName, *u.LastName)
        }</span>
        <span class="cov0" title="0">if u.FirstName != nil </span><span class="cov0" title="0">{
                return *u.FirstName
        }</span>
        <span class="cov0" title="0">if u.LastName != nil </span><span class="cov0" title="0">{
                return *u.LastName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// HasPersonalInfo checks if user has provided personal information
func (u *UserProfile) HasPersonalInfo() bool <span class="cov0" title="0">{
        return u.FirstName != nil &amp;&amp; u.LastName != nil &amp;&amp; u.DateOfBirth != nil
}</span>

// GetAge calculates user's age if date of birth is provided
func (u *UserProfile) GetAge() *int <span class="cov0" title="0">{
        if u.DateOfBirth == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">now := time.Now()
        age := now.Year() - u.DateOfBirth.Year()
        if now.YearDay() &lt; u.DateOfBirth.YearDay() </span><span class="cov0" title="0">{
                age--
        }</span>
        <span class="cov0" title="0">return &amp;age</span>
}

// OnboardingFlow represents a step in the onboarding process
type OnboardingFlow struct {
        ID           uuid.UUID          `json:"id" db:"id"`
        UserID       uuid.UUID          `json:"user_id" db:"user_id"`
        Step         OnboardingStepType `json:"step" db:"step"`
        Status       StepStatus         `json:"status" db:"status"`
        Data         map[string]any     `json:"data" db:"data"` // JSON data specific to the step
        ErrorMessage *string            `json:"error_message" db:"error_message"`
        StartedAt    *time.Time         `json:"started_at" db:"started_at"`
        CompletedAt  *time.Time         `json:"completed_at" db:"completed_at"`
        CreatedAt    time.Time          `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time          `json:"updated_at" db:"updated_at"`
}

// MarkStarted marks the step as started
func (o *OnboardingFlow) MarkStarted() <span class="cov0" title="0">{
        now := time.Now()
        o.Status = StepStatusInProgress
        o.StartedAt = &amp;now
        o.UpdatedAt = now
}</span>

// MarkCompleted marks the step as completed
func (o *OnboardingFlow) MarkCompleted(data map[string]any) <span class="cov0" title="0">{
        now := time.Now()
        o.Status = StepStatusCompleted
        o.CompletedAt = &amp;now
        if data != nil </span><span class="cov0" title="0">{
                o.Data = data
        }</span>
        <span class="cov0" title="0">o.UpdatedAt = now</span>
}

// MarkFailed marks the step as failed
func (o *OnboardingFlow) MarkFailed(errorMsg string) <span class="cov0" title="0">{
        now := time.Now()
        o.Status = StepStatusFailed
        o.ErrorMessage = &amp;errorMsg
        o.UpdatedAt = now
}</span>

// KYCSubmission represents a KYC submission
type KYCSubmission struct {
        ID               uuid.UUID      `json:"id" db:"id"`
        UserID           uuid.UUID      `json:"user_id" db:"user_id"`
        Provider         string         `json:"provider" db:"provider"`
        ProviderRef      string         `json:"provider_ref" db:"provider_ref"`
        SubmissionType   string         `json:"submission_type" db:"submission_type"`
        Status           KYCStatus      `json:"status" db:"status"`
        VerificationData map[string]any `json:"verification_data" db:"verification_data"`
        RejectionReasons []string       `json:"rejection_reasons" db:"rejection_reasons"`
        SubmittedAt      time.Time      `json:"submitted_at" db:"submitted_at"`
        ReviewedAt       *time.Time     `json:"reviewed_at" db:"reviewed_at"`
        ExpiresAt        *time.Time     `json:"expires_at" db:"expires_at"`
        CreatedAt        time.Time      `json:"created_at" db:"created_at"`
        UpdatedAt        time.Time      `json:"updated_at" db:"updated_at"`
}

// IsExpired checks if the KYC submission has expired
func (k *KYCSubmission) IsExpired() bool <span class="cov0" title="0">{
        return k.ExpiresAt != nil &amp;&amp; time.Now().After(*k.ExpiresAt)
}</span>

// CanRetry checks if the KYC submission can be retried
func (k *KYCSubmission) CanRetry() bool <span class="cov0" title="0">{
        return k.Status == KYCStatusRejected || k.Status == KYCStatusExpired
}</span>

// MarkReviewed marks the KYC as reviewed with a status
func (k *KYCSubmission) MarkReviewed(status KYCStatus, rejectionReasons []string) <span class="cov0" title="0">{
        now := time.Now()
        k.Status = status
        k.ReviewedAt = &amp;now
        k.UpdatedAt = now

        if status == KYCStatusRejected &amp;&amp; len(rejectionReasons) &gt; 0 </span><span class="cov0" title="0">{
                k.RejectionReasons = rejectionReasons
        }</span>
}

// === API Request/Response Models ===

// OnboardingStartRequest represents the request to start onboarding
type OnboardingStartRequest struct {
        Email string  `json:"email" validate:"required,email"`
        Phone *string `json:"phone,omitempty" validate:"omitempty,e164"`
}

// OnboardingStartResponse represents the response after starting onboarding
type OnboardingStartResponse struct {
        UserID           uuid.UUID          `json:"userId"`
        OnboardingStatus OnboardingStatus   `json:"onboardingStatus"`
        NextStep         OnboardingStepType `json:"nextStep"`
        SessionToken     string             `json:"sessionToken,omitempty"`
}

// OnboardingStatusResponse represents the current onboarding status
type OnboardingStatusResponse struct {
        UserID           uuid.UUID            `json:"userId"`
        OnboardingStatus OnboardingStatus     `json:"onboardingStatus"`
        KYCStatus        string               `json:"kycStatus"`
        CurrentStep      *OnboardingStepType  `json:"currentStep,omitempty"`
        CompletedSteps   []OnboardingStepType `json:"completedSteps"`
        WalletStatus     *WalletStatusSummary `json:"walletStatus,omitempty"`
        CanProceed       bool                 `json:"canProceed"`
        RequiredActions  []string             `json:"requiredActions,omitempty"`
}

// WalletStatusSummary provides a summary of wallet provisioning status
type WalletStatusSummary struct {
        TotalWallets    int               `json:"totalWallets"`
        CreatedWallets  int               `json:"createdWallets"`
        PendingWallets  int               `json:"pendingWallets"`
        FailedWallets   int               `json:"failedWallets"`
        SupportedChains []string          `json:"supportedChains"`
        WalletsByChain  map[string]string `json:"walletsByChain"` // chain -&gt; status
}

// KYCStatusResponse captures a user's verification state with contextual guidance
type KYCStatusResponse struct {
        UserID            uuid.UUID  `json:"userId"`
        Status            string     `json:"status"`
        Verified          bool       `json:"verified"`
        HasSubmitted      bool       `json:"hasSubmitted"`
        RequiresKYC       bool       `json:"requiresKyc"`
        RequiredFor       []string   `json:"requiredFor"`
        LastSubmittedAt   *time.Time `json:"lastSubmittedAt,omitempty"`
        ApprovedAt        *time.Time `json:"approvedAt,omitempty"`
        RejectionReason   *string    `json:"rejectionReason,omitempty"`
        ProviderReference *string    `json:"providerReference,omitempty"`
        NextSteps         []string   `json:"nextSteps,omitempty"`
}

// KYCSubmitRequest represents KYC submission request
type KYCSubmitRequest struct {
        DocumentType string                 `json:"documentType" validate:"required"`
        Documents    []KYCDocument          `json:"documents" validate:"required,min=1"`
        PersonalInfo *KYCPersonalInfo       `json:"personalInfo,omitempty"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// KYCDocument represents a document uploaded for KYC
type KYCDocument struct {
        Type        string `json:"type" validate:"required"` // passport, drivers_license, etc.
        FileURL     string `json:"fileUrl" validate:"required,url"`
        ContentType string `json:"contentType" validate:"required"`
}

// KYCPersonalInfo represents personal information for KYC
type KYCPersonalInfo struct {
        FirstName   string     `json:"firstName" validate:"required"`
        LastName    string     `json:"lastName" validate:"required"`
        DateOfBirth *time.Time `json:"dateOfBirth,omitempty"`
        Country     string     `json:"country" validate:"required,len=2"`
        Address     *Address   `json:"address,omitempty"`
}

// Address represents a physical address
type Address struct {
        Street     string `json:"street" validate:"required"`
        City       string `json:"city" validate:"required"`
        State      string `json:"state,omitempty"`
        PostalCode string `json:"postalCode" validate:"required"`
        Country    string `json:"country" validate:"required,len=2"`
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package entities

import (
        "fmt"
        "time"

        "github.com/google/uuid"
)

// OnboardingJobStatus represents the status of an onboarding job
type OnboardingJobStatus string

const (
        OnboardingJobStatusQueued     OnboardingJobStatus = "queued"
        OnboardingJobStatusInProgress OnboardingJobStatus = "in_progress"
        OnboardingJobStatusCompleted  OnboardingJobStatus = "completed"
        OnboardingJobStatusFailed     OnboardingJobStatus = "failed"
        OnboardingJobStatusRetry      OnboardingJobStatus = "retry"
)

// OnboardingJobType represents the type of onboarding job
type OnboardingJobType string

const (
        OnboardingJobTypeFullOnboarding OnboardingJobType = "full_onboarding"
        OnboardingJobTypeKYCOnly        OnboardingJobType = "kyc_only"
        OnboardingJobTypeWalletOnly     OnboardingJobType = "wallet_only"
)

// OnboardingJob represents an async onboarding job
type OnboardingJob struct {
        ID           uuid.UUID              `json:"id" db:"id"`
        UserID       uuid.UUID              `json:"userId" db:"user_id"`
        Status       OnboardingJobStatus    `json:"status" db:"status"`
        JobType      OnboardingJobType      `json:"jobType" db:"job_type"`
        Payload      map[string]interface{} `json:"payload" db:"payload"`
        AttemptCount int                    `json:"attemptCount" db:"attempt_count"`
        MaxAttempts  int                    `json:"maxAttempts" db:"max_attempts"`
        NextRetryAt  *time.Time             `json:"nextRetryAt" db:"next_retry_at"`
        ErrorMessage *string                `json:"errorMessage" db:"error_message"`
        StartedAt    *time.Time             `json:"startedAt" db:"started_at"`
        CompletedAt  *time.Time             `json:"completedAt" db:"completed_at"`
        CreatedAt    time.Time              `json:"createdAt" db:"created_at"`
        UpdatedAt    time.Time              `json:"updated_at" db:"updated_at"`
}

// MarkStarted marks the job as started
func (j *OnboardingJob) MarkStarted() <span class="cov0" title="0">{
        now := time.Now()
        j.Status = OnboardingJobStatusInProgress
        j.StartedAt = &amp;now
        j.AttemptCount++
        j.UpdatedAt = now
}</span>

// MarkCompleted marks the job as completed
func (j *OnboardingJob) MarkCompleted() <span class="cov0" title="0">{
        now := time.Now()
        j.Status = OnboardingJobStatusCompleted
        j.CompletedAt = &amp;now
        j.NextRetryAt = nil
        j.ErrorMessage = nil
        j.UpdatedAt = now
}</span>

// MarkFailed marks the job as failed with retry logic
func (j *OnboardingJob) MarkFailed(errorMsg string, retryDelay time.Duration) <span class="cov0" title="0">{
        now := time.Now()
        j.ErrorMessage = &amp;errorMsg
        j.UpdatedAt = now

        if j.AttemptCount &lt; j.MaxAttempts &amp;&amp; retryDelay &gt; 0 </span><span class="cov0" title="0">{
                j.Status = OnboardingJobStatusRetry
                retryTime := now.Add(retryDelay)
                j.NextRetryAt = &amp;retryTime
        }</span> else<span class="cov0" title="0"> {
                j.Status = OnboardingJobStatusFailed
                j.NextRetryAt = nil
        }</span>
}

// IsRetryable checks if the job can be retried
func (j *OnboardingJob) IsRetryable() bool <span class="cov0" title="0">{
        return j.Status == OnboardingJobStatusRetry &amp;&amp;
                j.NextRetryAt != nil &amp;&amp;
                time.Now().After(*j.NextRetryAt) &amp;&amp;
                j.AttemptCount &lt; j.MaxAttempts
}</span>

// IsEligibleForProcessing checks if the job is eligible for processing
func (j *OnboardingJob) IsEligibleForProcessing() bool <span class="cov0" title="0">{
        return j.Status == OnboardingJobStatusQueued || j.IsRetryable()
}</span>

// Validate validates the onboarding job
func (j *OnboardingJob) Validate() error <span class="cov0" title="0">{
        if j.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user ID is required")
        }</span>

        <span class="cov0" title="0">if j.JobType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("job type is required")
        }</span>

        <span class="cov0" title="0">if j.MaxAttempts &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max attempts must be greater than 0")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OnboardingJobPayload represents the payload for different job types
type OnboardingJobPayload struct {
        UserEmail    string                 `json:"user_email,omitempty"`
        UserPhone    string                 `json:"user_phone,omitempty"`
        KYCData      map[string]interface{} `json:"kyc_data,omitempty"`
        WalletChains []string               `json:"wallet_chains,omitempty"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package entities

import (
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
)

// TransferStatus represents the status of a transfer operation
type TransferStatus string

const (
        TransferStatusInitiated    TransferStatus = "initiated"
        TransferStatusDepositing   TransferStatus = "depositing"   // USDC being sent to Circle wallet
        TransferStatusDeposited    TransferStatus = "deposited"    // USDC confirmed in Circle wallet
        TransferStatusOffRamping   TransferStatus = "off_ramping"  // Converting USDC to fiat
        TransferStatusOffRamped    TransferStatus = "off_ramped"   // Fiat received from Circle
        TransferStatusTransferring TransferStatus = "transferring" // Moving fiat to Alpaca
        TransferStatusCompleted    TransferStatus = "completed"    // Funds available in Alpaca
        TransferStatusFailed       TransferStatus = "failed"
        TransferStatusCancelled    TransferStatus = "cancelled"
)

// TransferType represents the type of transfer
type TransferType string

const (
        TransferTypeUSDCToFiat TransferType = "usdc_to_fiat" // USDC deposit to fiat
        TransferTypeFiatToUSD  TransferType = "fiat_to_usd"  // Fiat to Alpaca USD
)

// Transfer represents a complete transfer operation from USDC deposit to Alpaca funding
type Transfer struct {
        ID     uuid.UUID      `json:"id" db:"id"`
        UserID uuid.UUID      `json:"user_id" db:"user_id"`
        Type   TransferType   `json:"type" db:"type"`
        Status TransferStatus `json:"status" db:"status"`

        // Source details (USDC deposit)
        SourceChain    Chain           `json:"source_chain" db:"source_chain"`
        SourceTxHash   *string         `json:"source_tx_hash" db:"source_tx_hash"`
        SourceWalletID *string         `json:"source_wallet_id" db:"source_wallet_id"` // Circle wallet ID
        SourceAmount   decimal.Decimal `json:"source_amount" db:"source_amount"`
        SourceToken    Stablecoin      `json:"source_token" db:"source_token"`

        // Destination details (Alpaca funding)
        DestAccountID *string          `json:"dest_account_id" db:"dest_account_id"` // Alpaca account ID
        DestAmount    *decimal.Decimal `json:"dest_amount" db:"dest_amount"`
        DestCurrency  string           `json:"dest_currency" db:"dest_currency"` // USD

        // Processing details
        IdempotencyKey string           `json:"idempotency_key" db:"idempotency_key"`
        ExchangeRate   *decimal.Decimal `json:"exchange_rate" db:"exchange_rate"` // USDC to USD rate
        Fees           *decimal.Decimal `json:"fees" db:"fees"`                   // Total fees incurred

        // Circle-specific fields
        CircleTransferID *string `json:"circle_transfer_id" db:"circle_transfer_id"`
        CirclePayoutID   *string `json:"circle_payout_id" db:"circle_payout_id"`

        // Alpaca-specific fields
        AlpacaTransferID *string `json:"alpaca_transfer_id" db:"alpaca_transfer_id"`

        // Error handling
        ErrorMessage *string `json:"error_message" db:"error_message"`
        ErrorType    *string `json:"error_type" db:"error_type"`

        // Timing
        InitiatedAt time.Time  `json:"initiated_at" db:"initiated_at"`
        DepositedAt *time.Time `json:"deposited_at" db:"deposited_at"`
        OffRampedAt *time.Time `json:"off_ramped_at" db:"off_ramped_at"`
        CompletedAt *time.Time `json:"completed_at" db:"completed_at"`
        UpdatedAt   time.Time  `json:"updated_at" db:"updated_at"`

        // Metadata
        WebhookPayload map[string]interface{}       `json:"webhook_payload,omitempty" db:"webhook_payload"`
        ProcessingLogs []TransferProcessingLogEntry `json:"processing_logs,omitempty" db:"processing_logs"`
}

// ProcessingLogEntry tracks individual processing steps
type TransferProcessingLogEntry struct {
        Timestamp  time.Time              `json:"timestamp"`
        Step       string                 `json:"step"`
        Status     string                 `json:"status"`
        Error      *string                `json:"error,omitempty"`
        ErrorType  *string                `json:"error_type,omitempty"`
        DurationMs int64                  `json:"duration_ms"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// Validate validates the transfer entity
func (t *Transfer) Validate() error <span class="cov0" title="0">{
        if t.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user_id is required")
        }</span>

        <span class="cov0" title="0">if t.SourceAmount.IsZero() || t.SourceAmount.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("source_amount must be positive")
        }</span>

        <span class="cov0" title="0">if t.SourceToken != StablecoinUSDC </span><span class="cov0" title="0">{
                return fmt.Errorf("only USDC transfers are currently supported")
        }</span>

        <span class="cov0" title="0">if t.IdempotencyKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("idempotency_key is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsComplete checks if the transfer is in a terminal state
func (t *Transfer) IsComplete() bool <span class="cov0" title="0">{
        return t.Status == TransferStatusCompleted ||
                t.Status == TransferStatusFailed ||
                t.Status == TransferStatusCancelled
}</span>

// CanRetry checks if the transfer can be retried
func (t *Transfer) CanRetry() bool <span class="cov0" title="0">{
        return t.Status == TransferStatusFailed &amp;&amp;
                t.ErrorType != nil &amp;&amp;
                *t.ErrorType != "permanent_failure"
}</span>

// AddProcessingLog adds a log entry for tracking
func (t *Transfer) AddProcessingLog(entry TransferProcessingLogEntry) <span class="cov0" title="0">{
        if t.ProcessingLogs == nil </span><span class="cov0" title="0">{
                t.ProcessingLogs = make([]TransferProcessingLogEntry, 0)
        }</span>
        <span class="cov0" title="0">t.ProcessingLogs = append(t.ProcessingLogs, entry)</span>
}

// UpdateStatus updates the transfer status with timestamps
func (t *Transfer) UpdateStatus(newStatus TransferStatus) <span class="cov0" title="0">{
        t.Status = newStatus
        t.UpdatedAt = time.Now()

        switch newStatus </span>{
        case TransferStatusDeposited:<span class="cov0" title="0">
                now := time.Now()
                t.DepositedAt = &amp;now</span>
        case TransferStatusOffRamped:<span class="cov0" title="0">
                now := time.Now()
                t.OffRampedAt = &amp;now</span>
        case TransferStatusCompleted:<span class="cov0" title="0">
                now := time.Now()
                t.CompletedAt = &amp;now</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package entities

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
)

// WalletChain represents supported blockchain networks for Circle integration
type WalletChain string

const (
        // Ethereum chains
        ChainETH        WalletChain = "ETH"
        ChainETHSepolia WalletChain = "ETH-SEPOLIA"

        // Polygon chains
        ChainMATIC     WalletChain = "MATIC"
        ChainMATICAmoy WalletChain = "MATIC-AMOY"

        // Solana chains
        ChainSOL       WalletChain = "SOL"
        ChainSOLDevnet WalletChain = "SOL-DEVNET"

        // Aptos chains
        WalletChainAptos        WalletChain = "APTOS"
        WalletChainAptosTestnet WalletChain = "APTOS-TESTNET"

        // Avalanche chains
        ChainAVAX WalletChain = "AVAX"

        // Base chains
        ChainBASE        WalletChain = "BASE"
        ChainBASESepolia WalletChain = "BASE-SEPOLIA"

        // USDC Token Addresses by Chain
        // SOL-DEVNET USDC token address
        USDCTokenAddressSOLDevnet = "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
)

// GetMainnetChains returns production chains
func GetMainnetChains() []WalletChain <span class="cov0" title="0">{
        return []WalletChain{
                ChainETH,
                ChainMATIC,
                ChainSOL,
                WalletChainAptos,
                ChainAVAX,
                ChainBASE,
        }
}</span>

// GetTestnetChains returns testnet chains
func GetTestnetChains() []WalletChain <span class="cov0" title="0">{
        return []WalletChain{
                ChainETHSepolia,
                ChainMATICAmoy,
                ChainSOLDevnet,
                WalletChainAptosTestnet,
                ChainBASESepolia,
        }
}</span>

// IsValid checks if the chain is supported
func (c WalletChain) IsValid() bool <span class="cov0" title="0">{
        validChains := append(GetMainnetChains(), GetTestnetChains()...)
        for _, chain := range validChains </span><span class="cov0" title="0">{
                if chain == c </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsTestnet checks if the chain is a testnet
func (c WalletChain) IsTestnet() bool <span class="cov0" title="0">{
        testnets := GetTestnetChains()
        for _, testnet := range testnets </span><span class="cov0" title="0">{
                if testnet == c </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetChainFamily returns the chain family
func (c WalletChain) GetChainFamily() string <span class="cov0" title="0">{
        switch c </span>{
        case ChainETH, ChainETHSepolia:<span class="cov0" title="0">
                return "Ethereum"</span>
        case ChainMATIC, ChainMATICAmoy:<span class="cov0" title="0">
                return "Polygon"</span>
        case ChainSOL, ChainSOLDevnet:<span class="cov0" title="0">
                return "Solana"</span>
        case WalletChainAptos, WalletChainAptosTestnet:<span class="cov0" title="0">
                return "Aptos"</span>
        case ChainAVAX:<span class="cov0" title="0">
                return "Avalanche"</span>
        case ChainBASE, ChainBASESepolia:<span class="cov0" title="0">
                return "Base"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// GetUSDCTokenAddress returns the USDC token address for the chain
func (c WalletChain) GetUSDCTokenAddress() string <span class="cov0" title="0">{
        switch c </span>{
        case ChainSOLDevnet:<span class="cov0" title="0">
                return USDCTokenAddressSOLDevnet</span>
        // Add more token addresses as they become available
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// WalletAccountType represents the type of wallet account
type WalletAccountType string

const (
        AccountTypeEOA WalletAccountType = "EOA" // Externally Owned Account
        AccountTypeSCA WalletAccountType = "SCA" // Smart Contract Account
)

// IsValid checks if account type is valid
func (t WalletAccountType) IsValid() bool <span class="cov0" title="0">{
        return t == AccountTypeEOA || t == AccountTypeSCA
}</span>

// WalletStatus represents the status of a wallet
type WalletStatus string

const (
        WalletStatusCreating WalletStatus = "creating"
        WalletStatusLive     WalletStatus = "live"
        WalletStatusFailed   WalletStatus = "failed"
)

// IsValid checks if wallet status is valid
func (s WalletStatus) IsValid() bool <span class="cov0" title="0">{
        return s == WalletStatusCreating || s == WalletStatusLive || s == WalletStatusFailed
}</span>

// WalletSetStatus represents the status of a wallet set
type WalletSetStatus string

const (
        WalletSetStatusActive   WalletSetStatus = "active"
        WalletSetStatusInactive WalletSetStatus = "inactive"
)

// WalletSet represents a Circle wallet set
type WalletSet struct {
        ID                     uuid.UUID       `json:"id" db:"id"`
        Name                   string          `json:"name" db:"name" validate:"required"`
        CircleWalletSetID      string          `json:"circle_wallet_set_id" db:"circle_wallet_set_id"`
        EntitySecretCiphertext string          `json:"-" db:"entity_secret_ciphertext"` // Never expose in JSON
        Status                 WalletSetStatus `json:"status" db:"status"`
        CreatedAt              time.Time       `json:"created_at" db:"created_at"`
        UpdatedAt              time.Time       `json:"updated_at" db:"updated_at"`
}

// Validate performs validation on wallet set
func (ws *WalletSet) Validate() error <span class="cov0" title="0">{
        if ws.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet set name is required")
        }</span>

        <span class="cov0" title="0">if len(ws.Name) &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet set name cannot exceed 100 characters")
        }</span>

        <span class="cov0" title="0">if ws.CircleWalletSetID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("circle wallet set ID is required")
        }</span>

        // Entity secret is now generated dynamically, no validation needed

        <span class="cov0" title="0">if ws.Status != WalletSetStatusActive &amp;&amp; ws.Status != WalletSetStatusInactive </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid wallet set status: %s", ws.Status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ManagedWallet represents a Circle-managed wallet
type ManagedWallet struct {
        ID             uuid.UUID         `json:"id" db:"id"`
        UserID         uuid.UUID         `json:"user_id" db:"user_id"`
        Chain          WalletChain       `json:"chain" db:"chain"`
        Address        string            `json:"address" db:"address"`
        CircleWalletID string            `json:"circle_wallet_id" db:"circle_wallet_id"`
        WalletSetID    uuid.UUID         `json:"wallet_set_id" db:"wallet_set_id"`
        AccountType    WalletAccountType `json:"account_type" db:"account_type"`
        Status         WalletStatus      `json:"status" db:"status"`
        CreatedAt      time.Time         `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time         `json:"updated_at" db:"updated_at"`

        // Related entities (not stored in DB)
        WalletSet *WalletSet `json:"wallet_set,omitempty"`
}

// Validate performs validation on managed wallet
func (w *ManagedWallet) Validate() error <span class="cov0" title="0">{
        if w.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user ID is required")
        }</span>

        <span class="cov0" title="0">if !w.Chain.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid chain: %s", w.Chain)
        }</span>

        <span class="cov0" title="0">if w.Address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet address is required")
        }</span>

        <span class="cov0" title="0">if w.CircleWalletID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("circle wallet ID is required")
        }</span>

        <span class="cov0" title="0">if w.WalletSetID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet set ID is required")
        }</span>

        <span class="cov0" title="0">if !w.AccountType.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid account type: %s", w.AccountType)
        }</span>

        <span class="cov0" title="0">if !w.Status.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid wallet status: %s", w.Status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsReady checks if wallet is ready for use
func (w *ManagedWallet) IsReady() bool <span class="cov0" title="0">{
        return w.Status == WalletStatusLive &amp;&amp; w.Address != ""
}</span>

// CanReceive checks if wallet can receive funds
func (w *ManagedWallet) CanReceive() bool <span class="cov0" title="0">{
        return w.IsReady()
}</span>

// GetDisplayAddress returns a user-friendly display of the address
func (w *ManagedWallet) GetDisplayAddress() string <span class="cov0" title="0">{
        if len(w.Address) &lt;= 8 </span><span class="cov0" title="0">{
                return w.Address
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s...%s", w.Address[:6], w.Address[len(w.Address)-4:])</span>
}

// WalletProvisioningJobStatus represents the status of wallet provisioning
type WalletProvisioningJobStatus string

const (
        ProvisioningStatusQueued     WalletProvisioningJobStatus = "queued"
        ProvisioningStatusInProgress WalletProvisioningJobStatus = "in_progress"
        ProvisioningStatusCompleted  WalletProvisioningJobStatus = "completed"
        ProvisioningStatusFailed     WalletProvisioningJobStatus = "failed"
        ProvisioningStatusRetry      WalletProvisioningJobStatus = "retry"
)

// WalletProvisioningJob represents an async wallet provisioning job
type WalletProvisioningJob struct {
        ID             uuid.UUID                   `json:"id" db:"id"`
        UserID         uuid.UUID                   `json:"user_id" db:"user_id"`
        Chains         []string                    `json:"chains" db:"chains"`
        Status         WalletProvisioningJobStatus `json:"status" db:"status"`
        AttemptCount   int                         `json:"attempt_count" db:"attempt_count"`
        MaxAttempts    int                         `json:"max_attempts" db:"max_attempts"`
        CircleRequests map[string]any              `json:"circle_requests" db:"circle_requests"`
        ErrorMessage   *string                     `json:"error_message" db:"error_message"`
        NextRetryAt    *time.Time                  `json:"next_retry_at" db:"next_retry_at"`
        StartedAt      *time.Time                  `json:"started_at" db:"started_at"`
        CompletedAt    *time.Time                  `json:"completed_at" db:"completed_at"`
        CreatedAt      time.Time                   `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time                   `json:"updated_at" db:"updated_at"`
}

// CanRetry checks if the job can be retried
func (job *WalletProvisioningJob) CanRetry() bool <span class="cov0" title="0">{
        return job.Status == ProvisioningStatusFailed &amp;&amp;
                job.AttemptCount &lt; job.MaxAttempts
}</span>

// MarkStarted marks the job as started
func (job *WalletProvisioningJob) MarkStarted() <span class="cov0" title="0">{
        now := time.Now()
        job.Status = ProvisioningStatusInProgress
        job.StartedAt = &amp;now
        job.AttemptCount++
        job.UpdatedAt = now
}</span>

// MarkCompleted marks the job as completed
func (job *WalletProvisioningJob) MarkCompleted() <span class="cov0" title="0">{
        now := time.Now()
        job.Status = ProvisioningStatusCompleted
        job.CompletedAt = &amp;now
        job.UpdatedAt = now
}</span>

// MarkFailed marks the job as failed
func (job *WalletProvisioningJob) MarkFailed(errorMsg string, retryDelay time.Duration) <span class="cov0" title="0">{
        now := time.Now()
        job.Status = ProvisioningStatusFailed
        job.ErrorMessage = &amp;errorMsg
        job.UpdatedAt = now

        if job.CanRetry() </span><span class="cov0" title="0">{
                nextRetry := now.Add(retryDelay)
                job.NextRetryAt = &amp;nextRetry
                job.Status = ProvisioningStatusRetry
        }</span>
}

// AddCircleRequest adds a Circle API request/response to the log
func (job *WalletProvisioningJob) AddCircleRequest(operation string, request, response any) <span class="cov0" title="0">{
        if job.CircleRequests == nil </span><span class="cov0" title="0">{
                job.CircleRequests = make(map[string]any)
        }</span>

        <span class="cov0" title="0">if requests, ok := job.CircleRequests["requests"].([]map[string]any); ok </span><span class="cov0" title="0">{
                job.CircleRequests["requests"] = append(requests, map[string]any{
                        "timestamp": time.Now(),
                        "operation": operation,
                        "request":   request,
                        "response":  response,
                })
        }</span> else<span class="cov0" title="0"> {
                job.CircleRequests["requests"] = []map[string]any{{
                        "timestamp": time.Now(),
                        "operation": operation,
                        "request":   request,
                        "response":  response,
                }}
        }</span>
}

// === API Request/Response Models ===

// WalletAddressesRequest represents request for wallet addresses
type WalletAddressesRequest struct {
        Chain *WalletChain `json:"chain,omitempty" validate:"omitempty"`
}

// WalletAddressResponse represents a single wallet address
type WalletAddressResponse struct {
        Chain   WalletChain `json:"chain"`
        Address string      `json:"address"`
        Status  string      `json:"status"`
}

// WalletAddressesResponse represents response with wallet addresses
type WalletAddressesResponse struct {
        Wallets []WalletAddressResponse `json:"wallets"`
}

// WalletStatusResponse represents wallet status for all chains
type WalletStatusResponse struct {
        UserID          uuid.UUID                      `json:"userId"`
        TotalWallets    int                            `json:"totalWallets"`
        ReadyWallets    int                            `json:"readyWallets"`
        PendingWallets  int                            `json:"pendingWallets"`
        FailedWallets   int                            `json:"failedWallets"`
        WalletsByChain  map[string]WalletChainStatus   `json:"walletsByChain"`
        ProvisioningJob *WalletProvisioningJobResponse `json:"provisioningJob,omitempty"`
}

// WalletChainStatus represents status for a specific chain
type WalletChainStatus struct {
        Chain     WalletChain `json:"chain"`
        Address   *string     `json:"address,omitempty"`
        Status    string      `json:"status"`
        CreatedAt *time.Time  `json:"createdAt,omitempty"`
        Error     *string     `json:"error,omitempty"`
}

// WalletProvisioningJobResponse represents provisioning job status
type WalletProvisioningJobResponse struct {
        ID           uuid.UUID  `json:"id"`
        Status       string     `json:"status"`
        Progress     string     `json:"progress"`
        AttemptCount int        `json:"attemptCount"`
        MaxAttempts  int        `json:"maxAttempts"`
        ErrorMessage *string    `json:"errorMessage,omitempty"`
        NextRetryAt  *time.Time `json:"nextRetryAt,omitempty"`
        CreatedAt    time.Time  `json:"createdAt"`
}

// WalletInitiationRequest represents request to initiate wallet creation after passcode verification
type WalletInitiationRequest struct {
        Chains []string `json:"chains,omitempty" validate:"omitempty,dive,oneof=SOL-DEVNET APTOS-TESTNET MATIC-AMOY BASE-SEPOLIA"`
}

// WalletInitiationResponse represents response for wallet initiation
type WalletInitiationResponse struct {
        Message string                         `json:"message"`
        UserID  string                         `json:"user_id"`
        Chains  []string                       `json:"chains"`
        Job     *WalletProvisioningJobResponse `json:"job,omitempty"`
}

// WalletProvisioningRequest represents request to provision wallets
type WalletProvisioningRequest struct {
        Chains []string `json:"chains,omitempty" validate:"omitempty,dive,oneof=ETH ETH-SEPOLIA MATIC MATIC-AMOY SOL SOL-DEVNET APTOS APTOS-TESTNET AVAX BASE BASE-SEPOLIA"`
}

// WalletProvisioningResponse represents response for wallet provisioning
type WalletProvisioningResponse struct {
        Message string                        `json:"message"`
        Job     WalletProvisioningJobResponse `json:"job"`
}

// === Circle API Models ===

// CircleWalletSetRequest represents Circle wallet set creation request
type CircleWalletSetRequest struct {
        IdempotencyKey         string `json:"idempotencyKey,omitempty"`
        EntitySecretCiphertext string `json:"entitySecretCiphertext"`
        Name                   string `json:"name"`
}

// CircleWalletSetResponse represents Circle wallet set response
type CircleWalletSetResponse struct {
        WalletSet CircleWalletSetData `json:"walletSet"`
}

// UnmarshalJSON normalizes Circle wallet set responses that may wrap data
func (r *CircleWalletSetResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        aux := struct {
                Data struct {
                        WalletSet CircleWalletSetData `json:"walletSet"`
                } `json:"data"`
                WalletSet *CircleWalletSetData `json:"walletSet"`
        }{}

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if wrapped in data.walletSet first
        <span class="cov0" title="0">if aux.Data.WalletSet.ID != "" </span><span class="cov0" title="0">{
                r.WalletSet = aux.Data.WalletSet
                return nil
        }</span>

        // Fallback to direct walletSet field
        <span class="cov0" title="0">if aux.WalletSet != nil &amp;&amp; aux.WalletSet.ID != "" </span><span class="cov0" title="0">{
                r.WalletSet = *aux.WalletSet
                return nil
        }</span>

        // Default empty structure
        <span class="cov0" title="0">r.WalletSet = CircleWalletSetData{}
        return nil</span>
}

// CircleWalletSetData represents Circle wallet set data
type CircleWalletSetData struct {
        ID          string    `json:"id"`
        CustodyType string    `json:"custodyType"`
        Name        string    `json:"name"`
        CreatedDate time.Time `json:"createDate"`
        UpdatedDate time.Time `json:"updateDate"`
}

// CircleWalletCreateRequest represents Circle wallet creation request
type CircleWalletCreateRequest struct {
        IdempotencyKey         string   `json:"idempotencyKey,omitempty"`
        EntitySecretCiphertext string   `json:"entitySecretCipherText"`
        Blockchains            []string `json:"blockchains"`
        Count                  int      `json:"count,omitempty"`
        AccountType            string   `json:"accountType"`
        WalletSetID            string   `json:"walletSetId"`
}

// CircleWalletCreateResponse represents Circle wallet creation response
type CircleWalletCreateResponse struct {
        Wallet CircleWalletData `json:"wallet"`
}

// CircleWalletCreateBulkResponse represents Circle wallet creation response for bulk operations
type CircleWalletCreateBulkResponse struct {
        Wallets []CircleWalletData `json:"wallets"`
}

// UnmarshalJSON normalizes Circle wallet responses that may wrap data
func (r *CircleWalletCreateResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        aux := struct {
                Data struct {
                        Wallets []CircleWalletData `json:"wallets"`
                } `json:"data"`
                Wallet  *CircleWalletData  `json:"wallet"`
                Wallets []CircleWalletData `json:"wallets"`
        }{}

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if wrapped in data.wallets first (most common format)
        <span class="cov0" title="0">if len(aux.Data.Wallets) &gt; 0 </span><span class="cov0" title="0">{
                r.Wallet = aux.Data.Wallets[0] // Take first wallet for single response
                return nil
        }</span>

        // Check direct wallets array
        <span class="cov0" title="0">if len(aux.Wallets) &gt; 0 </span><span class="cov0" title="0">{
                r.Wallet = aux.Wallets[0]
                return nil
        }</span>

        // Fallback to direct wallet field
        <span class="cov0" title="0">if aux.Wallet != nil &amp;&amp; aux.Wallet.ID != "" </span><span class="cov0" title="0">{
                r.Wallet = *aux.Wallet
                return nil
        }</span>

        // Default empty structure
        <span class="cov0" title="0">r.Wallet = CircleWalletData{}
        return nil</span>
}

// UnmarshalJSON normalizes Circle bulk wallet responses that may wrap data
func (r *CircleWalletCreateBulkResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type alias CircleWalletCreateBulkResponse
        aux := struct {
                Data    *alias             `json:"data"`
                Wallets []CircleWalletData `json:"wallets"`
        }{}

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch </span>{
        case aux.Data != nil &amp;&amp; len(aux.Data.Wallets) &gt; 0:<span class="cov0" title="0">
                r.Wallets = aux.Data.Wallets</span>
        case len(aux.Wallets) &gt; 0:<span class="cov0" title="0">
                r.Wallets = aux.Wallets</span>
        default:<span class="cov0" title="0">
                r.Wallets = []CircleWalletData{}</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CircleWalletData represents Circle wallet data
type CircleWalletData struct {
        ID          string                `json:"id"`
        State       string                `json:"state"`
        WalletSetId string                `json:"walletSetId"`
        CustodyType string                `json:"custodyType"`
        AccountType string                `json:"accountType,omitempty"`
        Addresses   []CircleWalletAddress `json:"addresses,omitempty"`
        Address     string                `json:"address,omitempty"` // For single address responses
        Blockchain  string                `json:"blockchain,omitempty"`
        CreatedDate time.Time             `json:"createDate"`
        UpdatedDate time.Time             `json:"updateDate"`
}

// CircleWalletAddress represents a wallet address for a specific blockchain
type CircleWalletAddress struct {
        Address    string `json:"address"`
        Blockchain string `json:"blockchain"`
        Chain      string `json:"chain,omitempty"`
}

// CircleErrorResponse represents Circle API error response
type CircleErrorResponse struct {
        Code    int                `json:"code"`
        Message string             `json:"message"`
        Errors  []CircleFieldError `json:"errors,omitempty"`
}

// CircleFieldError represents field-specific error
type CircleFieldError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// Error implements error interface
func (e CircleErrorResponse) Error() string <span class="cov0" title="0">{
        if len(e.Errors) &gt; 0 </span><span class="cov0" title="0">{
                var details []string
                for _, fieldErr := range e.Errors </span><span class="cov0" title="0">{
                        details = append(details, fmt.Sprintf("%s: %s", fieldErr.Field, fieldErr.Message))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Circle API error %d: %s (%s)", e.Code, e.Message, strings.Join(details, ", "))</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("Circle API error %d: %s", e.Code, e.Message)</span>
}

// CircleAPIError represents a comprehensive Circle API error with type information
type CircleAPIError struct {
        Code       int                `json:"code"`
        Message    string             `json:"message"`
        Errors     []CircleFieldError `json:"errors,omitempty"`
        RequestID  string             `json:"request_id,omitempty"`
        RetryAfter *time.Duration     `json:"retry_after,omitempty"`
        Type       string             `json:"type"`
}

// Error implements error interface
func (e CircleAPIError) Error() string <span class="cov0" title="0">{
        if len(e.Errors) &gt; 0 </span><span class="cov0" title="0">{
                var details []string
                for _, fieldErr := range e.Errors </span><span class="cov0" title="0">{
                        details = append(details, fmt.Sprintf("%s: %s", fieldErr.Field, fieldErr.Message))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Circle %s error %d: %s (%s)", e.Type, e.Code, e.Message, strings.Join(details, ", "))</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("Circle %s error %d: %s", e.Type, e.Code, e.Message)</span>
}

// IsRetryable returns true if the error is retryable
func (e CircleAPIError) IsRetryable() bool <span class="cov0" title="0">{
        switch e.Code </span>{
        case 429:<span class="cov0" title="0"> // Rate limit
                return true</span>
        case 500, 502, 503, 504:<span class="cov0" title="0"> // Server errors
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetRetryAfter returns the retry delay for rate limit errors
func (e CircleAPIError) GetRetryAfter() time.Duration <span class="cov0" title="0">{
        if e.RetryAfter != nil </span><span class="cov0" title="0">{
                return *e.RetryAfter
        }</span>
        // Default backoff for server errors
        <span class="cov0" title="0">if e.Code &gt;= 500 </span><span class="cov0" title="0">{
                return 5 * time.Second
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// CircleAuthError represents authentication/authorization errors
type CircleAuthError struct {
        CircleAPIError
}

// CircleValidationError represents validation errors
type CircleValidationError struct {
        CircleAPIError
}

// CircleRateLimitError represents rate limit errors
type CircleRateLimitError struct {
        CircleAPIError
}

// CircleConflictError represents conflict errors (duplicate resources)
type CircleConflictError struct {
        CircleAPIError
}

// CircleServerError represents server errors
type CircleServerError struct {
        CircleAPIError
}

// NewCircleAPIError creates a new Circle API error with proper typing
func NewCircleAPIError(code int, message string, requestID string, retryAfter *time.Duration) error <span class="cov0" title="0">{
        baseError := CircleAPIError{
                Code:       code,
                Message:    message,
                RequestID:  requestID,
                RetryAfter: retryAfter,
        }

        switch </span>{
        case code == 401 || code == 403:<span class="cov0" title="0">
                baseError.Type = "auth"
                return CircleAuthError{baseError}</span>
        case code == 400:<span class="cov0" title="0">
                baseError.Type = "validation"
                return CircleValidationError{baseError}</span>
        case code == 429:<span class="cov0" title="0">
                baseError.Type = "rate_limit"
                return CircleRateLimitError{baseError}</span>
        case code == 409:<span class="cov0" title="0">
                baseError.Type = "conflict"
                return CircleConflictError{baseError}</span>
        case code &gt;= 500:<span class="cov0" title="0">
                baseError.Type = "server"
                return CircleServerError{baseError}</span>
        default:<span class="cov0" title="0">
                baseError.Type = "client"
                return baseError</span>
        }
}

// WalletListFilters represents filters for wallet listing
type WalletListFilters struct {
        UserID      *uuid.UUID `json:"user_id,omitempty"`
        WalletSetID *uuid.UUID `json:"wallet_set_id,omitempty"`
        Chain       string     `json:"chain,omitempty"`
        AccountType string     `json:"account_type,omitempty"`
        Status      string     `json:"status,omitempty"`
        Limit       int        `json:"limit"`
        Offset      int        `json:"offset"`
}

// CircleTransferRequest represents a request to transfer funds using Circle API
type CircleTransferRequest struct {
        IDempotencyKey         string   `json:"idempotencyKey"`
        EntitySecretCiphertext string   `json:"entitySecretCiphertext"`
        WalletID               string   `json:"walletId"`
        TokenID                string   `json:"tokenId"`
        Amounts                []string `json:"amounts"`
        DestinationAddress     string   `json:"destinationAddress,omitempty"`
        DestinationWalletID    string   `json:"destinationWalletId,omitempty"`
        DestinationTag         string   `json:"destinationTag,omitempty"`
        DestinationMemo        string   `json:"destinationMemo,omitempty"`
        DestinationMemoType    string   `json:"destinationMemoType,omitempty"`
        RefID                  string   `json:"refId,omitempty"`
        Fee                    string   `json:"fee,omitempty"`
        FeeLevel               string   `json:"feeLevel,omitempty"`
        MaxFee                 string   `json:"maxFee,omitempty"`
        PriorityFee            string   `json:"priorityFee,omitempty"`
        GasPrice               string   `json:"gasPrice,omitempty"`
        GasLimit               string   `json:"gasLimit,omitempty"`
        Nonce                  string   `json:"nonce,omitempty"`
        Note                   string   `json:"note,omitempty"`
        AutoGas                bool     `json:"autoGas,omitempty"`
        NetworkFee             string   `json:"networkFee,omitempty"`
        ReplaceTxByHash        string   `json:"replaceTxByHash,omitempty"`
        SequenceID             string   `json:"sequenceId,omitempty"`
        SourceAddress          string   `json:"sourceAddress,omitempty"`
        SourceAddressTag       string   `json:"sourceAddressTag,omitempty"`
        SourceAddressMemo      string   `json:"sourceAddressMemo,omitempty"`
        SourceAddressMemoType  string   `json:"sourceAddressMemoType,omitempty"`
        SourceWalletID         string   `json:"sourceWalletId,omitempty"`
        SourceTag              string   `json:"sourceTag,omitempty"`
        SourceMemo             string   `json:"sourceMemo,omitempty"`
        SourceMemoType         string   `json:"sourceMemoType,omitempty"`
        TrackingRef            string   `json:"trackingRef,omitempty"`
        TxHash                 string   `json:"txHash,omitempty"`
        TxType                 string   `json:"txType,omitempty"`
        WalletSetID            string   `json:"walletSetId,omitempty"`
}

// CircleTokenInfo represents token metadata from Circle API
type CircleTokenInfo struct {
        ID           string    `json:"id"`
        Blockchain   string    `json:"blockchain"`
        TokenAddress string    `json:"tokenAddress,omitempty"`
        Standard     string    `json:"standard,omitempty"`
        Name         string    `json:"name"`
        Symbol       string    `json:"symbol"`
        Decimals     int       `json:"decimals"`
        IsNative     bool      `json:"isNative"`
        UpdateDate   time.Time `json:"updateDate"`
        CreateDate   time.Time `json:"createDate"`
}

// CircleTokenBalance represents a single token balance from Circle API
type CircleTokenBalance struct {
        Token      CircleTokenInfo `json:"token"`
        Amount     string          `json:"amount"`
        UpdateDate time.Time       `json:"updateDate"`
}

// CircleWalletBalancesResponse represents the Circle API response for wallet balances
type CircleWalletBalancesResponse struct {
        TokenBalances []CircleTokenBalance `json:"tokenBalances"`
}

// UnmarshalJSON normalizes Circle balance responses that wrap data
func (r *CircleWalletBalancesResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        aux := struct {
                Data struct {
                        TokenBalances []CircleTokenBalance `json:"tokenBalances"`
                } `json:"data"`
                TokenBalances []CircleTokenBalance `json:"tokenBalances"`
        }{}

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if wrapped in data.tokenBalances first
        <span class="cov0" title="0">if len(aux.Data.TokenBalances) &gt; 0 </span><span class="cov0" title="0">{
                r.TokenBalances = aux.Data.TokenBalances
                return nil
        }</span>

        // Fallback to direct tokenBalances field
        <span class="cov0" title="0">if len(aux.TokenBalances) &gt; 0 </span><span class="cov0" title="0">{
                r.TokenBalances = aux.TokenBalances
                return nil
        }</span>

        // Default to empty array (not nil)
        <span class="cov0" title="0">r.TokenBalances = []CircleTokenBalance{}
        return nil</span>
}

// GetUSDCBalance extracts USDC balance from token balances
func (r *CircleWalletBalancesResponse) GetUSDCBalance() string <span class="cov0" title="0">{
        for _, balance := range r.TokenBalances </span><span class="cov0" title="0">{
                // Check if token is USDC (case-insensitive)
                if strings.EqualFold(balance.Token.Symbol, "USDC") </span><span class="cov0" title="0">{
                        return balance.Amount
                }</span>
        }
        <span class="cov0" title="0">return "0"</span>
}

// GetNativeBalance extracts native token balance (e.g., MATIC, ETH)
func (r *CircleWalletBalancesResponse) GetNativeBalance() string <span class="cov0" title="0">{
        for _, balance := range r.TokenBalances </span><span class="cov0" title="0">{
                if balance.Token.IsNative </span><span class="cov0" title="0">{
                        return balance.Amount
                }</span>
        }
        <span class="cov0" title="0">return "0"</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package entities

import (
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
)

// WithdrawalStatus represents the status of a withdrawal request
type WithdrawalStatus string

const (
        WithdrawalStatusPending    WithdrawalStatus = "pending"
        WithdrawalStatusApproved   WithdrawalStatus = "approved"
        WithdrawalStatusProcessing WithdrawalStatus = "processing"
        WithdrawalStatusCompleted  WithdrawalStatus = "completed"
        WithdrawalStatusFailed     WithdrawalStatus = "failed"
        WithdrawalStatusRejected   WithdrawalStatus = "rejected"
        WithdrawalStatusExpired    WithdrawalStatus = "expired"
        WithdrawalStatusCancelled  WithdrawalStatus = "cancelled"
)

// IsValid checks if the withdrawal status is valid
func (s WithdrawalStatus) IsValid() bool <span class="cov0" title="0">{
        switch s </span>{
        case WithdrawalStatusPending, WithdrawalStatusApproved, WithdrawalStatusProcessing,
                WithdrawalStatusCompleted, WithdrawalStatusFailed, WithdrawalStatusRejected,
                WithdrawalStatusExpired, WithdrawalStatusCancelled:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// WithdrawalRequest represents a withdrawal request
type WithdrawalRequest struct {
        ID                 uuid.UUID              `json:"id" db:"id"`
        UserID             uuid.UUID              `json:"user_id" db:"user_id"`
        WalletID           uuid.UUID              `json:"wallet_id" db:"wallet_id"`
        Amount             decimal.Decimal        `json:"amount" db:"amount"`
        Currency           string                 `json:"currency" db:"currency"`
        DestinationAddress string                 `json:"destination_address" db:"destination_address"`
        Blockchain         string                 `json:"blockchain" db:"blockchain"`
        Status             WithdrawalStatus       `json:"status" db:"status"`
        ApprovalRequired   bool                   `json:"approval_required" db:"approval_required"`
        ApprovedBy         *uuid.UUID             `json:"approved_by,omitempty" db:"approved_by"`
        ApprovedAt         *time.Time             `json:"approved_at,omitempty" db:"approved_at"`
        ExpiresAt          time.Time              `json:"expires_at" db:"expires_at"`
        RejectionReason    *string                `json:"rejection_reason,omitempty" db:"rejection_reason"`
        RejectedBy         *uuid.UUID             `json:"rejected_by,omitempty" db:"rejected_by"`
        RejectedAt         *time.Time             `json:"rejected_at,omitempty" db:"rejected_at"`
        IdempotencyKey     *string                `json:"idempotency_key,omitempty" db:"idempotency_key"`
        Metadata           map[string]interface{} `json:"metadata,omitempty" db:"metadata"`
        CreatedAt          time.Time              `json:"created_at" db:"created_at"`
        UpdatedAt          time.Time              `json:"updated_at" db:"updated_at"`

        // Related entities (not stored in DB)
        Wallet *ManagedWallet `json:"wallet,omitempty"`
        User   *User          `json:"user,omitempty"`
}

// Validate validates the withdrawal request
func (wr *WithdrawalRequest) Validate() error <span class="cov0" title="0">{
        if wr.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user_id is required")
        }</span>
        <span class="cov0" title="0">if wr.WalletID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet_id is required")
        }</span>
        <span class="cov0" title="0">if wr.Amount.IsZero() || wr.Amount.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("amount must be positive")
        }</span>
        <span class="cov0" title="0">if wr.Currency == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("currency is required")
        }</span>
        <span class="cov0" title="0">if wr.DestinationAddress == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("destination_address is required")
        }</span>
        <span class="cov0" title="0">if wr.Blockchain == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("blockchain is required")
        }</span>
        <span class="cov0" title="0">if !wr.Status.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid status: %s", wr.Status)
        }</span>
        <span class="cov0" title="0">if wr.ExpiresAt.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("expires_at is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsExpired checks if the withdrawal request has expired
func (wr *WithdrawalRequest) IsExpired() bool <span class="cov0" title="0">{
        return time.Now().After(wr.ExpiresAt)
}</span>

// CanBeApproved checks if the withdrawal can be approved
func (wr *WithdrawalRequest) CanBeApproved() bool <span class="cov0" title="0">{
        return wr.Status == WithdrawalStatusPending &amp;&amp; !wr.IsExpired()
}</span>

// CanBeRejected checks if the withdrawal can be rejected
func (wr *WithdrawalRequest) CanBeRejected() bool <span class="cov0" title="0">{
        return wr.Status == WithdrawalStatusPending &amp;&amp; !wr.IsExpired()
}</span>

// WithdrawalApproval represents an approval for a withdrawal request
type WithdrawalApproval struct {
        ID                  uuid.UUID `json:"id" db:"id"`
        WithdrawalRequestID uuid.UUID `json:"withdrawal_request_id" db:"withdrawal_request_id"`
        ApproverID          uuid.UUID `json:"approver_id" db:"approver_id"`
        ApprovalLevel       int       `json:"approval_level" db:"approval_level"`
        ApprovedAt          time.Time `json:"approved_at" db:"approved_at"`
        Notes               *string   `json:"notes,omitempty" db:"notes"`
        CreatedAt           time.Time `json:"created_at" db:"created_at"`

        // Related entities (not stored in DB)
        Approver *User `json:"approver,omitempty"`
}

// WithdrawalLimits represents user withdrawal limits
type WithdrawalLimits struct {
        ID                   uuid.UUID       `json:"id" db:"id"`
        UserID               uuid.UUID       `json:"user_id" db:"user_id"`
        DailyLimit           decimal.Decimal `json:"daily_limit" db:"daily_limit"`
        WeeklyLimit          decimal.Decimal `json:"weekly_limit" db:"weekly_limit"`
        MonthlyLimit         decimal.Decimal `json:"monthly_limit" db:"monthly_limit"`
        RequireDualAuthAbove decimal.Decimal `json:"require_dual_auth_above" db:"require_dual_auth_above"`
        IsActive             bool            `json:"is_active" db:"is_active"`
        CreatedAt            time.Time       `json:"created_at" db:"created_at"`
        UpdatedAt            time.Time       `json:"updated_at" db:"updated_at"`
}

// Validate validates the withdrawal limits
func (wl *WithdrawalLimits) Validate() error <span class="cov0" title="0">{
        if wl.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user_id is required")
        }</span>
        <span class="cov0" title="0">if wl.DailyLimit.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("daily_limit cannot be negative")
        }</span>
        <span class="cov0" title="0">if wl.WeeklyLimit.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("weekly_limit cannot be negative")
        }</span>
        <span class="cov0" title="0">if wl.MonthlyLimit.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("monthly_limit cannot be negative")
        }</span>
        <span class="cov0" title="0">if wl.RequireDualAuthAbove.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("require_dual_auth_above cannot be negative")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WithdrawalTracking represents withdrawal usage tracking
type WithdrawalTracking struct {
        ID               uuid.UUID       `json:"id" db:"id"`
        UserID           uuid.UUID       `json:"user_id" db:"user_id"`
        Date             time.Time       `json:"date" db:"date"`
        DailyTotal       decimal.Decimal `json:"daily_total" db:"daily_total"`
        WeeklyTotal      decimal.Decimal `json:"weekly_total" db:"weekly_total"`
        MonthlyTotal     decimal.Decimal `json:"monthly_total" db:"monthly_total"`
        LastWithdrawalAt *time.Time      `json:"last_withdrawal_at,omitempty" db:"last_withdrawal_at"`
        CreatedAt        time.Time       `json:"created_at" db:"created_at"`
        UpdatedAt        time.Time       `json:"updated_at" db:"updated_at"`
}

// === API Request/Response Models ===

// CreateWithdrawalRequest represents a withdrawal request
type CreateWithdrawalRequest struct {
        WalletID           uuid.UUID `json:"walletId" validate:"required"`
        Amount             string    `json:"amount" validate:"required,gt=0"`
        Currency           string    `json:"currency" validate:"required,oneof=USDC"`
        DestinationAddress string    `json:"destinationAddress" validate:"required"`
        Blockchain         string    `json:"blockchain" validate:"required,oneof=SOL-DEVNET"`
        IdempotencyKey     *string   `json:"idempotencyKey,omitempty"`
}

// WithdrawalResponse represents a withdrawal request response
type WithdrawalResponse struct {
        ID                 uuid.UUID        `json:"id"`
        UserID             uuid.UUID        `json:"userId"`
        WalletID           uuid.UUID        `json:"walletId"`
        Amount             string           `json:"amount"`
        Currency           string           `json:"currency"`
        DestinationAddress string           `json:"destinationAddress"`
        Blockchain         string           `json:"blockchain"`
        Status             WithdrawalStatus `json:"status"`
        ApprovalRequired   bool             `json:"approvalRequired"`
        ApprovedBy         *uuid.UUID       `json:"approvedBy,omitempty"`
        ApprovedAt         *time.Time       `json:"approvedAt,omitempty"`
        ExpiresAt          time.Time        `json:"expiresAt"`
        CreatedAt          time.Time        `json:"createdAt"`
        UpdatedAt          time.Time        `json:"updatedAt"`
}

// ApproveWithdrawalRequest represents an approval request
type ApproveWithdrawalRequest struct {
        WithdrawalID uuid.UUID `json:"withdrawalId" validate:"required"`
        Notes        *string   `json:"notes,omitempty"`
}

// RejectWithdrawalRequest represents a rejection request
type RejectWithdrawalRequest struct {
        WithdrawalID    uuid.UUID `json:"withdrawalId" validate:"required"`
        RejectionReason string    `json:"rejectionReason" validate:"required"`
        Notes           *string   `json:"notes,omitempty"`
}

// WithdrawalLimitsRequest represents a limits update request
type WithdrawalLimitsRequest struct {
        DailyLimit           *string `json:"dailyLimit,omitempty"`
        WeeklyLimit          *string `json:"weeklyLimit,omitempty"`
        MonthlyLimit         *string `json:"monthlyLimit,omitempty"`
        RequireDualAuthAbove *string `json:"requireDualAuthAbove,omitempty"`
}

// WithdrawalLimitsResponse represents withdrawal limits response
type WithdrawalLimitsResponse struct {
        DailyLimit           string `json:"dailyLimit"`
        WeeklyLimit          string `json:"weeklyLimit"`
        MonthlyLimit         string `json:"monthlyLimit"`
        RequireDualAuthAbove string `json:"requireDualAuthAbove"`
        DailyUsed            string `json:"dailyUsed"`
        WeeklyUsed           string `json:"weeklyUsed"`
        MonthlyUsed          string `json:"monthlyUsed"`
        DailyRemaining       string `json:"dailyRemaining"`
        WeeklyRemaining      string `json:"weeklyRemaining"`
        MonthlyRemaining     string `json:"monthlyRemaining"`
}

// WithdrawalListResponse represents a paginated list of withdrawals
type WithdrawalListResponse struct {
        Withdrawals []*WithdrawalResponse `json:"withdrawals"`
        NextCursor  *string               `json:"nextCursor,omitempty"`
        TotalCount  int                   `json:"totalCount"`
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package entities

import (
        "context"
        "time"

        "github.com/google/uuid"
)

// ZeroGStorageClient interface defines operations for 0G storage
type ZeroGStorageClient interface {
        // Store uploads data to 0G storage and returns a content-addressed URI
        Store(ctx context.Context, namespace string, data []byte, metadata map[string]string) (*StorageResult, error)

        // Retrieve downloads data from 0G storage using a URI
        Retrieve(ctx context.Context, uri string) (*StorageData, error)

        // HealthCheck verifies connectivity to 0G storage network
        HealthCheck(ctx context.Context) (*HealthStatus, error)

        // ListObjects lists objects in a namespace (optional, for management)
        ListObjects(ctx context.Context, namespace string, prefix string) ([]StorageObject, error)

        // Delete removes an object from storage (if supported)
        Delete(ctx context.Context, uri string) error
}

// ZeroGInferenceGateway interface defines operations for AI inference
type ZeroGInferenceGateway interface {
        // GenerateWeeklySummary creates an AI-generated weekly portfolio summary
        GenerateWeeklySummary(ctx context.Context, request *WeeklySummaryRequest) (*InferenceResult, error)

        // AnalyzeOnDemand performs on-demand portfolio analysis
        AnalyzeOnDemand(ctx context.Context, request *AnalysisRequest) (*InferenceResult, error)

        // HealthCheck verifies connectivity to 0G compute network
        HealthCheck(ctx context.Context) (*HealthStatus, error)

        // GetServiceInfo returns information about available inference services
        GetServiceInfo(ctx context.Context) (*ServiceInfo, error)
}

// StorageResult represents the result of a successful storage operation
type StorageResult struct {
        URI       string            `json:"uri"`        // Content-addressed URI for retrieval
        Hash      string            `json:"hash"`       // Content hash (SHA-256)
        Size      int64             `json:"size"`       // Size in bytes
        Namespace string            `json:"namespace"`  // Storage namespace
        Metadata  map[string]string `json:"metadata"`   // Custom metadata
        StoredAt  time.Time         `json:"stored_at"`  // Storage timestamp
        Replicas  int               `json:"replicas"`   // Number of replicas stored
        ExpiresAt *time.Time        `json:"expires_at"` // Optional expiration time
}

// StorageData represents retrieved data from storage
type StorageData struct {
        Data      []byte            `json:"data"`       // Retrieved data content
        URI       string            `json:"uri"`        // Original URI
        Hash      string            `json:"hash"`       // Content hash for verification
        Size      int64             `json:"size"`       // Data size
        Metadata  map[string]string `json:"metadata"`   // Associated metadata
        StoredAt  time.Time         `json:"stored_at"`  // Original storage timestamp
        ExpiresAt *time.Time        `json:"expires_at"` // Expiration time if set
}

// StorageObject represents metadata about a stored object
type StorageObject struct {
        URI       string            `json:"uri"`       // Object URI
        Hash      string            `json:"hash"`      // Content hash
        Size      int64             `json:"size"`      // Object size
        Metadata  map[string]string `json:"metadata"`  // Object metadata
        StoredAt  time.Time         `json:"stored_at"` // Storage timestamp
        Namespace string            `json:"namespace"` // Storage namespace
}

// WeeklySummaryRequest contains data for weekly summary generation
type WeeklySummaryRequest struct {
        UserID        uuid.UUID             `json:"user_id"`        // User identifier
        WeekStart     time.Time             `json:"week_start"`     // Start of the week
        WeekEnd       time.Time             `json:"week_end"`       // End of the week
        PortfolioData *PortfolioMetrics     `json:"portfolio_data"` // Portfolio performance data
        Preferences   *UserPreferences      `json:"preferences"`    // User preferences for summary
        PreviousWeek  *WeeklySummaryRequest `json:"previous_week"`  // Previous week for comparison
}

// AnalysisRequest contains data for on-demand analysis
type AnalysisRequest struct {
        UserID        uuid.UUID              `json:"user_id"`        // User identifier
        AnalysisType  string                 `json:"analysis_type"`  // Type of analysis requested
        PortfolioData *PortfolioMetrics      `json:"portfolio_data"` // Current portfolio data
        Preferences   *UserPreferences       `json:"preferences"`    // User preferences
        Parameters    map[string]interface{} `json:"parameters"`     // Additional parameters
}

// PortfolioMetrics contains aggregated portfolio performance data
type PortfolioMetrics struct {
        TotalValue         float64            `json:"total_value"`          // Current total portfolio value
        TotalReturn        float64            `json:"total_return"`         // Total return (absolute)
        TotalReturnPct     float64            `json:"total_return_pct"`     // Total return percentage
        DayChange          float64            `json:"day_change"`           // Daily change
        DayChangePct       float64            `json:"day_change_pct"`       // Daily change percentage
        WeekChange         float64            `json:"week_change"`          // Weekly change
        WeekChangePct      float64            `json:"week_change_pct"`      // Weekly change percentage
        MonthChange        float64            `json:"month_change"`         // Monthly change
        MonthChangePct     float64            `json:"month_change_pct"`     // Monthly change percentage
        Positions          []PositionMetrics  `json:"positions"`            // Individual position metrics
        AllocationByBasket map[string]float64 `json:"allocation_by_basket"` // Allocation breakdown
        RiskMetrics        *RiskMetrics       `json:"risk_metrics"`         // Risk analysis
        PerformanceHistory []PerformancePoint `json:"performance_history"`  // Historical performance data
}

// PositionMetrics contains metrics for individual positions
type PositionMetrics struct {
        BasketID        uuid.UUID `json:"basket_id"`         // Basket identifier
        BasketName      string    `json:"basket_name"`       // Basket name
        Quantity        float64   `json:"quantity"`          // Position quantity
        AvgPrice        float64   `json:"avg_price"`         // Average purchase price
        CurrentValue    float64   `json:"current_value"`     // Current market value
        UnrealizedPL    float64   `json:"unrealized_pl"`     // Unrealized profit/loss
        UnrealizedPLPct float64   `json:"unrealized_pl_pct"` // Unrealized P&amp;L percentage
        Weight          float64   `json:"weight"`            // Portfolio weight
}

// RiskMetrics contains portfolio risk analysis
type RiskMetrics struct {
        Volatility      float64 `json:"volatility"`      // Portfolio volatility
        Beta            float64 `json:"beta"`            // Portfolio beta
        SharpeRatio     float64 `json:"sharpe_ratio"`    // Sharpe ratio
        MaxDrawdown     float64 `json:"max_drawdown"`    // Maximum drawdown
        VaR             float64 `json:"var"`             // Value at Risk (95%)
        Diversification float64 `json:"diversification"` // Diversification score (0-1)
}

// PerformancePoint represents a point-in-time portfolio value
type PerformancePoint struct {
        Date  time.Time `json:"date"`  // Date of the data point
        Value float64   `json:"value"` // Portfolio value
        PnL   float64   `json:"pnl"`   // Profit &amp; Loss
}

// UserPreferences contains user preferences for AI analysis
type UserPreferences struct {
        RiskTolerance        string          `json:"risk_tolerance"`        // conservative, moderate, aggressive
        PreferredStyle       string          `json:"preferred_style"`       // detailed, summary, bullet_points
        FocusAreas           []string        `json:"focus_areas"`           // areas of interest (performance, risk, allocation, etc.)
        Language             string          `json:"language"`              // preferred language (default: en)
        NotificationSettings map[string]bool `json:"notification_settings"` // notification preferences
}

// InferenceResult represents the result of an AI inference operation
type InferenceResult struct {
        RequestID      string                 `json:"request_id"`      // Unique request identifier
        Content        string                 `json:"content"`         // Generated content (markdown)
        ContentType    string                 `json:"content_type"`    // Content type (text/markdown, application/json)
        Metadata       map[string]interface{} `json:"metadata"`        // Additional metadata
        TokensUsed     int                    `json:"tokens_used"`     // Number of tokens consumed
        ProcessingTime time.Duration          `json:"processing_time"` // Time taken for inference
        Model          string                 `json:"model"`           // Model used for inference
        CreatedAt      time.Time              `json:"created_at"`      // Generation timestamp
        ArtifactURI    string                 `json:"artifact_uri"`    // URI to stored detailed analysis
}

// HealthStatus represents the health status of a 0G service
type HealthStatus struct {
        Status      string                 `json:"status"`       // healthy, degraded, unhealthy
        Latency     time.Duration          `json:"latency"`      // Response latency
        Version     string                 `json:"version"`      // Service version
        Uptime      time.Duration          `json:"uptime"`       // Service uptime
        Metrics     map[string]interface{} `json:"metrics"`      // Service-specific metrics
        LastChecked time.Time              `json:"last_checked"` // Last health check time
        Errors      []string               `json:"errors"`       // Any error messages
}

// ServiceInfo contains information about available inference services
type ServiceInfo struct {
        ProviderID   string                 `json:"provider_id"`  // Provider identifier
        ServiceName  string                 `json:"service_name"` // Service name
        Models       []ModelInfo            `json:"models"`       // Available models
        Pricing      *PricingInfo           `json:"pricing"`      // Pricing information
        Capabilities []string               `json:"capabilities"` // Service capabilities
        Status       string                 `json:"status"`       // Service status
        Metadata     map[string]interface{} `json:"metadata"`     // Additional service metadata
}

// ModelInfo contains information about an AI model
type ModelInfo struct {
        ModelID     string    `json:"model_id"`    // Model identifier
        Name        string    `json:"name"`        // Human-readable model name
        Description string    `json:"description"` // Model description
        MaxTokens   int       `json:"max_tokens"`  // Maximum tokens per request
        InputCost   float64   `json:"input_cost"`  // Cost per input token
        OutputCost  float64   `json:"output_cost"` // Cost per output token
        Version     string    `json:"version"`     // Model version
        UpdatedAt   time.Time `json:"updated_at"`  // Last update timestamp
}

// PricingInfo contains service pricing information
type PricingInfo struct {
        Currency      string  `json:"currency"`       // Pricing currency
        BaseRate      float64 `json:"base_rate"`      // Base rate
        TokenRate     float64 `json:"token_rate"`     // Rate per token
        MinimumCharge float64 `json:"minimum_charge"` // Minimum charge per request
}

// ZeroGError represents errors from 0G operations
type ZeroGError struct {
        Code      string                 `json:"code"`      // Error code
        Message   string                 `json:"message"`   // Error message
        Details   map[string]interface{} `json:"details"`   // Additional error details
        Retryable bool                   `json:"retryable"` // Whether the operation can be retried
        Timestamp time.Time              `json:"timestamp"` // Error timestamp
}

func (e *ZeroGError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// Operation result types for internal use
type OperationResult struct {
        Success   bool                   `json:"success"`
        Data      interface{}            `json:"data,omitempty"`
        Error     *ZeroGError            `json:"error,omitempty"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
        Duration  time.Duration          `json:"duration"`
        Timestamp time.Time              `json:"timestamp"`
}

// Namespace constants for storage organization
const (
        NamespaceAISummaries  = "ai-summaries/"
        NamespaceAIArtifacts  = "ai-artifacts/"
        NamespaceModelPrompts = "model-prompts/"
)

// Analysis types for on-demand analysis
const (
        AnalysisTypeDiversification = "diversification"
        AnalysisTypeRisk            = "risk"
        AnalysisTypePerformance     = "performance"
        AnalysisTypeAllocation      = "allocation"
        AnalysisTypeRebalancing     = "rebalancing"
)

// Health status constants
const (
        HealthStatusHealthy   = "healthy"
        HealthStatusDegraded  = "degraded"
        HealthStatusUnhealthy = "unhealthy"
)

// Error codes for 0G operations
const (
        ErrorCodeNetworkError       = "NETWORK_ERROR"
        ErrorCodeAuthError          = "AUTH_ERROR"
        ErrorCodeInvalidRequest     = "INVALID_REQUEST"
        ErrorCodeQuotaExceeded      = "QUOTA_EXCEEDED"
        ErrorCodeServiceUnavailable = "SERVICE_UNAVAILABLE"
        ErrorCodeInternalError      = "INTERNAL_ERROR"
        ErrorCodeTimeout            = "TIMEOUT"
        ErrorCodeInvalidURI         = "INVALID_URI"
        ErrorCodeNotFound           = "NOT_FOUND"
        ErrorCodeInsufficientFunds  = "INSUFFICIENT_FUNDS"
)
</pre>
		
		<pre class="file" id="file12" style="display: none">package funding

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
        "github.com/stack-service/stack_service/internal/domain/entities"
        "github.com/stack-service/stack_service/pkg/logger"
)

// Service handles funding operations - deposit addresses, confirmations, balance conversion
type Service struct {
        depositRepo       DepositRepository
        balanceRepo       BalanceRepository
        walletRepo        WalletRepository
        managedWalletRepo ManagedWalletRepository
        circleAPI         CircleAdapter
        logger            *logger.Logger
}

// DepositRepository interface for deposit persistence
type DepositRepository interface {
        Create(ctx context.Context, deposit *entities.Deposit) error
        GetByUserID(ctx context.Context, userID uuid.UUID, limit, offset int) ([]*entities.Deposit, error)
        UpdateStatus(ctx context.Context, id uuid.UUID, status string, confirmedAt *time.Time) error
        GetByTxHash(ctx context.Context, txHash string) (*entities.Deposit, error)
}

// BalanceRepository interface for balance management
type BalanceRepository interface {
        Get(ctx context.Context, userID uuid.UUID) (*entities.Balance, error)
        UpdateBuyingPower(ctx context.Context, userID uuid.UUID, amount decimal.Decimal) error
        UpdatePendingDeposits(ctx context.Context, userID uuid.UUID, amount decimal.Decimal) error
}

// WalletRepository interface for wallet operations
type WalletRepository interface {
        GetByUserAndChain(ctx context.Context, userID uuid.UUID, chain entities.Chain) (*entities.Wallet, error)
        GetByAddress(ctx context.Context, address string) (*entities.Wallet, error)
        Create(ctx context.Context, wallet *entities.Wallet) error
}

// ManagedWalletRepository interface for managed wallet operations
type ManagedWalletRepository interface {
        GetByUserID(ctx context.Context, userID uuid.UUID) ([]*entities.ManagedWallet, error)
        GetByCircleWalletID(ctx context.Context, circleWalletID string) (*entities.ManagedWallet, error)
}

// CircleAdapter interface for Circle API integration
type CircleAdapter interface {
        GenerateDepositAddress(ctx context.Context, chain entities.Chain, userID uuid.UUID) (string, error)
        ValidateDeposit(ctx context.Context, txHash string, amount decimal.Decimal) (bool, error)
        ConvertToUSD(ctx context.Context, amount decimal.Decimal, token entities.Stablecoin) (decimal.Decimal, error)
        GetWalletBalances(ctx context.Context, walletID string, tokenAddress ...string) (*entities.CircleWalletBalancesResponse, error)
}

// NewService creates a new funding service
func NewService(
        depositRepo DepositRepository,
        balanceRepo BalanceRepository,
        walletRepo WalletRepository,
        managedWalletRepo ManagedWalletRepository,
        circleAPI CircleAdapter,
        logger *logger.Logger,
) *Service <span class="cov0" title="0">{
        return &amp;Service{
                depositRepo:       depositRepo,
                balanceRepo:       balanceRepo,
                walletRepo:        walletRepo,
                managedWalletRepo: managedWalletRepo,
                circleAPI:         circleAPI,
                logger:            logger,
        }
}</span>

// CreateDepositAddress generates or retrieves deposit address for a chain
func (s *Service) CreateDepositAddress(ctx context.Context, userID uuid.UUID, chain entities.Chain) (*entities.DepositAddressResponse, error) <span class="cov0" title="0">{
        // Check if user already has a wallet for this chain
        wallet, err := s.walletRepo.GetByUserAndChain(ctx, userID, chain)
        if err != nil &amp;&amp; err.Error() != "wallet not found" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing wallet: %w", err)
        }</span>

        <span class="cov0" title="0">var address string
        if wallet != nil </span><span class="cov0" title="0">{
                address = wallet.Address
                s.logger.Info("Using existing wallet address", "user_id", userID, "chain", chain, "address", address)
        }</span> else<span class="cov0" title="0"> {
                // Generate new address through Circle
                address, err = s.circleAPI.GenerateDepositAddress(ctx, chain, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate deposit address: %w", err)
                }</span>

                // Create wallet record
                <span class="cov0" title="0">wallet = &amp;entities.Wallet{
                        ID:          uuid.New(),
                        UserID:      userID,
                        Chain:       chain,
                        Address:     address,
                        ProviderRef: fmt.Sprintf("circle-%s", address),
                        Status:      "active",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                }

                if err := s.walletRepo.Create(ctx, wallet); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create wallet record: %w", err)
                }</span>

                <span class="cov0" title="0">s.logger.Info("Created new wallet address", "user_id", userID, "chain", chain, "address", address)</span>
        }

        <span class="cov0" title="0">return &amp;entities.DepositAddressResponse{
                Chain:   chain,
                Address: address,
                QRCode:  nil, // Could generate QR code URL here
        }, nil</span>
}

// GetFundingConfirmations retrieves recent funding confirmations for user
func (s *Service) GetFundingConfirmations(ctx context.Context, userID uuid.UUID, limit, offset int) ([]*entities.FundingConfirmation, error) <span class="cov0" title="0">{
        deposits, err := s.depositRepo.GetByUserID(ctx, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get deposits: %w", err)
        }</span>

        <span class="cov0" title="0">confirmations := make([]*entities.FundingConfirmation, len(deposits))
        for i, deposit := range deposits </span><span class="cov0" title="0">{
                var confirmedAt time.Time
                if deposit.ConfirmedAt != nil </span><span class="cov0" title="0">{
                        confirmedAt = *deposit.ConfirmedAt
                }</span>
                <span class="cov0" title="0">confirmations[i] = &amp;entities.FundingConfirmation{
                        ID:          deposit.ID,
                        Chain:       deposit.Chain,
                        TxHash:      deposit.TxHash,
                        Token:       deposit.Token,
                        Amount:      deposit.Amount.String(),
                        Status:      deposit.Status,
                        ConfirmedAt: confirmedAt,
                }</span>
        }

        <span class="cov0" title="0">return confirmations, nil</span>
}

// GetBalance returns user's current balance with real-time Circle wallet balances
func (s *Service) GetBalance(ctx context.Context, userID uuid.UUID) (*entities.BalancesResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Fetching user balance with real-time Circle wallet data", "user_id", userID.String())

        // Get user's managed wallets
        managedWallets, err := s.managedWalletRepo.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get managed wallets", "error", err, "user_id", userID.String())
                // Fallback to database balance
                return s.getDatabaseBalance(ctx, userID)
        }</span>

        <span class="cov0" title="0">if len(managedWallets) == 0 </span><span class="cov0" title="0">{
                s.logger.Info("No managed wallets found for user, returning zero balance", "user_id", userID.String())
                return &amp;entities.BalancesResponse{
                        BuyingPower:     "0.00",
                        PendingDeposits: "0.00",
                        Currency:        "USD",
                }, nil
        }</span>

        // Aggregate USDC balance from all Circle wallets
        <span class="cov0" title="0">totalUSDCBalance := decimal.Zero
        walletsProcessed := 0

        for _, wallet := range managedWallets </span><span class="cov0" title="0">{
                if wallet.CircleWalletID == "" || wallet.Status != entities.WalletStatusLive </span><span class="cov0" title="0">{
                        s.logger.Debug("Skipping wallet - not ready",
                                "wallet_id", wallet.ID.String(),
                                "circle_wallet_id", wallet.CircleWalletID,
                                "status", wallet.Status)
                        continue</span>
                }

                // Fetch real-time balance from Circle API
                <span class="cov0" title="0">balanceResp, err := s.circleAPI.GetWalletBalances(ctx, wallet.CircleWalletID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to fetch Circle wallet balance, skipping",
                                "error", err,
                                "wallet_id", wallet.ID.String(),
                                "circle_wallet_id", wallet.CircleWalletID,
                                "chain", wallet.Chain)
                        continue</span>
                }

                // Extract USDC balance
                <span class="cov0" title="0">usdcBalanceStr := balanceResp.GetUSDCBalance()
                if usdcBalanceStr != "0" </span><span class="cov0" title="0">{
                        usdcBalance, err := decimal.NewFromString(usdcBalanceStr)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to parse USDC balance",
                                        "error", err,
                                        "balance_str", usdcBalanceStr,
                                        "circle_wallet_id", wallet.CircleWalletID)
                                continue</span>
                        }

                        <span class="cov0" title="0">totalUSDCBalance = totalUSDCBalance.Add(usdcBalance)
                        walletsProcessed++

                        s.logger.Info("Retrieved wallet balance",
                                "circle_wallet_id", wallet.CircleWalletID,
                                "chain", wallet.Chain,
                                "usdc_balance", usdcBalanceStr,
                                "running_total", totalUSDCBalance.String())</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("Aggregated Circle wallet balances",
                "user_id", userID.String(),
                "total_usdc", totalUSDCBalance.String(),
                "wallets_processed", walletsProcessed,
                "total_wallets", len(managedWallets))

        // Get pending deposits from database
        pendingDeposits := decimal.Zero
        dbBalance, err := s.balanceRepo.Get(ctx, userID)
        if err == nil </span><span class="cov0" title="0">{
                pendingDeposits = dbBalance.PendingDeposits
        }</span>

        // USDC is 1:1 with USD, so buying power = USDC balance
        <span class="cov0" title="0">return &amp;entities.BalancesResponse{
                BuyingPower:     totalUSDCBalance.String(),
                PendingDeposits: pendingDeposits.String(),
                Currency:        "USD",
        }, nil</span>
}

// getDatabaseBalance retrieves balance from database as fallback
func (s *Service) getDatabaseBalance(ctx context.Context, userID uuid.UUID) (*entities.BalancesResponse, error) <span class="cov0" title="0">{
        balance, err := s.balanceRepo.Get(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "balance not found" </span><span class="cov0" title="0">{
                        // Return zero balance for new users
                        return &amp;entities.BalancesResponse{
                                BuyingPower:     "0.00",
                                PendingDeposits: "0.00",
                                Currency:        "USD",
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get balance: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;entities.BalancesResponse{
                BuyingPower:     balance.BuyingPower.String(),
                PendingDeposits: balance.PendingDeposits.String(),
                Currency:        balance.Currency,
        }, nil</span>
}

// ProcessChainDeposit processes incoming chain deposit webhook
func (s *Service) ProcessChainDeposit(ctx context.Context, webhook *entities.ChainDepositWebhook) error <span class="cov0" title="0">{
        s.logger.Info("Processing chain deposit", "chain", webhook.Chain, "tx_hash", webhook.TxHash, "amount", webhook.Amount)

        // Validate the deposit with Circle
        amountFloat, err := strconv.ParseFloat(webhook.Amount, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid deposit amount %q: %w", webhook.Amount, err)
        }</span>
        <span class="cov0" title="0">amount := decimal.NewFromFloat(amountFloat)
        isValid, err := s.circleAPI.ValidateDeposit(ctx, webhook.TxHash, amount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate deposit: %w", err)
        }</span>

        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                s.logger.Warn("Invalid deposit received", "tx_hash", webhook.TxHash)
                return fmt.Errorf("invalid deposit signature or amount")
        }</span>

        // Check if deposit already exists (idempotency check)
        <span class="cov0" title="0">existingDeposit, err := s.depositRepo.GetByTxHash(ctx, webhook.TxHash)
        if err != nil &amp;&amp; err.Error() != "deposit not found" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check existing deposit: %w", err)
        }</span>

        <span class="cov0" title="0">if existingDeposit != nil </span><span class="cov0" title="0">{
                s.logger.Info("Deposit already processed", "tx_hash", webhook.TxHash)
                return nil
        }</span>

        // Find the wallet to get user ID
        <span class="cov0" title="0">wallet, err := s.walletRepo.GetByAddress(ctx, webhook.Address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find wallet for address %s: %w", webhook.Address, err)
        }</span>

        // Convert stablecoin to USD buying power
        <span class="cov0" title="0">usdAmount, err := s.circleAPI.ConvertToUSD(ctx, amount, webhook.Token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert to USD: %w", err)
        }</span>

        // Create deposit record
        <span class="cov0" title="0">deposit := &amp;entities.Deposit{
                ID:          uuid.New(),
                UserID:      wallet.UserID,
                Chain:       webhook.Chain,
                TxHash:      webhook.TxHash,
                Token:       webhook.Token,
                Amount:      amount,
                Status:      "confirmed",
                ConfirmedAt: &amp;webhook.BlockTime,
                CreatedAt:   time.Now(),
        }

        if err := s.depositRepo.Create(ctx, deposit); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create deposit record: %w", err)
        }</span>

        // Update user's buying power
        <span class="cov0" title="0">if err := s.balanceRepo.UpdateBuyingPower(ctx, wallet.UserID, usdAmount); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update buying power: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Deposit processed successfully",
                "user_id", wallet.UserID,
                "amount", webhook.Amount,
                "usd_amount", usdAmount.String(),
                "tx_hash", webhook.TxHash,
        )

        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package wallet

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/stack-service/stack_service/internal/domain/entities"
        "go.uber.org/zap"
)

// Service handles wallet operations - wallet set management, multi-chain wallet creation
type Service struct {
        walletRepo          WalletRepository
        walletSetRepo       WalletSetRepository
        provisioningJobRepo WalletProvisioningJobRepository
        circleClient        CircleClient
        auditService        AuditService
        entitySecretService EntitySecretService
        onboardingService   OnboardingService
        logger              *zap.Logger
        config              Config
}

const defaultWalletSetNamePrefix = "STACK-WalletSet"

// Config captures runtime configuration for the wallet service
type Config struct {
        WalletSetNamePrefix string
        SupportedChains     []entities.WalletChain
        DefaultWalletSetID  string
}

// Repository interfaces
type WalletRepository interface {
        Create(ctx context.Context, wallet *entities.ManagedWallet) error
        GetByID(ctx context.Context, id uuid.UUID) (*entities.ManagedWallet, error)
        GetByUserID(ctx context.Context, userID uuid.UUID) ([]*entities.ManagedWallet, error)
        GetByUserAndChain(ctx context.Context, userID uuid.UUID, chain entities.WalletChain) (*entities.ManagedWallet, error)
        GetByCircleWalletID(ctx context.Context, circleWalletID string) (*entities.ManagedWallet, error)
        Update(ctx context.Context, wallet *entities.ManagedWallet) error
        UpdateStatus(ctx context.Context, id uuid.UUID, status entities.WalletStatus) error
}

type WalletSetRepository interface {
        Create(ctx context.Context, walletSet *entities.WalletSet) error
        GetByID(ctx context.Context, id uuid.UUID) (*entities.WalletSet, error)
        GetByCircleWalletSetID(ctx context.Context, circleWalletSetID string) (*entities.WalletSet, error)
        GetActive(ctx context.Context) (*entities.WalletSet, error)
        Update(ctx context.Context, walletSet *entities.WalletSet) error
}

type WalletProvisioningJobRepository interface {
        Create(ctx context.Context, job *entities.WalletProvisioningJob) error
        GetByID(ctx context.Context, id uuid.UUID) (*entities.WalletProvisioningJob, error)
        GetByUserID(ctx context.Context, userID uuid.UUID) (*entities.WalletProvisioningJob, error)
        GetRetryableJobs(ctx context.Context, limit int) ([]*entities.WalletProvisioningJob, error)
        Update(ctx context.Context, job *entities.WalletProvisioningJob) error
}

// External service interfaces
type CircleClient interface {
        CreateWalletSet(ctx context.Context, name string, entitySecretCiphertext string) (*entities.CircleWalletSetResponse, error)
        GetWalletSet(ctx context.Context, walletSetID string) (*entities.CircleWalletSetResponse, error)
        CreateWallet(ctx context.Context, req entities.CircleWalletCreateRequest) (*entities.CircleWalletCreateResponse, error)
        GetWallet(ctx context.Context, walletID string) (*entities.CircleWalletCreateResponse, error)
        HealthCheck(ctx context.Context) error
        GetMetrics() map[string]interface{}
}

type AuditService interface {
        LogWalletEvent(ctx context.Context, userID uuid.UUID, action, entity string, before, after interface{}) error
}

type EntitySecretService interface {
        GenerateEntitySecretCiphertext(ctx context.Context) (string, error)
}

type OnboardingService interface {
        ProcessWalletCreationComplete(ctx context.Context, userID uuid.UUID) error
}

// NewService creates a new wallet service
func NewService(
        walletRepo WalletRepository,
        walletSetRepo WalletSetRepository,
        provisioningJobRepo WalletProvisioningJobRepository,
        circleClient CircleClient,
        auditService AuditService,
        entitySecretService EntitySecretService,
        onboardingService OnboardingService,
        logger *zap.Logger,
        cfg Config,
) *Service <span class="cov10" title="4">{
        cfg.DefaultWalletSetID = strings.TrimSpace(cfg.DefaultWalletSetID)
        if cfg.WalletSetNamePrefix == "" </span><span class="cov8" title="3">{
                cfg.WalletSetNamePrefix = defaultWalletSetNamePrefix
        }</span>

        <span class="cov10" title="4">cfg.SupportedChains = normalizeSupportedChains(cfg.SupportedChains, logger)

        // Entity secret is now generated dynamically, no configuration needed

        return &amp;Service{
                walletRepo:          walletRepo,
                walletSetRepo:       walletSetRepo,
                provisioningJobRepo: provisioningJobRepo,
                circleClient:        circleClient,
                auditService:        auditService,
                entitySecretService: entitySecretService,
                onboardingService:   onboardingService,
                logger:              logger,
                config:              cfg,
        }</span>
}

// SetOnboardingService sets the onboarding service (for dependency injection after creation)
func (s *Service) SetOnboardingService(onboardingService OnboardingService) <span class="cov0" title="0">{
        s.onboardingService = onboardingService
}</span>

func normalizeSupportedChains(chains []entities.WalletChain, logger *zap.Logger) []entities.WalletChain <span class="cov10" title="4">{
        if len(chains) == 0 </span><span class="cov0" title="0">{
                return []entities.WalletChain{
                        entities.ChainSOLDevnet,
                }
        }</span>

        <span class="cov10" title="4">normalized := make([]entities.WalletChain, 0, len(chains))
        seen := make(map[entities.WalletChain]struct{})

        for _, chain := range chains </span><span class="cov10" title="4">{
                if !chain.IsValid() </span><span class="cov0" title="0">{
                        logger.Warn("Ignoring unsupported wallet chain in configuration", zap.String("chain", string(chain)))
                        continue</span>
                }
                <span class="cov10" title="4">if _, ok := seen[chain]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="4">seen[chain] = struct{}{}
                normalized = append(normalized, chain)</span>
        }

        <span class="cov10" title="4">if len(normalized) == 0 </span><span class="cov0" title="0">{
                return []entities.WalletChain{
                        entities.ChainSOLDevnet,
                }
        }</span>

        <span class="cov10" title="4">return normalized</span>
}

// CreateWalletsForUser creates developer-controlled wallets for a user across specified chains
// This follows the developer-controlled-wallet pattern where we use a pre-registered Entity Secret Ciphertext
func (s *Service) CreateWalletsForUser(ctx context.Context, userID uuid.UUID, chains []entities.WalletChain) error <span class="cov0" title="0">{
        s.logger.Info("Creating developer-controlled wallets for user",
                zap.String("userID", userID.String()),
                zap.Any("chains", chains))

        if len(chains) == 0 </span><span class="cov0" title="0">{
                chains = s.config.SupportedChains
        }</span>

        // Check if user already has a provisioning job
        <span class="cov0" title="0">existingJob, err := s.provisioningJobRepo.GetByUserID(ctx, userID)
        if err == nil &amp;&amp; existingJob != nil </span><span class="cov0" title="0">{
                s.logger.Info("User already has a provisioning job",
                        zap.String("userID", userID.String()),
                        zap.String("jobID", existingJob.ID.String()),
                        zap.String("status", string(existingJob.Status)))

                // If job is in progress or queued, don't create a new one
                if existingJob.Status == entities.ProvisioningStatusQueued ||
                        existingJob.Status == entities.ProvisioningStatusInProgress </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Convert chain types to strings
        <span class="cov0" title="0">chainStrings := make([]string, len(chains))
        for i, chain := range chains </span><span class="cov0" title="0">{
                chainStrings[i] = string(chain)
        }</span>

        // Create provisioning job
        <span class="cov0" title="0">job := &amp;entities.WalletProvisioningJob{
                ID:           uuid.New(),
                UserID:       userID,
                Chains:       chainStrings,
                Status:       entities.ProvisioningStatusQueued,
                AttemptCount: 0,
                MaxAttempts:  3,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if err := s.provisioningJobRepo.Create(ctx, job); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create provisioning job: %w", err)
        }</span>

        // Process the job immediately (in production this might be done by a background worker)
        <span class="cov0" title="0">if err := s.ProcessWalletProvisioningJob(ctx, job.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to process wallet provisioning job",
                        zap.Error(err),
                        zap.String("jobID", job.ID.String()))
                return fmt.Errorf("failed to process provisioning job: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessWalletProvisioningJob processes a wallet provisioning job
func (s *Service) ProcessWalletProvisioningJob(ctx context.Context, jobID uuid.UUID) error <span class="cov0" title="0">{
        s.logger.Info("Processing wallet provisioning job", zap.String("jobID", jobID.String()))

        // Get the job
        job, err := s.provisioningJobRepo.GetByID(ctx, jobID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get provisioning job: %w", err)
        }</span>

        <span class="cov0" title="0">if job.Status != entities.ProvisioningStatusQueued &amp;&amp; job.Status != entities.ProvisioningStatusRetry </span><span class="cov0" title="0">{
                s.logger.Info("Job is not in queued/retry status",
                        zap.String("jobID", jobID.String()),
                        zap.String("status", string(job.Status)))
                return nil
        }</span>

        // Mark job as started
        <span class="cov0" title="0">job.MarkStarted()
        if err := s.provisioningJobRepo.Update(ctx, job); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update job status: %w", err)
        }</span>

        // Get or create wallet set
        <span class="cov0" title="0">walletSet, err := s.ensureWalletSet(ctx)
        if err != nil </span><span class="cov0" title="0">{
                job.MarkFailed(fmt.Sprintf("Failed to ensure wallet set: %v", err), 5*time.Minute)
                s.provisioningJobRepo.Update(ctx, job)
                return fmt.Errorf("failed to ensure wallet set: %w", err)
        }</span>

        // Create wallets for each chain
        <span class="cov0" title="0">var lastErr error
        successCount := 0

        for _, chainStr := range job.Chains </span><span class="cov0" title="0">{
                chain := entities.WalletChain(chainStr)

                if err := s.createWalletForChain(ctx, job.UserID, chain, walletSet, job); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to create wallet for chain",
                                zap.Error(err),
                                zap.String("userID", job.UserID.String()),
                                zap.String("chain", chainStr))
                        lastErr = err
                }</span> else<span class="cov0" title="0"> {
                        successCount++
                }</span>
        }

        // Update job status based on results
        <span class="cov0" title="0">if successCount == len(job.Chains) </span><span class="cov0" title="0">{
                // All wallets created successfully
                job.MarkCompleted()
                s.logger.Info("All wallets created successfully",
                        zap.String("jobID", jobID.String()),
                        zap.String("userID", job.UserID.String()),
                        zap.Int("walletCount", successCount))

                // Trigger onboarding completion callback
                if s.onboardingService != nil </span><span class="cov0" title="0">{
                        if err := s.onboardingService.ProcessWalletCreationComplete(ctx, job.UserID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to process wallet creation complete in onboarding service",
                                        zap.Error(err),
                                        zap.String("userID", job.UserID.String()))
                        }</span> else<span class="cov0" title="0"> {
                                s.logger.Info("Wallet provisioning completed and onboarding status updated",
                                        zap.String("userID", job.UserID.String()))
                        }</span>
                }

        } else<span class="cov0" title="0"> if successCount &gt; 0 </span><span class="cov0" title="0">{
                // Partial success - mark as failed but note partial success
                job.MarkFailed(fmt.Sprintf("Partial success: %d/%d wallets created. Last error: %v",
                        successCount, len(job.Chains), lastErr), 10*time.Minute)
        }</span> else<span class="cov0" title="0"> {
                // Complete failure
                job.MarkFailed(fmt.Sprintf("Failed to create any wallets: %v", lastErr), 10*time.Minute)
        }</span>

        <span class="cov0" title="0">if err := s.provisioningJobRepo.Update(ctx, job); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update job final status", zap.Error(err))
        }</span>

        // Log audit event
        <span class="cov0" title="0">if err := s.auditService.LogWalletEvent(ctx, job.UserID, "wallet_provisioning_processed", "provisioning_job",
                nil, map[string]any{
                        "job_id":        job.ID,
                        "status":        string(job.Status),
                        "success_count": successCount,
                        "total_chains":  len(job.Chains),
                }); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to log audit event", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return lastErr</span>
}

// GetWalletAddresses returns wallet addresses for a user, optionally filtered by chain
func (s *Service) GetWalletAddresses(ctx context.Context, userID uuid.UUID, chain *entities.WalletChain) (*entities.WalletAddressesResponse, error) <span class="cov1" title="1">{
        s.logger.Debug("Getting wallet addresses",
                zap.String("userID", userID.String()),
                zap.Any("chain", chain))

        var wallets []*entities.ManagedWallet
        var err error

        if chain != nil </span><span class="cov0" title="0">{
                // Get wallet for specific chain
                wallet, err := s.walletRepo.GetByUserAndChain(ctx, userID, *chain)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get wallet for chain %s: %w", *chain, err)
                }</span>
                <span class="cov0" title="0">if wallet != nil </span><span class="cov0" title="0">{
                        wallets = []*entities.ManagedWallet{wallet}
                }</span>
        } else<span class="cov1" title="1"> {
                // Get all wallets for user
                wallets, err = s.walletRepo.GetByUserID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get wallets for user: %w", err)
                }</span>
        }

        // Convert to response format
        <span class="cov1" title="1">var walletResponses []entities.WalletAddressResponse
        for _, wallet := range wallets </span><span class="cov0" title="0">{
                if wallet.IsReady() </span><span class="cov0" title="0">{
                        walletResponses = append(walletResponses, entities.WalletAddressResponse{
                                Chain:   wallet.Chain,
                                Address: wallet.Address,
                                Status:  string(wallet.Status),
                        })
                }</span>
        }

        <span class="cov1" title="1">return &amp;entities.WalletAddressesResponse{
                Wallets: walletResponses,
        }, nil</span>
}

// GetWalletStatus returns comprehensive wallet status for a user
func (s *Service) GetWalletStatus(ctx context.Context, userID uuid.UUID) (*entities.WalletStatusResponse, error) <span class="cov1" title="1">{
        s.logger.Debug("Getting wallet status", zap.String("userID", userID.String()))

        // Get all wallets for user
        wallets, err := s.walletRepo.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wallets: %w", err)
        }</span>

        // Get provisioning job if exists
        <span class="cov1" title="1">provisioningJob, err := s.provisioningJobRepo.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                // Not finding a job is okay
                provisioningJob = nil
        }</span>

        // Count wallets by status
        <span class="cov1" title="1">var readyCount, pendingCount, failedCount int
        walletsByChain := make(map[string]entities.WalletChainStatus)

        for _, wallet := range wallets </span><span class="cov0" title="0">{
                switch wallet.Status </span>{
                case entities.WalletStatusLive:<span class="cov0" title="0">
                        readyCount++</span>
                case entities.WalletStatusCreating:<span class="cov0" title="0">
                        pendingCount++</span>
                case entities.WalletStatusFailed:<span class="cov0" title="0">
                        failedCount++</span>
                }

                // Add to chain status map
                <span class="cov0" title="0">chainStatus := entities.WalletChainStatus{
                        Chain:     wallet.Chain,
                        Status:    string(wallet.Status),
                        CreatedAt: &amp;wallet.CreatedAt,
                }

                if wallet.IsReady() </span><span class="cov0" title="0">{
                        chainStatus.Address = &amp;wallet.Address
                }</span>

                <span class="cov0" title="0">walletsByChain[string(wallet.Chain)] = chainStatus</span>
        }

        // Create response
        <span class="cov1" title="1">response := &amp;entities.WalletStatusResponse{
                UserID:         userID,
                TotalWallets:   len(wallets),
                ReadyWallets:   readyCount,
                PendingWallets: pendingCount,
                FailedWallets:  failedCount,
                WalletsByChain: walletsByChain,
        }

        // Add provisioning job info if exists
        if provisioningJob != nil </span><span class="cov0" title="0">{
                progress := fmt.Sprintf("%d/%d chains", readyCount+failedCount, len(provisioningJob.Chains))
                if len(provisioningJob.Chains) &gt; 0 </span><span class="cov0" title="0">{
                        percentage := float64(readyCount+failedCount) / float64(len(provisioningJob.Chains)) * 100
                        progress = fmt.Sprintf("%.0f%% complete", percentage)
                }</span>

                <span class="cov0" title="0">response.ProvisioningJob = &amp;entities.WalletProvisioningJobResponse{
                        ID:           provisioningJob.ID,
                        Status:       string(provisioningJob.Status),
                        Progress:     progress,
                        AttemptCount: provisioningJob.AttemptCount,
                        MaxAttempts:  provisioningJob.MaxAttempts,
                        ErrorMessage: provisioningJob.ErrorMessage,
                        NextRetryAt:  provisioningJob.NextRetryAt,
                        CreatedAt:    provisioningJob.CreatedAt,
                }</span>
        }

        <span class="cov1" title="1">return response, nil</span>
}

// RetryFailedWalletProvisioning retries failed wallet provisioning jobs
func (s *Service) RetryFailedWalletProvisioning(ctx context.Context, limit int) error <span class="cov0" title="0">{
        s.logger.Info("Retrying failed wallet provisioning jobs", zap.Int("limit", limit))

        jobs, err := s.provisioningJobRepo.GetRetryableJobs(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get retryable jobs: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Found retryable jobs", zap.Int("count", len(jobs)))

        for _, job := range jobs </span><span class="cov0" title="0">{
                if time.Now().After(*job.NextRetryAt) </span><span class="cov0" title="0">{
                        s.logger.Info("Retrying wallet provisioning job",
                                zap.String("jobID", job.ID.String()),
                                zap.String("userID", job.UserID.String()))

                        if err := s.ProcessWalletProvisioningJob(ctx, job.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to retry provisioning job",
                                        zap.Error(err),
                                        zap.String("jobID", job.ID.String()))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper methods

func (s *Service) ensureWalletSet(ctx context.Context) (*entities.WalletSet, error) <span class="cov0" title="0">{
        // First, try to use configured default wallet set ID
        if s.config.DefaultWalletSetID != "" </span><span class="cov0" title="0">{
                if walletSet, err := s.walletSetRepo.GetByCircleWalletSetID(ctx, s.config.DefaultWalletSetID); err == nil &amp;&amp; walletSet != nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Using configured default wallet set",
                                zap.String("walletSetID", walletSet.ID.String()),
                                zap.String("circleWalletSetID", walletSet.CircleWalletSetID))
                        return walletSet, nil
                }</span>

                <span class="cov0" title="0">s.logger.Info("Configured Circle wallet set not found locally, attempting to hydrate",
                        zap.String("circleWalletSetID", s.config.DefaultWalletSetID))

                circleSet, err := s.circleClient.GetWalletSet(ctx, s.config.DefaultWalletSetID)
                if err == nil &amp;&amp; circleSet != nil </span><span class="cov0" title="0">{
                        walletSet := &amp;entities.WalletSet{
                                ID:                uuid.New(),
                                Name:              circleSet.WalletSet.Name,
                                CircleWalletSetID: circleSet.WalletSet.ID,
                                Status:            entities.WalletSetStatusActive,
                                CreatedAt:         time.Now(),
                                UpdatedAt:         time.Now(),
                        }

                        if createErr := s.walletSetRepo.Create(ctx, walletSet); createErr != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to persist hydrated wallet set, attempting to reuse existing record",
                                        zap.Error(createErr),
                                        zap.String("circleWalletSetID", walletSet.CircleWalletSetID))

                                existing, fetchErr := s.walletSetRepo.GetByCircleWalletSetID(ctx, walletSet.CircleWalletSetID)
                                if fetchErr == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                                        return existing, nil
                                }</span>

                                <span class="cov0" title="0">return nil, fmt.Errorf("failed to persist configured wallet set: %w", createErr)</span>
                        }

                        <span class="cov0" title="0">return walletSet, nil</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load configured Circle wallet set from API",
                                zap.String("circleWalletSetID", s.config.DefaultWalletSetID),
                                zap.Error(err))
                }</span>
        }

        // Try to get existing active wallet set
        <span class="cov0" title="0">walletSet, err := s.walletSetRepo.GetActive(ctx)
        if err == nil &amp;&amp; walletSet != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Using existing active wallet set",
                        zap.String("walletSetID", walletSet.ID.String()),
                        zap.String("circleWalletSetID", walletSet.CircleWalletSetID))
                return walletSet, nil
        }</span>

        <span class="cov0" title="0">s.logger.Info("Creating new developer-controlled wallet set")

        // Create new wallet set in Circle using pre-registered Entity Secret Ciphertext
        setName := fmt.Sprintf("%s-%s", s.config.WalletSetNamePrefix, time.Now().Format("20060102"))
        circleResp, err := s.circleClient.CreateWalletSet(ctx, setName, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Circle wallet set: %w", err)
        }</span>

        // Generate entity secret ciphertext for the wallet set
        <span class="cov0" title="0">entitySecretCiphertext, err := s.entitySecretService.GenerateEntitySecretCiphertext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate entity secret ciphertext: %w", err)
        }</span>

        // Create wallet set record
        <span class="cov0" title="0">walletSet = &amp;entities.WalletSet{
                ID:                     uuid.New(),
                Name:                   setName,
                CircleWalletSetID:      circleResp.WalletSet.ID,
                EntitySecretCiphertext: entitySecretCiphertext,
                Status:                 entities.WalletSetStatusActive,
                CreatedAt:              time.Now(),
                UpdatedAt:              time.Now(),
        }

        if err := s.walletSetRepo.Create(ctx, walletSet); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create wallet set record: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Created new developer-controlled wallet set",
                zap.String("walletSetID", walletSet.ID.String()),
                zap.String("circleWalletSetID", walletSet.CircleWalletSetID))

        return walletSet, nil</span>
}

func (s *Service) createWalletForChain(ctx context.Context, userID uuid.UUID, chain entities.WalletChain,
        walletSet *entities.WalletSet, job *entities.WalletProvisioningJob) error <span class="cov0" title="0">{

        s.logger.Info("Creating developer-controlled wallet for chain",
                zap.String("userID", userID.String()),
                zap.String("chain", string(chain)))

        // Check if wallet already exists for this chain
        existingWallet, err := s.walletRepo.GetByUserAndChain(ctx, userID, chain)
        if err == nil &amp;&amp; existingWallet != nil </span><span class="cov0" title="0">{
                s.logger.Info("Wallet already exists for chain",
                        zap.String("userID", userID.String()),
                        zap.String("chain", string(chain)),
                        zap.String("address", existingWallet.Address))
                return nil
        }</span>

        // Determine account type based on chain following developer-controlled-wallet pattern
        <span class="cov0" title="0">accountType := entities.AccountTypeEOA
        if chain.GetChainFamily() == "EVM" </span><span class="cov0" title="0">{
                // Use SCA for EVM chains to achieve unified addresses across all EVM chains
                // This ensures the same address works on ETH, MATIC, AVAX, BASE, etc.
                accountType = entities.AccountTypeSCA
        }</span>
        // Solana and Aptos chains use EOA

        // Create Circle wallet request using pre-registered Entity Secret Ciphertext
        <span class="cov0" title="0">circleReq := entities.CircleWalletCreateRequest{
                WalletSetID: walletSet.CircleWalletSetID,
                Blockchains: []string{string(chain)},
                AccountType: string(accountType),
                Count:       1, // Create single wallet per chain
                // EntitySecretCiphertext is automatically added by Circle client from config
        }

        // Add request to job log
        job.AddCircleRequest("create_wallet", circleReq, nil)

        // Create wallet in Circle using developer-controlled pattern
        circleResp, err := s.circleClient.CreateWallet(ctx, circleReq)
        if err != nil </span><span class="cov0" title="0">{
                // Add error response to job log
                job.AddCircleRequest("create_wallet_error", circleReq, map[string]any{"error": err.Error()})
                return fmt.Errorf("failed to create wallet in Circle: %w", err)
        }</span>

        // Add successful response to job log
        <span class="cov0" title="0">job.AddCircleRequest("create_wallet_success", circleReq, circleResp)

        // Find the address for the requested chain
        var address string

        // Handle both single address and addresses array responses
        if circleResp.Wallet.Address != "" </span><span class="cov0" title="0">{
                // Single address response (direct format)
                address = circleResp.Wallet.Address
        }</span> else<span class="cov0" title="0"> if len(circleResp.Wallet.Addresses) &gt; 0 </span><span class="cov0" title="0">{
                // Addresses array response
                for _, addr := range circleResp.Wallet.Addresses </span><span class="cov0" title="0">{
                        if addr.Blockchain == string(chain) </span><span class="cov0" title="0">{
                                address = addr.Address
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no address found for chain %s in Circle response", string(chain))
        }</span>

        // Create wallet record with Circle wallet ID for transaction operations
        <span class="cov0" title="0">wallet := &amp;entities.ManagedWallet{
                ID:             uuid.New(),
                UserID:         userID,
                Chain:          chain,
                Address:        address,
                CircleWalletID: circleResp.Wallet.ID, // Store Circle wallet ID for transactions
                WalletSetID:    walletSet.ID,
                AccountType:    accountType,
                Status:         entities.WalletStatusLive, // Circle API returns live wallets
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        if err := wallet.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.walletRepo.Create(ctx, wallet); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create wallet record: %w", err)
        }</span>

        // Log audit event
        <span class="cov0" title="0">if err := s.auditService.LogWalletEvent(ctx, userID, "developer_wallet_created", "wallet", nil, wallet); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to log audit event", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.logger.Info("Created developer-controlled wallet successfully",
                zap.String("userID", userID.String()),
                zap.String("chain", string(chain)),
                zap.String("address", address),
                zap.String("circleWalletID", circleResp.Wallet.ID))

        return nil</span>
}

// HealthCheck performs health checks on the wallet service
func (s *Service) HealthCheck(ctx context.Context) error <span class="cov1" title="1">{
        s.logger.Debug("Performing wallet service health check")

        // Check Circle client health
        if err := s.circleClient.HealthCheck(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("circle client health check failed: %w", err)
        }</span>

        // Check if we can access the wallet set
        <span class="cov1" title="1">_, err := s.walletSetRepo.GetActive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("No active wallet set found", zap.Error(err))
                // This is not necessarily a failure for health check
        }</span>

        <span class="cov1" title="1">s.logger.Info("Wallet service health check passed")
        return nil</span>
}

// GetProvisioningJobByUserID retrieves the provisioning job for a user
func (s *Service) GetProvisioningJobByUserID(ctx context.Context, userID uuid.UUID) (*entities.WalletProvisioningJob, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting provisioning job for user",
                zap.String("userID", userID.String()))

        job, err := s.provisioningJobRepo.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get provisioning job for user",
                        zap.Error(err),
                        zap.String("userID", userID.String()))
                return nil, fmt.Errorf("failed to get provisioning job: %w", err)
        }</span>

        <span class="cov0" title="0">return job, nil</span>
}

// GetWalletByUserAndChain retrieves a wallet for a specific user and chain
func (s *Service) GetWalletByUserAndChain(ctx context.Context, userID uuid.UUID, chain entities.WalletChain) (*entities.ManagedWallet, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting wallet for user and chain",
                zap.String("userID", userID.String()),
                zap.String("chain", string(chain)))

        wallet, err := s.walletRepo.GetByUserAndChain(ctx, userID, chain)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get wallet for user and chain",
                        zap.Error(err),
                        zap.String("userID", userID.String()),
                        zap.String("chain", string(chain)))
                return nil, fmt.Errorf("failed to get wallet: %w", err)
        }</span>

        <span class="cov0" title="0">return wallet, nil</span>
}

// GetMetrics returns service metrics for monitoring
func (s *Service) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        metrics := s.circleClient.GetMetrics()

        // Add service-specific metrics
        metrics["service"] = "wallet"
        metrics["timestamp"] = time.Now()

        return metrics
}</span>

// SupportedChains returns the configured wallet chains
func (s *Service) SupportedChains() []entities.WalletChain <span class="cov0" title="0">{
        return append([]entities.WalletChain(nil), s.config.SupportedChains...)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package circle

import (
        "bytes"
        "context"
        "crypto/rand"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "math"
        "net/http"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
        "github.com/sony/gobreaker"
        "github.com/stack-service/stack_service/internal/domain/entities"
        entitysecret "github.com/stack-service/stack_service/internal/domain/services/entity_secret"
        "go.uber.org/zap"
)

const (
        // Circle API URLs
        ProductionBaseURL = "https://api.circle.com"
        SandboxBaseURL    = "https://api-sandbox.circle.com"

        // Timeouts and limits
        defaultTimeout    = 30 * time.Second
        maxRetries        = 5
        baseBackoff       = 1 * time.Second
        maxBackoff        = 32 * time.Second
        jitterRange       = 0.1 // 10% jitter
        defaultRetryAfter = 5 * time.Second
        maxRetryAfter     = 60 * time.Second
)

// Config represents Circle API configuration
type Config struct {
        APIKey                 string        `json:"api_key"`
        BaseURL                string        `json:"base_url"`
        Environment            string        `json:"environment"` // "sandbox" or "production"
        Timeout                time.Duration `json:"timeout"`
        WalletSetsEndpoint     string        `json:"wallet_sets_endpoint"`
        WalletsEndpoint        string        `json:"wallets_endpoint"`
        PublicKeyEndpoint      string        `json:"public_key_endpoint"`
        BalancesEndpoint       string        `json:"balances_endpoint"`
        TransferEndpoint       string        `json:"transfer_endpoint"`
        EntitySecretCiphertext string        `json:"entity_secret_ciphertext"` // Pre-registered ciphertext from Circle Dashboard
}

// Client represents a Circle API client
type Client struct {
        config              Config
        httpClient          *http.Client
        circuitBreaker      *gobreaker.CircuitBreaker
        logger              *zap.Logger
        entitySecretService *entitysecret.Service
}

// NewClient creates a new Circle API client
func NewClient(config Config, logger *zap.Logger) *Client <span class="cov0" title="0">{
        if config.Timeout == 0 </span><span class="cov0" title="0">{
                config.Timeout = defaultTimeout
        }</span>

        <span class="cov0" title="0">if config.BaseURL == "" </span><span class="cov0" title="0">{
                if config.Environment == "mainnet" </span><span class="cov0" title="0">{
                        config.BaseURL = ProductionBaseURL
                }</span> else<span class="cov0" title="0"> {
                        // Default to production URL for both testnet and mainnet
                        // Circle Wallet API uses the same base URL for both environments
                        config.BaseURL = ProductionBaseURL
                }</span>
        }
        <span class="cov0" title="0">config.BaseURL = strings.TrimRight(config.BaseURL, "/")

        if config.WalletSetsEndpoint == "" </span><span class="cov0" title="0">{
                config.WalletSetsEndpoint = "/v1/w3s/developer/walletSets"
        }</span>
        <span class="cov0" title="0">if config.WalletsEndpoint == "" </span><span class="cov0" title="0">{
                config.WalletsEndpoint = "/v1/w3s/developer/wallets"
        }</span>
        <span class="cov0" title="0">if config.PublicKeyEndpoint == "" </span><span class="cov0" title="0">{
                config.PublicKeyEndpoint = "/v1/w3s/config/entity/publicKey"
        }</span>
        <span class="cov0" title="0">if config.BalancesEndpoint == "" </span><span class="cov0" title="0">{
                config.BalancesEndpoint = "/v1/w3s/wallets"
        }</span>
        <span class="cov0" title="0">if config.TransferEndpoint == "" </span><span class="cov0" title="0">{
                config.TransferEndpoint = "/v1/w3s/developer/transactions/transfer"
        }</span>

        <span class="cov0" title="0">httpClient := &amp;http.Client{
                Timeout: config.Timeout,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                MinVersion: tls.VersionTLS12,
                        },
                        MaxIdleConns:        100,
                        MaxIdleConnsPerHost: 10,
                        IdleConnTimeout:     90 * time.Second,
                },
        }

        st := gobreaker.Settings{
                Name:        "CircleAPI",
                MaxRequests: 5,
                Interval:    10 * time.Second,
                Timeout:     30 * time.Second,
                ReadyToTrip: func(counts gobreaker.Counts) bool </span><span class="cov0" title="0">{
                        return counts.ConsecutiveFailures &gt; 5
                }</span>,
                OnStateChange: func(name string, from gobreaker.State, to gobreaker.State) <span class="cov0" title="0">{
                        logger.Info("Circuit breaker state changed",
                                zap.String("name", name),
                                zap.String("from", from.String()),
                                zap.String("to", to.String()))
                }</span>,
        }

        <span class="cov0" title="0">circuitBreaker := gobreaker.NewCircuitBreaker(st)

        // Initialize entity secret service for dynamic ciphertext generation (fallback only)
        entitySecretService := entitysecret.NewService(logger)

        if strings.TrimSpace(config.EntitySecretCiphertext) == "" </span><span class="cov0" title="0">{
                logger.Warn("No pre-registered entity secret ciphertext configured. Dynamic generation will be used, but Circle API may reject these requests.")
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Using pre-registered entity secret ciphertext from configuration.")
        }</span>

        <span class="cov0" title="0">return &amp;Client{
                config:              config,
                httpClient:          httpClient,
                circuitBreaker:      circuitBreaker,
                logger:              logger,
                entitySecretService: entitySecretService,
        }</span>
}

// CreateWalletSet creates a new developer-controlled wallet set using pre-registered Entity Secret Ciphertext
func (c *Client) CreateWalletSet(ctx context.Context, name string, _ string) (*entities.CircleWalletSetResponse, error) <span class="cov0" title="0">{

        var entitySecretCipherText string
        var err error

        entitySecretCipherText, err = c.entitySecretService.GenerateEntitySecretCiphertext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate entity secret ciphertext: %w", err)
        }</span>

        // Entity secret service already returns base64-encoded ciphertext
        <span class="cov0" title="0">c.logger.Warn("Using dynamically generated entity secret ciphertext - Circle API may reject this request")

        request := entities.CircleWalletSetRequest{
                IdempotencyKey:         uuid.NewString(),
                EntitySecretCiphertext: entitySecretCipherText,
                Name:                   name,
        }

        c.logger.Info("Creating developer-controlled wallet set",
                zap.String("walletSetName", name))

        var response entities.CircleWalletSetResponse
        _, err = c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "POST", c.config.WalletSetsEndpoint, request, &amp;response)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to create developer-controlled wallet set",
                        zap.String("name", name),
                        zap.Error(err))
                return nil, fmt.Errorf("create wallet set failed: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("response to create wallet set: %+v\n", response)

        c.logger.Info("Created developer-controlled wallet set successfully",
                zap.String("name", name),
                zap.String("walletSetId", response.WalletSet.ID))

        return &amp;response, nil</span>
}

// GetWalletSet retrieves a wallet set by ID
func (c *Client) GetWalletSet(ctx context.Context, walletSetID string) (*entities.CircleWalletSetResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf("%s/%s", c.config.WalletSetsEndpoint, walletSetID)

        var response entities.CircleWalletSetResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get wallet set",
                        zap.String("walletSetId", walletSetID),
                        zap.Error(err))
                return nil, fmt.Errorf("get wallet set failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// CreateWallet creates a new developer-controlled wallet using dynamic Entity Secret Ciphertext
func (c *Client) CreateWallet(ctx context.Context, req entities.CircleWalletCreateRequest) (*entities.CircleWalletCreateResponse, error) <span class="cov0" title="0">{
        if strings.TrimSpace(req.IdempotencyKey) == "" </span><span class="cov0" title="0">{
                req.IdempotencyKey = uuid.NewString()
        }</span>

        // Generate a new unique entity secret ciphertext for this request
        <span class="cov0" title="0">entitySecretCiphertext, err := c.entitySecretService.GenerateEntitySecretCiphertext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate entity secret ciphertext: %w", err)
        }</span>

        // Entity secret service already returns base64-encoded ciphertext
        <span class="cov0" title="0">req.EntitySecretCiphertext = entitySecretCiphertext

        c.logger.Info("Creating developer-controlled wallet",
                zap.String("walletSetId", req.WalletSetID),
                zap.Strings("blockchains", req.Blockchains),
                zap.String("accountType", req.AccountType),
                zap.Int("count", req.Count))

        var response entities.CircleWalletCreateResponse
        _, err = c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "POST", c.config.WalletsEndpoint, req, &amp;response)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to create developer-controlled wallet",
                        zap.String("walletSetId", req.WalletSetID),
                        zap.Strings("blockchains", req.Blockchains),
                        zap.String("accountType", req.AccountType),
                        zap.Int("count", req.Count),
                        zap.Error(err))
                return nil, fmt.Errorf("create wallet failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Created developer-controlled wallet successfully",
                zap.String("walletSetId", req.WalletSetID),
                zap.String("walletId", response.Wallet.ID),
                zap.Strings("blockchains", req.Blockchains))

        return &amp;response, nil</span>
}

// GetWallet retrieves a wallet by ID
func (c *Client) GetWallet(ctx context.Context, walletID string) (*entities.CircleWalletCreateResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf("%s/%s", c.config.WalletsEndpoint, walletID)

        var response entities.CircleWalletCreateResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get wallet",
                        zap.String("walletId", walletID),
                        zap.Error(err))
                return nil, fmt.Errorf("get wallet failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// addJitter adds random jitter to a duration to prevent thundering herd
func addJitter(duration time.Duration) time.Duration <span class="cov0" title="0">{
        // Generate random number between -1 and 1
        randomBytes := make([]byte, 8)
        rand.Read(randomBytes)
        randomFloat := float64(randomBytes[0]) / 255.0 // Normalize to 0-1
        randomFloat = randomFloat*2 - 1                // Convert to -1 to 1

        jitter := time.Duration(float64(duration) * jitterRange * randomFloat)
        return duration + jitter
}</span>

// calculateBackoff calculates exponential backoff with jitter
func calculateBackoff(attempt int, retryAfter *time.Duration) time.Duration <span class="cov0" title="0">{
        var baseDelay time.Duration

        if retryAfter != nil </span><span class="cov0" title="0">{
                baseDelay = *retryAfter
                if baseDelay &gt; maxRetryAfter </span><span class="cov0" title="0">{
                        baseDelay = maxRetryAfter
                }</span>
        } else<span class="cov0" title="0"> {
                // Exponential backoff: 2^attempt * baseBackoff
                exponent := math.Pow(2, float64(attempt))
                baseDelay = time.Duration(exponent) * baseBackoff
                if baseDelay &gt; maxBackoff </span><span class="cov0" title="0">{
                        baseDelay = maxBackoff
                }</span>
        }

        <span class="cov0" title="0">return addJitter(baseDelay)</span>
}

// doRequestWithRetry performs HTTP request with exponential backoff retry and jitter
func (c *Client) doRequestWithRetry(ctx context.Context, method, endpoint string, requestBody, responseBody interface{}) error <span class="cov0" title="0">{
        var lastErr error
        requestID := uuid.NewString()

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        // Check if the last error was a rate limit error with Retry-After
                        var retryAfter *time.Duration
                        if circleErr, ok := lastErr.(entities.CircleAPIError); ok </span><span class="cov0" title="0">{
                                if circleErr.GetRetryAfter() &gt; 0 </span><span class="cov0" title="0">{
                                        ra := circleErr.GetRetryAfter()
                                        retryAfter = &amp;ra
                                }</span>
                        }

                        <span class="cov0" title="0">backoff := calculateBackoff(attempt-1, retryAfter)

                        c.logger.Info("Retrying Circle API request",
                                zap.String("request_id", requestID),
                                zap.Int("attempt", attempt),
                                zap.Duration("backoff", backoff),
                                zap.String("method", method),
                                zap.String("endpoint", endpoint))

                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(backoff):<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov0" title="0">err := c.doRequest(ctx, method, endpoint, requestBody, responseBody, requestID)
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                // Check if error is retryable
                if !c.shouldRetry(err) </span><span class="cov0" title="0">{
                        c.logger.Warn("Not retrying Circle API request due to error type",
                                zap.String("request_id", requestID),
                                zap.Error(err),
                                zap.String("method", method),
                                zap.String("endpoint", endpoint))
                        break</span>
                }

                <span class="cov0" title="0">c.logger.Warn("Circle API request failed, will retry",
                        zap.String("request_id", requestID),
                        zap.Error(err),
                        zap.Int("attempt", attempt+1),
                        zap.Int("maxRetries", maxRetries),
                        zap.String("method", method),
                        zap.String("endpoint", endpoint))</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("request failed after %d attempts: %w", maxRetries+1, lastErr)</span>
}

// doRequest performs a single HTTP request
func (c *Client) doRequest(ctx context.Context, method, endpoint string, requestBody, responseBody interface{}, requestID string) error <span class="cov0" title="0">{
        url := c.config.BaseURL + endpoint

        var reqBody io.Reader
        if requestBody != nil </span><span class="cov0" title="0">{
                jsonData, err := json.Marshal(requestBody)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov0" title="0">reqBody = bytes.NewBuffer(jsonData)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, method, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+c.config.APIKey)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")
        req.Header.Set("User-Agent", "Stack-Service/1.0")
        req.Header.Set("X-Request-ID", requestID)

        c.logger.Debug("Making Circle API request",
                zap.String("request_id", requestID),
                zap.String("method", method),
                zap.String("url", url),
                zap.Any("headers", req.Header))

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Received Circle API response",
                zap.String("request_id", requestID),
                zap.String("method", method),
                zap.String("url", url),
                zap.Int("statusCode", resp.StatusCode),
                zap.String("body", string(body)))

        // Handle error responses
        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return c.handleErrorResponse(resp.StatusCode, body, requestID)
        }</span>

        // Unmarshal successful response
        <span class="cov0" title="0">if responseBody != nil &amp;&amp; len(body) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(body, responseBody); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal response: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleErrorResponse processes Circle API error responses and returns typed errors
func (c *Client) handleErrorResponse(statusCode int, body []byte, requestID string) error <span class="cov0" title="0">{
        // Parse Retry-After header if present
        var retryAfter *time.Duration
        // Note: In a real implementation, you'd get this from the response headers
        // For now, we'll use default values based on status code

        var circleErr entities.CircleErrorResponse
        if err := json.Unmarshal(body, &amp;circleErr); err != nil </span><span class="cov0" title="0">{
                // If we can't parse the error response, create a generic error
                message := fmt.Sprintf("HTTP %d: %s", statusCode, string(body))
                return entities.NewCircleAPIError(statusCode, message, requestID, retryAfter)
        }</span>

        // Set default retry-after for rate limits
        <span class="cov0" title="0">if statusCode == 429 </span><span class="cov0" title="0">{
                defaultRetry := defaultRetryAfter
                retryAfter = &amp;defaultRetry
        }</span>

        // Create typed error
        <span class="cov0" title="0">apiError := entities.NewCircleAPIError(statusCode, circleErr.Message, requestID, retryAfter)

        // Add field errors if present
        if len(circleErr.Errors) &gt; 0 </span><span class="cov0" title="0">{
                if circleAPIErr, ok := apiError.(entities.CircleAPIError); ok </span><span class="cov0" title="0">{
                        circleAPIErr.Errors = circleErr.Errors
                        return circleAPIErr
                }</span>
        }

        <span class="cov0" title="0">return apiError</span>
}

// shouldRetry determines if a request should be retried based on the error
func (c *Client) shouldRetry(err error) bool <span class="cov0" title="0">{
        // Don't retry on context cancellation
        if err == context.Canceled || err == context.DeadlineExceeded </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if it's a Circle API error
        <span class="cov0" title="0">if circleErr, ok := err.(entities.CircleAPIError); ok </span><span class="cov0" title="0">{
                return circleErr.IsRetryable()
        }</span>

        // Check legacy CircleErrorResponse for backward compatibility
        <span class="cov0" title="0">if circleErr, ok := err.(entities.CircleErrorResponse); ok </span><span class="cov0" title="0">{
                // Don't retry on client errors (4xx), except for rate limiting and timeouts
                if circleErr.Code &gt;= 400 &amp;&amp; circleErr.Code &lt; 500 </span><span class="cov0" title="0">{
                        return circleErr.Code == 429 || circleErr.Code == 408
                }</span>
                // Retry on server errors (5xx)
                <span class="cov0" title="0">return circleErr.Code &gt;= 500</span>
        }

        // Retry on network errors
        <span class="cov0" title="0">return true</span>
}

// HealthCheck performs a health check against Circle API
func (c *Client) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Use a simple GET request to wallet sets to check connectivity
        endpoint := c.config.WalletSetsEndpoint

        req, err := http.NewRequestWithContext(ctx, "GET", c.config.BaseURL+endpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create health check request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+c.config.APIKey)
        req.Header.Set("Accept", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("circle API health check failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= 500 </span><span class="cov0" title="0">{
                return fmt.Errorf("circle API health check failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Circle API health check successful", zap.Int("statusCode", resp.StatusCode))
        return nil</span>
}

// GenerateDepositAddress generates a deposit address for the specified chain and user
func (c *Client) GenerateDepositAddress(ctx context.Context, chain entities.WalletChain, userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        // For MVP, we'll simulate address generation based on chain type
        // In production, this would call Circle's actual deposit address generation API
        return "hello", nil
}</span>

// ValidateDeposit validates a deposit transaction using Circle's validation service
func (c *Client) ValidateDeposit(ctx context.Context, txHash string, amount decimal.Decimal) (bool, error) <span class="cov0" title="0">{
        c.logger.Info("Validating deposit",
                zap.String("tx_hash", txHash),
                zap.String("amount", amount.String()))

        // For MVP, we'll simulate validation
        // In production, this would call Circle's transaction validation API

        // Simple validation: check if amount is positive and txHash is not empty
        if amount.IsZero() || amount.IsNegative() </span><span class="cov0" title="0">{
                c.logger.Warn("Invalid deposit amount",
                        zap.String("tx_hash", txHash),
                        zap.String("amount", amount.String()))
                return false, nil
        }</span>

        <span class="cov0" title="0">if txHash == "" </span><span class="cov0" title="0">{
                c.logger.Warn("Empty transaction hash", zap.String("tx_hash", txHash))
                return false, nil
        }</span>

        // For demo purposes, reject transactions with "invalid" in the hash
        <span class="cov0" title="0">if len(txHash) &gt; 7 &amp;&amp; txHash[:7] == "invalid" </span><span class="cov0" title="0">{
                c.logger.Warn("Invalid transaction detected", zap.String("tx_hash", txHash))
                return false, nil
        }</span>

        <span class="cov0" title="0">c.logger.Info("Deposit validation successful",
                zap.String("tx_hash", txHash),
                zap.String("amount", amount.String()))

        return true, nil</span>
}

// ConvertToUSD converts stablecoin amount to USD buying power
func (c *Client) ConvertToUSD(ctx context.Context, amount decimal.Decimal, token entities.Stablecoin) (decimal.Decimal, error) <span class="cov0" title="0">{
        c.logger.Info("Converting to USD",
                zap.String("amount", amount.String()),
                zap.String("token", string(token)))

        // For MVP, we'll use fixed conversion rates
        // In production, this would call Circle's price oracle or conversion API

        var conversionRate decimal.Decimal
        switch token </span>{
        case entities.StablecoinUSDC:<span class="cov0" title="0">
                // USDC is pegged 1:1 to USD
                conversionRate = decimal.NewFromInt(1)</span>
        default:<span class="cov0" title="0">
                return decimal.Zero, fmt.Errorf("unsupported token: %s", token)</span>
        }

        <span class="cov0" title="0">usdAmount := amount.Mul(conversionRate)

        c.logger.Info("Conversion to USD completed",
                zap.String("original_amount", amount.String()),
                zap.String("token", string(token)),
                zap.String("usd_amount", usdAmount.String()),
                zap.String("conversion_rate", conversionRate.String()))

        return usdAmount, nil</span>
}

// GetEntityPublicKey retrieves the entity's public key (optional if using pre-registered ciphertext)
func (c *Client) GetEntityPublicKey(ctx context.Context) (string, error) <span class="cov0" title="0">{
        c.logger.Info("Retrieving entity public key")

        var response map[string]interface{}
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", c.config.PublicKeyEndpoint, nil, &amp;response)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get entity public key", zap.Error(err))
                return "", fmt.Errorf("get entity public key failed: %w", err)
        }</span>

        // Extract public key from response
        <span class="cov0" title="0">if publicKey, ok := response["publicKey"].(string); ok </span><span class="cov0" title="0">{
                c.logger.Info("Retrieved entity public key successfully")
                return publicKey, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("public key not found in response")</span>
}

// GetWalletBalances retrieves token balances for a specific wallet
// tokenAddress is optional - if provided, filters results to only that token
func (c *Client) GetWalletBalances(ctx context.Context, walletID string, tokenAddress ...string) (*entities.CircleWalletBalancesResponse, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf("%s/%s/balances", c.config.BalancesEndpoint, walletID)

        // Add tokenAddress query parameter if provided
        if len(tokenAddress) &gt; 0 &amp;&amp; tokenAddress[0] != "" </span><span class="cov0" title="0">{
                endpoint = fmt.Sprintf("%s?tokenAddress=%s", endpoint, tokenAddress[0])
                c.logger.Info("Getting wallet balances",
                        zap.String("walletId", walletID),
                        zap.String("tokenAddress", tokenAddress[0]),
                        zap.String("endpoint", endpoint),
                        zap.String("fullURL", c.config.BaseURL+endpoint))
        }</span> else<span class="cov0" title="0"> {
                c.logger.Info("Getting wallet balances",
                        zap.String("walletId", walletID),
                        zap.String("endpoint", endpoint),
                        zap.String("fullURL", c.config.BaseURL+endpoint))
        }</span>

        <span class="cov0" title="0">var response entities.CircleWalletBalancesResponse
        _, err := c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "GET", endpoint, nil, &amp;response)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get wallet balances",
                        zap.String("walletId", walletID),
                        zap.Error(err))
                return nil, fmt.Errorf("get wallet balances failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Retrieved wallet balances successfully",
                zap.String("walletId", walletID),
                zap.Int("tokenCount", len(response.TokenBalances)),
                zap.String("usdcBalance", response.GetUSDCBalance()))
        c.logger.Info("log the response", zap.Any("response", response))

        return &amp;response, nil</span>
}

// TransferFunds transfers funds between accounts using developer-controlled wallets
func (c *Client) TransferFunds(ctx context.Context, req entities.CircleTransferRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Generate a new unique entity secret ciphertext for this request
        entitySecretCiphertext, err := c.entitySecretService.GenerateEntitySecretCiphertext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate entity secret ciphertext: %w", err)
        }</span>

        // Entity secret service already returns base64-encoded ciphertext
        <span class="cov0" title="0">req.EntitySecretCiphertext = entitySecretCiphertext

        c.logger.Info("Transferring funds",
                zap.String("walletId", req.WalletID),
                zap.Strings("amounts", req.Amounts),
                zap.String("tokenId", req.TokenID))

        var response map[string]interface{}
        _, err = c.circuitBreaker.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return &amp;response, c.doRequestWithRetry(ctx, "POST", c.config.TransferEndpoint, req, &amp;response)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to transfer funds",
                        zap.String("walletId", req.WalletID),
                        zap.Strings("amounts", req.Amounts),
                        zap.Error(err))
                return nil, fmt.Errorf("transfer funds failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Transfer completed successfully",
                zap.String("walletId", req.WalletID),
                zap.Strings("amounts", req.Amounts))

        return response, nil</span>
}

// GetMetrics returns circuit breaker metrics for monitoring
func (c *Client) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        counts := c.circuitBreaker.Counts()
        return map[string]interface{}{
                "circuit_breaker_state": c.circuitBreaker.State().String(),
                "requests":              counts.Requests,
                "consecutive_successes": counts.ConsecutiveSuccesses,
                "consecutive_failures":  counts.ConsecutiveFailures,
                "total_successes":       counts.TotalSuccesses,
                "total_failures":        counts.TotalFailures,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package retry

import (
        "context"
        "fmt"
        "math"
        "time"
)

// RetryConfig holds configuration for retry behavior
type RetryConfig struct {
        MaxAttempts int           // Maximum number of retry attempts
        BaseDelay   time.Duration // Base delay between retries
        MaxDelay    time.Duration // Maximum delay between retries
        Multiplier  float64       // Backoff multiplier
}

// DefaultConfig returns a default retry configuration
func DefaultConfig() RetryConfig <span class="cov0" title="0">{
        return RetryConfig{
                MaxAttempts: 3,
                BaseDelay:   100 * time.Millisecond,
                MaxDelay:    30 * time.Second,
                Multiplier:  2.0,
        }
}</span>

// RetryableFunc represents a function that can be retried
type RetryableFunc func() error

// IsRetryableFunc determines if an error should trigger a retry
type IsRetryableFunc func(error) bool

// WithExponentialBackoff retries a function with exponential backoff
func WithExponentialBackoff(
        ctx context.Context,
        config RetryConfig,
        fn RetryableFunc,
        isRetryable IsRetryableFunc,
) error <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt; config.MaxAttempts; attempt++ </span><span class="cov0" title="0">{
                // Execute the function
                err := fn()
                if err == nil </span><span class="cov0" title="0">{
                        return nil // Success
                }</span>

                <span class="cov0" title="0">lastErr = err

                // Check if we should retry
                if !isRetryable(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("non-retryable error: %w", err)
                }</span>

                // Don't wait after the last attempt
                <span class="cov0" title="0">if attempt == config.MaxAttempts-1 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Calculate delay with exponential backoff
                <span class="cov0" title="0">delay := time.Duration(float64(config.BaseDelay) * math.Pow(config.Multiplier, float64(attempt)))
                if delay &gt; config.MaxDelay </span><span class="cov0" title="0">{
                        delay = config.MaxDelay
                }</span>

                // Wait for the calculated delay or context cancellation
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("retry cancelled by context: %w", ctx.Err())</span>
                case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        // Continue to next attempt
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("max retry attempts (%d) exceeded: %w", config.MaxAttempts, lastErr)</span>
}

// IsTemporaryError is a common retry predicate for temporary/transient errors
func IsTemporaryError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Add logic to identify temporary errors
        // This could be based on error types, messages, HTTP status codes, etc.
        <span class="cov0" title="0">errorStr := err.Error()

        // Common temporary error patterns
        temporaryPatterns := []string{
                "connection refused",
                "timeout",
                "temporary failure",
                "service unavailable",
                "internal server error",
                "too many requests",
                "rate limited",
                "network is unreachable",
                "no route to host",
                "connection reset",
        }

        for _, pattern := range temporaryPatterns </span><span class="cov0" title="0">{
                if contains(errorStr, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// contains is a simple substring check helper
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp;
                (s == substr ||
                        (len(s) &gt; len(substr) &amp;&amp;
                                (s[:len(substr)] == substr ||
                                        s[len(s)-len(substr):] == substr ||
                                        indexOf(s, substr) != -1)))
}</span>

// indexOf returns the index of substr in s, or -1 if not found
func indexOf(s, substr string) int <span class="cov0" title="0">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package webhook

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "strings"
        "time"
)

// SignatureValidator validates webhook signatures using HMAC-SHA256
type SignatureValidator struct {
        secret []byte
}

// NewSignatureValidator creates a new signature validator with the given secret
func NewSignatureValidator(secret string) *SignatureValidator <span class="cov0" title="0">{
        return &amp;SignatureValidator{
                secret: []byte(secret),
        }
}</span>

// ValidateSignature validates an HMAC-SHA256 signature against the payload
func (v *SignatureValidator) ValidateSignature(payload []byte, signature string) error <span class="cov0" title="0">{
        if signature == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing signature")
        }</span>

        // Remove common prefixes if present
        <span class="cov0" title="0">signature = strings.TrimPrefix(signature, "sha256=")
        signature = strings.TrimPrefix(signature, "hmac-sha256=")

        // Calculate expected signature
        expectedSignature := v.calculateSignature(payload)

        // Compare signatures using constant-time comparison to prevent timing attacks
        if !hmac.Equal([]byte(expectedSignature), []byte(signature)) </span><span class="cov0" title="0">{
                return fmt.Errorf("signature verification failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// calculateSignature computes HMAC-SHA256 signature for the payload
func (v *SignatureValidator) calculateSignature(payload []byte) string <span class="cov0" title="0">{
        h := hmac.New(sha256.New, v.secret)
        h.Write(payload)
        return hex.EncodeToString(h.Sum(nil))
}</span>

// GenerateSignature generates an HMAC-SHA256 signature for testing purposes
func (v *SignatureValidator) GenerateSignature(payload []byte) string <span class="cov0" title="0">{
        return "sha256=" + v.calculateSignature(payload)
}</span>

// ValidateTimestamp checks if the webhook timestamp is within acceptable bounds
// This helps prevent replay attacks
func ValidateTimestamp(timestamp int64, maxAge int64) error <span class="cov0" title="0">{
        if timestamp &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid timestamp")
        }</span>

        <span class="cov0" title="0">currentTime := getCurrentTimestamp()
        if timestamp &gt; currentTime </span><span class="cov0" title="0">{
                return fmt.Errorf("timestamp is in the future")
        }</span>

        <span class="cov0" title="0">if currentTime-timestamp &gt; maxAge </span><span class="cov0" title="0">{
                return fmt.Errorf("timestamp is too old")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getCurrentTimestamp returns current Unix timestamp
func getCurrentTimestamp() int64 <span class="cov0" title="0">{
        return time.Now().Unix()
}</span>

// WebhookSecurityConfig holds configuration for webhook security
type WebhookSecurityConfig struct {
        Secret            string   // HMAC secret key
        MaxTimestampAge   int64    // Maximum age of timestamp in seconds (e.g., 300 for 5 minutes)
        RequireSignature  bool     // Whether signature is required
        RequireTimestamp  bool     // Whether timestamp validation is required
        TrustedUserAgents []string // List of trusted user agents (optional)
        MaxPayloadSize    int64    // Maximum payload size in bytes
}

// DefaultWebhookConfig returns a secure default configuration
func DefaultWebhookConfig() WebhookSecurityConfig <span class="cov0" title="0">{
        return WebhookSecurityConfig{
                Secret:           "",  // Must be provided
                MaxTimestampAge:  300, // 5 minutes
                RequireSignature: true,
                RequireTimestamp: false,       // Set to true if webhooks include timestamp
                MaxPayloadSize:   1024 * 1024, // 1MB
        }
}</span>

// WebhookValidator provides comprehensive webhook validation
type WebhookValidator struct {
        config       WebhookSecurityConfig
        sigValidator *SignatureValidator
}

// NewWebhookValidator creates a new webhook validator
func NewWebhookValidator(config WebhookSecurityConfig) *WebhookValidator <span class="cov0" title="0">{
        var sigValidator *SignatureValidator
        if config.RequireSignature &amp;&amp; config.Secret != "" </span><span class="cov0" title="0">{
                sigValidator = NewSignatureValidator(config.Secret)
        }</span>

        <span class="cov0" title="0">return &amp;WebhookValidator{
                config:       config,
                sigValidator: sigValidator,
        }</span>
}

// ValidateRequest performs comprehensive webhook request validation
func (v *WebhookValidator) ValidateRequest(payload []byte, signature string, timestamp int64, userAgent string) error <span class="cov0" title="0">{
        // Check payload size
        if v.config.MaxPayloadSize &gt; 0 &amp;&amp; int64(len(payload)) &gt; v.config.MaxPayloadSize </span><span class="cov0" title="0">{
                return fmt.Errorf("payload too large: %d bytes (max: %d)", len(payload), v.config.MaxPayloadSize)
        }</span>

        // Validate signature if required
        <span class="cov0" title="0">if v.config.RequireSignature </span><span class="cov0" title="0">{
                if v.sigValidator == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("signature validation required but no secret configured")
                }</span>
                <span class="cov0" title="0">if err := v.sigValidator.ValidateSignature(payload, signature); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("signature validation failed: %w", err)
                }</span>
        }

        // Validate timestamp if required
        <span class="cov0" title="0">if v.config.RequireTimestamp </span><span class="cov0" title="0">{
                if err := ValidateTimestamp(timestamp, v.config.MaxTimestampAge); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("timestamp validation failed: %w", err)
                }</span>
        }

        // Validate user agent if configured
        <span class="cov0" title="0">if len(v.config.TrustedUserAgents) &gt; 0 </span><span class="cov0" title="0">{
                trusted := false
                for _, trustedUA := range v.config.TrustedUserAgents </span><span class="cov0" title="0">{
                        if strings.Contains(userAgent, trustedUA) </span><span class="cov0" title="0">{
                                trusted = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !trusted </span><span class="cov0" title="0">{
                        return fmt.Errorf("untrusted user agent: %s", userAgent)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
